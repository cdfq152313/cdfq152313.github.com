<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ios on Denny&#39;s Blog</title>
    <link>https://cdfq152313.github.io/tags/ios/index.xml</link>
    <description>Recent content in Ios on Denny&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <atom:link href="https://cdfq152313.github.io/tags/ios/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Swift Mail &amp; Message</title>
      <link>https://cdfq152313.github.io/post/2016-11-02/</link>
      <pubDate>Wed, 02 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-11-02/</guid>
      <description>

&lt;h2 id=&#34;mail&#34;&gt;Mail&lt;/h2&gt;

&lt;p&gt;不能在模擬器上跑，會crash。&lt;/p&gt;

&lt;h3 id=&#34;簡單流程&#34;&gt;簡單流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;初始化MFMailComposeViewController&lt;/li&gt;
&lt;li&gt;設定標題以及收件者&lt;/li&gt;
&lt;li&gt;推出MFMailComposeViewController&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import MessageUI

func sendMail(){
  let mailController = MFMailComposeViewController()
  mailController.setSubject(&amp;quot;swift程式設計入門&amp;quot;)
  mailController.setToRecipients([&amp;quot;cdfq152313@gmail.com&amp;quot;])
  self.present(mailController, animated: true, completion: nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;測試能不能使用mail功能&#34;&gt;測試能不能使用Mail功能&lt;/h3&gt;

&lt;p&gt;像是在模擬器上就不能使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if MFMailComposeViewController.canSendMail(){
	// 可以寄信
}
else{
	// 不能寄信
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mailcomposedelegate&#34;&gt;mailComposeDelegate&lt;/h3&gt;

&lt;p&gt;設定mailComposeDelegate可以讓寄信完後，dismiss到原來畫面，這邊要注意的是不要設成一般delegate了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;mailController.mailComposeDelegate = self

func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) {
		dismiss(animated: true, completion: nil)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想知道寄信後的狀態可參考第二個參數didFinishWith result。按住command + 滑鼠左鍵在MFMailCompseResult可以知道有下列狀態。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public enum MFMailComposeResult : Int {
    case cancelled
    case saved
    case sent
    case failed
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;夾帶圖片&#34;&gt;夾帶圖片&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 夾一張圖片
func mailCo
var image = UIImage(named: &amp;quot;book1&amp;quot;)
var data = UIImageJPEGRepresentation(image!, 0.9)
mailController.addAttachmentData(data!, mimeType:&amp;quot;image/jpg&amp;quot;, fileName: &amp;quot;book1.jpg&amp;quot;)

// 可以夾不只一個圖片
image = UIImage(named: &amp;quot;book2&amp;quot;)
data = UIImageJPEGRepresentation(image!, 0.9)
mailController.addAttachmentData(data!, mimeType: &amp;quot;image/jpg&amp;quot;, fileName: &amp;quot;book2.jpg&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;放置html檔&#34;&gt;放置HTML檔&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let body = &amp;quot;&amp;lt;h1&amp;gt;HelloWorld&amp;lt;/h1&amp;gt;&amp;quot;
mailController.setMessageBody(body, isHTML:true)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;message&#34;&gt;Message&lt;/h2&gt;

&lt;p&gt;同樣不能在模擬器上跑，會crash。&lt;/p&gt;

&lt;h3 id=&#34;簡單流程-1&#34;&gt;簡單流程&lt;/h3&gt;

&lt;p&gt;由於是訊息，只要填body即可。收件者可以是&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;人名&lt;/li&gt;
&lt;li&gt;手機號碼&lt;/li&gt;
&lt;li&gt;郵件信箱&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func sendMessage(){
  let controller = MFMessageComposeViewController()
  controller.body = &amp;quot;hello&amp;quot;
  controller.recipients = [&amp;quot;Denny&amp;quot;, &amp;quot;0978948787&amp;quot;, &amp;quot;cdfq152313@gmail.com&amp;quot;]
  self.present(controller, animated: true, completion: nil)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Swift TableView 與 Collection View</title>
      <link>https://cdfq152313.github.io/post/2016-10-25/</link>
      <pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-10-25/</guid>
      <description>

&lt;h2 id=&#34;tableview&#34;&gt;TableView&lt;/h2&gt;

&lt;h3 id=&#34;indexpath-section-row&#34;&gt;IndexPath: Section &amp;amp; Row&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/razNcl9.png&#34; alt=&#34;Section and Row&#34; /&gt;&lt;/p&gt;

&lt;p&gt;看圖應該可以明瞭Section和Row的含意，Apple把tableView劃分為section，每個section下又有row。&lt;br /&gt;
在IOS中有一個叫做IndexPath的類別專門儲存這兩個值，在tableView以後要override的方法會經常看到。&lt;/p&gt;

&lt;h3 id=&#34;必定要override的method-幾個section-幾個row&#34;&gt;必定要override的method: 幾個section 幾個row&lt;/h3&gt;

&lt;p&gt;使用tableView必須指定DataSource和Delegate (若是TableViewController則已經指定好自己作為這兩個protocol的實作)&lt;br /&gt;
其中有些function是必定要override的&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;總共有幾個section&lt;/li&gt;
&lt;li&gt;每個section裡面有幾個row&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在這個範例中，我指定兩個section，section 0有2 row，section 1有3 row。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 總共幾個section
override func numberOfSections(in tableView: UITableView) -&amp;gt; Int {
  return 2
}

// 每個section裡面有幾個row
override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
	if section == 0{
  	return 2
  }
  else{
  	return 3
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;某一列的內容&#34;&gt;某一列的內容&lt;/h3&gt;

&lt;p&gt;但是只有這樣，顯示出來會是空白一片，所以必須要回傳顯示的內容。&lt;br /&gt;
在做這個項目之前，必須先到storyBoard，將tableView裏頭的cell指定一個identifier，否則會錯誤。&lt;br /&gt;
在此我指定cell的identifier為myCell&lt;br /&gt;
&lt;img src=&#34;http://i.imgur.com/0mgnfd6.png&#34; alt=&#34;Identifier&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然後才可以在程式碼中使用myCell&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
  let cell = tableView.dequeueReusableCell(withIdentifier: &amp;quot;myCell&amp;quot;, for: indexPath)

  // 顯示目前是第幾Row
  cell.textLabel?.text = &amp;quot;Row &amp;quot; + String(indexPath.row)
  return cell
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/MFz1Rhv.png&#34; alt=&#34;目前畫面&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;section-title&#34;&gt;Section Title&lt;/h3&gt;

&lt;p&gt;但是這樣少了每個section的title，沒有段落感，所以用以下的code加上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&amp;gt; String? {
  if section == 0{
  	return &amp;quot;Section 0&amp;quot;
  }
  else{
  	return &amp;quot;Section 1&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/razNcl9.png&#34; alt=&#34;目前畫面&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;點擊某列跳轉到下一個controller-並傳值&#34;&gt;點擊某列跳轉到下一個Controller，並傳值&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://dennycheng-blog.logdown.com/posts/946492-controller-interaction&#34;&gt;請參閱之前的傳值方法&lt;/a&gt;，我們選用方法一。這邊要補充的是：可以藉由tableview中的indexPathForselectedRow屬性來得知哪一列被選中。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在prepare裡裡面進行傳值的預備動作。&lt;/li&gt;
&lt;li&gt;轉型Controller，這樣才可以塞property

&lt;ul&gt;
&lt;li&gt;在此我們假設SecondViewController中有selectedIndexPath這個屬性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可以藉由tableView中的indexPathForselectedRow來判定哪個Row被選中。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
  if let indexPath = tableView.indexPathForSelectedRow{
    let controller = segue.destination as! SecondViewController
    controller.selectedIndexPath = indexPath
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;滑動刪除&#34;&gt;滑動刪除&lt;/h3&gt;

&lt;p&gt;只要複寫方法即可，記得必須同時刪除實際的Array以及畫面上的元件，否則會造成畫面與實際資料不同步的問題。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {
  if editingStyle == .delete {
    // 刪除元素
    myArray.remove(at: indexPath.row)
    // 刪除畫面上的元素
    tableView.deleteRows(at: [indexPath], with: .fade)
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但使用這個方法，只能滑出一個按鈕。如果想滑動時有多個按鈕可以選擇請看下節。&lt;/p&gt;

&lt;h3 id=&#34;自訂滑動選項&#34;&gt;自訂滑動選項&lt;/h3&gt;

&lt;p&gt;如果想要自訂滑動按鈕的文字樣式，或是想指定多個滑動按鈕，那就不能使用上述的複寫方法。而必須改用下面這個。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;複寫方法&lt;/li&gt;
&lt;li&gt;自訂UITableViewRowAction&lt;/li&gt;
&lt;li&gt;回傳UITableViewRowAction陣列&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因為此方法回傳陣列，所以可以塞進多個按鈕。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&amp;gt; [UITableViewRowAction]? {
        let addAction = UITableViewRowAction(style: .normal, title: &amp;quot;insert&amp;quot;) { 
        	(action, indexPath) in
          // 下面可寫插入元素的動作  
        }
        
        let deleteAction = UITableViewRowAction(style: .default, title: &amp;quot;delete&amp;quot;) { 
        	(action, indexPath) in
          // 下面可寫刪除元素的動作  
        }
        return [deleteAction, addAction]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;更新畫面的method&#34;&gt;更新畫面的method&lt;/h3&gt;

&lt;p&gt;TableView裡面有三個method可以更新畫面。列表如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;刪除：需提供IndexPath的陣列，一次可以刪一串。&lt;/li&gt;
&lt;li&gt;插入：需提供IndexPath的陣列，一次可以加入一串。&lt;/li&gt;
&lt;li&gt;重新整理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;程式碼如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;tableView.deleteRows(at: [indexPath], with: .fade)
tableView.insertRows(at: [indexPath], with: .fade)
tableView.reloadData()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;更換位置&#34;&gt;更換位置&lt;/h3&gt;

&lt;h3 id=&#34;下拉更新&#34;&gt;下拉更新&lt;/h3&gt;

&lt;p&gt;常常會看到有APP在tableView下拉時畫面會開始轉圈圈，然後更新，現在試著製作這個效果。
1. 在StoryBoard中點選TableViewController。
2. 將Refreshing設定成enable
3. 此時左方會出現一個Refresh Control，將其拉到程式碼中，選擇Action，動作為value changed。
    - &lt;img src=&#34;http://i.imgur.com/QYt5WVC.png&#34; alt=&#34;設定&#34; /&gt;
4. 接下來就可以對剛剛拉出的action做一些事，做完後使用self.refreshControl?.endRefreshing()，就可以結束轉圈圈的畫面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  @IBAction func reload(_ sender: AnyObject) {
      // do something
      self.refreshControl?.endRefreshing()
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;搜尋&#34;&gt;搜尋&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let searchController = UISearchController(searchResultsController: nil)
searchController.searchResultsUpdater = self
self.tableView.tableHeaderView = searchController.searchBar
searchController.dimsBackgroundDuringPresentation = false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;uicollectionview&#34;&gt;UICollectionView&lt;/h2&gt;

&lt;h3 id=&#34;uicollectionviewdelegateflowlayout&#34;&gt;UICollectionViewDelegateFlowLayout&lt;/h3&gt;

&lt;p&gt;可以調整cell的大小&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift Map 地圖功能</title>
      <link>https://cdfq152313.github.io/post/2016-10-21/</link>
      <pubDate>Fri, 21 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-10-21/</guid>
      <description>

&lt;h2 id=&#34;環境設定&#34;&gt;環境設定&lt;/h2&gt;

&lt;h3 id=&#34;權限&#34;&gt;權限&lt;/h3&gt;

&lt;p&gt;開啟地圖本身不需要權限，如果若需要GPS位置，請在info.plist中開啟&lt;br /&gt;
&lt;img src=&#34;http://i.imgur.com/sHeMOKN.png&#34; alt=&#34;Alt Text&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;storyboard-iboutlet&#34;&gt;StoryBoard &amp;amp; IBOutlet&lt;/h3&gt;

&lt;p&gt;在StoryBoard上地圖套件名稱叫做&lt;strong&gt;Map Kit View&lt;/strong&gt;&lt;br /&gt;
如果想要拉IBOutlet到自己的class中，會發現出現Error，這是因為Map class並不包含在UIKit當中。&lt;br /&gt;
所以請import Mapkit&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Mapkit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;mkmapviewdelegate&#34;&gt;MKMapViewDelegate&lt;/h3&gt;

&lt;p&gt;最後就是記得設定mapView的delegate&lt;br /&gt;
如果需要特殊效果的時候非常有用，例如：開始讀取map位置的時候要做什麼，結束讀取位置的時候要做什麼&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;將地址解析為gps&#34;&gt;將地址解析為GPS&lt;/h3&gt;

&lt;p&gt;可以利用CLGeocoder這個class來達成，以下是一個簡單的範例&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始化CLGeocoder&lt;/li&gt;
&lt;li&gt;使用geocodeAddressString此方法，傳入兩個參數

&lt;ul&gt;
&lt;li&gt;需解析之address (字串)&lt;/li&gt;
&lt;li&gt;解析完後的動作(closure)，參數如下&lt;/li&gt;
&lt;li&gt;[CLPlacemark]?: 一個地址有多個可能符合之GPS位置，所以是一個Array。&lt;/li&gt;
&lt;li&gt;Error?: 若無則為nil&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在closure當中，把經緯度印出來

&lt;ul&gt;
&lt;li&gt;我們可以從CLPlacemark的location屬性當中，找到經度和緯度。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 初始化
let geoCoder = CLGeocoder()

// 解析字串
geoCoder.geocodeAddressString(address) {
	(places, error) in
  // 如果解析失敗，直接回傳不做任何事
	guard error == nil else {
		print (&amp;quot;Get position error&amp;quot;)
		return
	}
	
  // 印出位置
	if(places?.count)! &amp;gt; 0 {
		let placeMark = places?.first
		print(&amp;quot;Location: \(placeMark?.location)&amp;quot;)
	}

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;標註位置&#34;&gt;標註位置&lt;/h2&gt;

&lt;p&gt;先拿到要標註的GPS位置，再開始進行標註。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始化MKPointAnnotation&lt;/li&gt;
&lt;li&gt;設定title / subtitle / image等等欄位&lt;/li&gt;
&lt;li&gt;設定GPS位置&lt;/li&gt;
&lt;li&gt;使用方法addAnnotation方法將大頭針插在地圖上&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func setAnnotation(placeMark:CLPlacemark){
    // 開始進行標註
    let annotation = MKPointAnnotation()
    annotation.title = &amp;quot;Hello~~&amp;quot;
    annotation.subtitle = &amp;quot;Moto&amp;quot;
    annotation.coordinate = (placeMark.location?.coordinate)!
    self.mapView.addAnnotation(annotation)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;將畫面拉到特定位置&#34;&gt;將畫面拉到特定位置&lt;/h2&gt;

&lt;p&gt;標註畫面只是將大頭針插上位置，地圖並沒有移動。如果想要將地圖zoom in到某個地點附近，就必須使用這個功能。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始化座標，需要使用到經緯度。&lt;/li&gt;
&lt;li&gt;初始化想顯示範圍，MKCoordinateSpanMake的兩個參數分別代表經緯度長度。&lt;/li&gt;
&lt;li&gt;用上述兩個參數初始化MKCoordinateRegion&lt;/li&gt;
&lt;li&gt;使用setRegion方法&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func zoomInMap(placeMark:CLPlacemark){
		// set region
    let cl2d = CLLocationCoordinate2D(latitude: (placeMark.location?.coordinate.latitude)!, longitude: (placeMark.location?.coordinate.longitude)!)
		let span = MKCoordinateSpanMake(0.075, 0.075)
		let region = MKCoordinateRegion(center: cl2d, span: span)
		self.mapView.setRegion(region, animated: true)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;以下難產中&#34;&gt;以下難產中&lt;/h2&gt;

&lt;h2 id=&#34;mapkit-位置改變時定位&#34;&gt;MapKit 位置改變時定位&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Swift 多執行緒與檔案下載</title>
      <link>https://cdfq152313.github.io/post/2016-10-14/</link>
      <pubDate>Fri, 14 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-10-14/</guid>
      <description>

&lt;p&gt;Swift的執行緒分為主要和背景。
Main Queue / Concurrent Queue
主執行緒不能執行同步工作，只能執行非同步工作。&lt;/p&gt;

&lt;h2 id=&#34;主執行緒語法&#34;&gt;主執行緒語法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let task1 = {
	for i in 1...5{
		print (&amp;quot;Task1: (\i)&amp;quot;)
	}
}

// DispatchQueue.main.sync(execute: task1)
DispatchQueue.main.async(execute: task1)

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;背景執行緒語法&#34;&gt;背景執行緒語法&lt;/h2&gt;

&lt;p&gt;不指定執行緒&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;DispatchQueue.global().sync(execute: task1)
DispatchQueue.global().async(execute: task1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定執行緒&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;DispatchQueue.global(qos: .background).sync(execute:task1)
DispatchQueue.global(qos: .background).async(execute:task1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;下載方法&#34;&gt;下載方法&lt;/h2&gt;

&lt;h3 id=&#34;nsdata&#34;&gt;NSData&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;利用url生出網址&lt;/li&gt;
&lt;li&gt;利用Data Class下載(以前叫NSData)&lt;/li&gt;
&lt;li&gt;把下載下來的資料指定給想要的檔案&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;記得要使用DispatchQueue.global().async使用此function，否則畫面會被block住。&lt;br /&gt;
下載完畢後要更新UI時要使用ispatchQueue.main.async否則畫面不會即時更新。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func download(){
  if let url = URL(string: &amp;quot;http://www.carlosicaza.com/wp-content/uploads/2014/07/Swift-logo.png&amp;quot;){
    do {
      let data = try Data(contentsOf:url)
      let image = UIImage(data:data)
      DispatchQueue.main.async{
        self.myImage.image = image
      }
    }
    catch{
      print(&amp;quot;Cannot download image&amp;quot;)
    }
  }
}

DispatchQueue.global().async {
	self.download()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;session&#34;&gt;Session&lt;/h3&gt;

&lt;p&gt;改利用Session來下載&lt;br /&gt;
Session的ataTask本身即是非同步，所以不會擋住UI畫面。&lt;br /&gt;
一樣在任務結束要更新UI時要使用main thread來更新。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;利用url生出網址&lt;/li&gt;
&lt;li&gt;利用Session的dataTask

&lt;ul&gt;
&lt;li&gt;指定網址&lt;/li&gt;
&lt;li&gt;指定下載完成後要做的事 (若要更新UI，記得要在Mainthread執行)&lt;/li&gt;
&lt;li&gt;會回傳一個URLSessionDataTask的instance作為此任務的標記&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;將剛剛接收到的instance.resume()才會開始執行任務&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;self.image = nil
let task = session.dataTask(with: url) {
    (data, response, error) in
    if error != nil{
        return
    }
    
    if let loadedData = data{
        let loadedImage = UIImage(data: loadedData)
        DispatchQueue.main.async{
            self.image = loadedImage
            self.loading?.stopAnimating()
        }
    }
    
}
task.resume()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Swift 檔案路徑與讀寫檔</title>
      <link>https://cdfq152313.github.io/post/2016-10-11/</link>
      <pubDate>Tue, 11 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-10-11/</guid>
      <description>

&lt;h2 id=&#34;ios的路徑&#34;&gt;iOS的路徑&lt;/h2&gt;

&lt;h3 id=&#34;專案資料夾內的路徑&#34;&gt;專案資料夾內的路徑&lt;/h3&gt;

&lt;p&gt;利用Bundle.main獲取
可以指定檔案名稱以及副檔名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 得到url
let url = Bundle.main.url(forResource: &amp;quot;myjson&amp;quot;, withExtension: &amp;quot;json&amp;quot;)
// 得到path
let path = Bundle.main.path(forResource: &amp;quot;myjson&amp;quot;, ofType: &amp;quot;json&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一般app路徑&#34;&gt;一般App路徑&lt;/h3&gt;

&lt;p&gt;Document範例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 透過路徑尋找URL
let path = NSHomeDirectory() + &amp;quot;/Document&amp;quot;
let urlfrompath = URL(fileURLWithPath: path)

// 直接拿取URL，陣列第0個是資料夾本身(雖然也只有一個url)
let url = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Caches 範例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 透過路徑尋找URL
let path = NSHomeDirectory() + &amp;quot;/Library/Caches&amp;quot;
let urlfrompath = URL(fileURLWithPath: path)

// 直接拿取URL
let url = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask)[0]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Temp 範例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 兩種路徑取得的方法
let pathFromNSHome = NSHomeDirectory() + &amp;quot;/tmp&amp;quot;
let pathFromLibrary = NSTemporaryDirectory()

// URL
let urlfrompath = URL(fileURLWithPath: pathFromNSHome)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;新增路徑&#34;&gt;新增路徑&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;將想要新增的路徑名稱寫出來&lt;/li&gt;
&lt;li&gt;利用FileManager.default.createDirectory新增路徑

&lt;ul&gt;
&lt;li&gt;此方法的withIntermediateDirctories參數若設成true，可以幫你遞迴建立不存在的資料夾&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let directoryPath = NSTemporaryDirectory() + &amp;quot;/images&amp;quot;
do{
	try FileManager.default.createDirectory(atPath: directoryPath, withIntermediateDirectories: true, attributes: nil)
}catch{
	print(&amp;quot;Cannot create directory&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;列出某個路徑下的所有檔案&#34;&gt;列出某個路徑下的所有檔案&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;先找到想列出檔案的路徑&lt;/li&gt;
&lt;li&gt;利用 FileManager.default.contentsOfDirectory來列出此資料夾底下的檔案&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let tempPath = NSTemporaryDirectory()
do{
  let fileList = try FileManager.default.contentsOfDirectory(atPath: tempPath)
  for file in fileList{
  	print(file)
  }
}
catch{
	print(&amp;quot;Cannot list directory&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;查看路徑資訊&#34;&gt;查看路徑資訊&lt;/h3&gt;

&lt;p&gt;FileManager.default.fileExists 可以幫你查看這個檔案是否存在，以及該檔案是否為一個Directory。&lt;br /&gt;
需要特別注意的是OBJCBool的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let path = NSTemporaryDirectory() + &amp;quot;/images&amp;quot;
var isDirectory:ObjCBool = false
let isExist = FileManager.default.fileExists(atPath: path, isDirectory: &amp;amp;isDirectory)
if isExist == true &amp;amp;&amp;amp; isDirectory.boolValue == true{
	print(&amp;quot;File exist and it is a direcotry&amp;quot;)
}
else if isExist == true &amp;amp;&amp;amp; isDirectory.boolValue == false{
	print(&amp;quot;File exist but it is not a direcotry&amp;quot;)
}
else{
	print(&amp;quot;File isn&#39;t exist&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;複製貼上刪除檔案&#34;&gt;複製貼上刪除檔案&lt;/h3&gt;

&lt;p&gt;使用下方函式，記得加上do try catch。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;FileManager.default.copyItem(atPath: path, toPath: cpPath)
FileManager.default.moveItem(atPath: path, toPath: mvPath)
FileManager.default.removeItem(atPath: path)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;一般型別寫檔讀檔&#34;&gt;一般型別寫檔讀檔&lt;/h2&gt;

&lt;h3 id=&#34;讀寫string&#34;&gt;讀寫String&lt;/h3&gt;

&lt;p&gt;寫檔要呼叫String的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let text = &amp;quot;Hello World&amp;quot;
let filePath = NSTemporaryDirectory() + &amp;quot;Text.txt&amp;quot;
do{
	try text.write(toFile: filePath, atomically: true, encoding: .utf8)
}catch{
	print(&amp;quot;Not save correctly&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;讀檔要使用NSString&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let filePath = NSTemporaryDirectory() + &amp;quot;Text.txt&amp;quot;
do{
  let loading = try NSString(contentsOfFile: filePath, encoding: String.Encoding.utf8.rawValue)
  print(loading)
}catch{
	print(&amp;quot;No save file&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;讀寫array&#34;&gt;讀寫Array&lt;/h3&gt;

&lt;p&gt;利用NSArray做寫入&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let originalArray = [&amp;quot;Apple&amp;quot;, &amp;quot;Banana&amp;quot;, &amp;quot;MAngo&amp;quot;]
let arrayToSave = NSArray(array: originalArray)
let filePath = NSTemporaryDirectory() + &amp;quot;saveArray.txt&amp;quot;
arrayToSave.write(toFile: filePath, atomically: true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用NSArray做讀出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let filePath = NSTemporaryDirectory() + &amp;quot;saveArray.txt&amp;quot;
if let loadArray = NSArray(contentsOfFile: filePath) as? [String]{
	print(loadArray)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;讀寫dict&#34;&gt;讀寫Dict&lt;/h3&gt;

&lt;p&gt;寫入靠NSDictionary&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let originalDict = [&amp;quot;1&amp;quot;:&amp;quot;apple&amp;quot;, &amp;quot;2&amp;quot;:&amp;quot;banana&amp;quot;, &amp;quot;3&amp;quot;:&amp;quot;orange&amp;quot;]
let dictToSave = NSDictionary(dictionary: originalDict)
let filePath = NSTemporaryDirectory() + &amp;quot;saveDict.txt&amp;quot;
dictToSave.write(toFile: filePath, atomically: true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;讀取靠NSDictionary&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let filePath = NSTemporaryDirectory() + &amp;quot;saveDict.txt&amp;quot;
  if let loadDict = NSDictionary(contentsOfFile: filePath) as? [String:String]{
  print(loadDict)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;多媒體寫檔讀檔&#34;&gt;多媒體寫檔讀檔&lt;/h2&gt;

&lt;h3 id=&#34;圖檔&#34;&gt;圖檔&lt;/h3&gt;

&lt;p&gt;存檔&lt;br /&gt;
多媒體的寫檔只能依靠URL而不能靠檔案路徑。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先拿到要儲存的UIImage (可靠照相機或手機已有的圖片)&lt;/li&gt;
&lt;li&gt;以指定格式載入圖片 (UIImagePNGRepresentation或UIImageJPGRepresentation)&lt;/li&gt;
&lt;li&gt;產生路徑及URL&lt;/li&gt;
&lt;li&gt;在指定URL下存檔&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 拿到UIImage
guard let image = UIImage(named: &amp;quot;Tails&amp;quot;) else {
  print (&amp;quot;Cannot find image&amp;quot;)
  return
}

if let dataToSave = UIImagePNGRepresentation(image){
	// 產生路徑
  let filePath = NSTemporaryDirectory() + &amp;quot;savedImage.png&amp;quot;
  let fileURL = URL(fileURLWithPath: filePath)
  // 寫入
  do{
  	try dataToSave.write(to: fileURL)
  }catch{
  	print(&amp;quot;Can not save Image&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;讀檔&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;先用UIImage載入&lt;/li&gt;
&lt;li&gt;把載入圖片放在UIImageView上面&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let filePath = NSTemporaryDirectory() + &amp;quot;savedImage.png&amp;quot;
let image = UIImage(contentsOfFile: filePath)
myImageView.image = image
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自定義class讀寫檔&#34;&gt;自定義class讀寫檔&lt;/h2&gt;

&lt;p&gt;要寫檔的class必須繼承&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NSObject&lt;/li&gt;
&lt;li&gt;NSCoding&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;並複寫相關function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Item : NSObject, NSCoding{
    var name:String?
    var detail:String?
    
    init(name:String, detail:String) {
        self.name = name
        self.detail = detail
    }
    
    required init?(coder aDecoder: NSCoder) {       
        name = aDecoder.decodeObject(forKey: &amp;quot;name&amp;quot;) as! String
        detail = aDecoder.decodeObject(forKey: &amp;quot;detail&amp;quot;) as! String
    }
    
    func encode(with aCoder: NSCoder) {
        aCoder.encode(name, forKey: &amp;quot;name&amp;quot;)
        aCoder.encode(detail, forKey: &amp;quot;detail&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以來試著測試了&lt;br /&gt;
寫檔&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;產生物件&lt;/li&gt;
&lt;li&gt;利用NSKeyedArchiver.archivedData包裹物件，產生data&lt;/li&gt;
&lt;li&gt;找到寫檔路徑&lt;/li&gt;
&lt;li&gt;將data寫入指定路徑&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let item = Item(name: &amp;quot;危城&amp;quot;, detail: &amp;quot;動作&amp;quot;)
let data = NSKeyedArchiver.archivedData(withRootObject: item)
let docUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
let url = docUrl.appendingPathComponent(&amp;quot;myfile.txt&amp;quot;)
try! data.write(to: url)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;讀檔&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找到讀檔路徑&lt;/li&gt;
&lt;li&gt;獲取Data&lt;/li&gt;
&lt;li&gt;利用NSKeyedUnarchiver.unarchiveObject，將data轉換成指定物件&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let docUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
let url = docUrl.appendingPathComponent(&amp;quot;myfile.txt&amp;quot;)
let data = try? Data(contentsOf: url)

if let data = data {
	let item = NSKeyedUnarchiver.unarchiveObject(with: data) as! Item
	print(&amp;quot;=== Read ===&amp;quot;)
	print(item.name)
	print(item.detail)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Swift 聲音播放與錄製</title>
      <link>https://cdfq152313.github.io/post/2016-10-06/</link>
      <pubDate>Thu, 06 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-10-06/</guid>
      <description>

&lt;h2 id=&#34;播放系統音效&#34;&gt;播放系統音效&lt;/h2&gt;

&lt;p&gt;超簡單只需要兩行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import AudioToolbox
AudioServicesPlaySystemSound(1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;播放自己放在app的音樂&#34;&gt;播放自己放在app的音樂&lt;/h2&gt;

&lt;p&gt;先把自己的音效拖進Xcode，記得選擇&amp;rdquo;copy items if needed&amp;rdquo;，否則只會放入reference。&lt;br /&gt;
可以開一個新的Group(資料夾圖示)來專門放置音檔。&lt;/p&gt;

&lt;h3 id=&#34;步驟&#34;&gt;步驟&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;找到檔案在哪(用Bundle)&lt;/li&gt;
&lt;li&gt;產生URL&lt;/li&gt;
&lt;li&gt;產生AVAudioPlayer&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// AVAudioPlayer初始化
func myPlayerInit()-&amp;gt;AVAudioPlayer?{
	guard let path = Bundle.main.path(forResource: &amp;quot;Right&amp;quot;, ofType:&amp;quot;mp3&amp;quot;) else{
		return nil
	}

  let audioURL = URL(fileURLWithPath: path)
  do{
  	return try AVAudioPlayer(contentsOf: audioURL)
  }
  catch{
    print(&amp;quot;AVAudio Player Init failed&amp;quot;)
    return nil
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 利用button播放 每次按下都將聲音時間歸零
let myPlayer = myPlayerInit()
myPlayer?.play()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;其他好用的方法&#34;&gt;其他好用的方法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myPlayer?.stop() // 停止
myPlayer?.currentTime = 0 // 把音檔時間歸零
myPlayer?.numberOfLoops = 2 // 重複播放次數，若為負數則為無限次播放
myPlayer?.volume = 0.5 // 調整音量

// 把播放速度調慢或調快
myPlayer?.enableRate = true
myPlayer?.rate = 0.5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;播放手機內部的音樂&#34;&gt;播放手機內部的音樂&lt;/h2&gt;

&lt;p&gt;利用MPMediaPickerController，此一Controller會讓你選擇音樂。我們只需要指定選完音樂(或沒選到)要做什麼動作即可。&lt;/p&gt;

&lt;h3 id=&#34;步驟-1&#34;&gt;步驟&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;在Xcode調整權限

&lt;ul&gt;
&lt;li&gt;在info.plist裡面新增 &amp;ldquo;Privacy - Media Library Ussage Description&amp;rdquo;&lt;/li&gt;
&lt;li&gt;在右方新增你的理由&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;新增MPMediaPickerController&lt;/li&gt;
&lt;li&gt;實作MPMediaPickerController之delegate (MPMediaPickerControllerDelegate)

&lt;ul&gt;
&lt;li&gt;取消不動作&lt;/li&gt;
&lt;li&gt;選取到音樂則播放&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;指定2實作的delegate給1&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;權限設定&#34;&gt;權限設定&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/m9279lW.png&#34; alt=&#34;存取影音檔案權限&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;mpmediapickercontrollerdelegate的實作&#34;&gt;MPMediaPickerControllerDelegate的實作&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 取消不動作直接消除視窗
func mediaPickerDidCancel(_ mediaPicker: MPMediaPickerController) {
	dismiss(animated: true, completion: nil)
}

// 選取到音樂則播放
func mediaPicker(_ mediaPicker: MPMediaPickerController, didPickMediaItems mediaItemCollection: MPMediaItemCollection) {
  let musicPlayer = MPMusicPlayerController.applicationMusicPlayer()
  musicPlayer.setQueue(with:mediaItemCollection)
  musicPlayer.play()
  dismiss(animated:true, completion: nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若要停止MPmusicPlayerController一樣可以使用.stop函數&lt;/p&gt;

&lt;h2 id=&#34;錄音&#34;&gt;錄音&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;在info.plist增加麥克風權限&lt;/li&gt;
&lt;li&gt;選好放置路徑並產生URL&lt;/li&gt;
&lt;li&gt;設定錄音數據(dict)&lt;/li&gt;
&lt;li&gt;產生AVAudioRecorder實體&lt;/li&gt;
&lt;li&gt;指定AVAudioRecorder的delegate

&lt;ul&gt;
&lt;li&gt;指定錄完音後執行的動作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;開始錄音&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;權限設定-1&#34;&gt;權限設定&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/WwJpAMB.png&#34; alt=&#34;麥克風權限&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;步驟2-3-4-5&#34;&gt;步驟2 3 4 5&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func audioRecorderInit()-&amp;gt;AVAudioRecorder?{
	// 步驟2 設定路徑
  let path = NSHomeDirectory() + &amp;quot;/Documents/user.wav&amp;quot;
  let url = URL(fileURLWithPath: path)
  // 步驟3 設定錄音數據(dict)
  let recordSettings:[String:Any] = [
    AVEncoderAudioQualityKey : AVAudioQuality.min.rawValue,
    AVEncoderBitRateKey: 16,
    AVNumberOfChannelsKey: 2,
    AVSampleRateKey: 44100.0
  ]
  do {
  	// 步驟4 5 產生實體並指定delegate
  	let audioRecorder = try AVAudioRecorder(url: url, settings:recordSettings)
    audioRecorder.delegate = self
    return audioRecorder
  }
  catch{
  	print(&amp;quot;something is worng&amp;quot;)
  	return nil
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;avaudiorecorderdelegate的實作&#34;&gt;AVAudioRecorderDelegate的實作&lt;/h3&gt;

&lt;p&gt;參數recorder的屬性url可以拿到錄製好的檔案路徑&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func audioRecorderDidFinishRecording(_ recorder: AVAudioRecorder, successfully flag: Bool) {
  if flag == true{
    do {
    	try audioPlayer = AVAudioPlayer(contentsOf: recorder.url)
  	}
    catch{
    	print(&amp;quot;something is Wrong...&amp;quot;)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;開始錄音&#34;&gt;開始錄音&lt;/h3&gt;

&lt;p&gt;將AVAudioSession調成AVAudioSessionCatetoryPlayAndRecord，可有效增大錄音音量。若不調整則會很小聲。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;do {
	try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayAndRecord)
}
catch{
	print(&amp;quot;can&#39;t set audio session&amp;quot;)
}
audioRecorder?.prepareToRecord()
audioRecorder?.record()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;停止錄音&#34;&gt;停止錄音&lt;/h3&gt;

&lt;p&gt;記得把剛剛的AVAudioSession.sharedInstance()調回原樣&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;self.audioRecorder?.stop()
do{
	try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback)
	try AVAudioSession.sharedInstance().setActive(false)
}
catch{
	print(&amp;quot;can&#39;t set audio session&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Swift 基礎語法筆記</title>
      <link>https://cdfq152313.github.io/post/2016-10-04/</link>
      <pubDate>Tue, 04 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-10-04/</guid>
      <description>

&lt;h2 id=&#34;參考資料&#34;&gt;參考資料&lt;/h2&gt;

&lt;p&gt;感謝大大～～&lt;br /&gt;
&lt;a href=&#34;https://itisjoe.gitbooks.io/swiftgo/content/&#34;&gt;https://itisjoe.gitbooks.io/swiftgo/content/&lt;/a&gt;&lt;br /&gt;
因應swift3，筆記內容與gitbook上略有不同&lt;/p&gt;

&lt;h2 id=&#34;struct和enum是value-type-class是reference-type&#34;&gt;struct和enum是value type, class是reference type&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;struct宣告為常數，就無法更改內部的值，但class可以。&lt;/li&gt;
&lt;li&gt;struct和enum這種value type，內部member function不能修改member data的值&lt;/li&gt;
&lt;li&gt;如果真的要修改要加上mutating修飾字&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Apple{
    var x = 0.0
    mutating func add(num:Double){
        x += num
    }
}

var x = Apple(x:1.2)
x.add(1.5)
print(x.x)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;mutating 還可以替換掉本身的實體結構&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;struct Apple{
    var x = 0.0
    mutating func new(num:Double){
        x = Apple()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;function注意事項&#34;&gt;function注意事項&lt;/h2&gt;

&lt;p&gt;call function時，參數後要指定參數名稱，不可以省略&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func plus(a :Int, b:Int){
  print(a+b)
}
plus(a:1, b:3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要省略要加上底線&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func plus(_ a :Int,_ b:Int){
  print(a+b)
}
plus(1, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;外部參數名稱-external-parameter-name&#34;&gt;外部參數名稱(External parameter Name)&lt;/h3&gt;

&lt;p&gt;事實上a前面的底線是External parameter Name的意思。External parameter Name用於外部呼叫Function時的參數識別名，若不寫則與內部名稱相同。&lt;br /&gt;
而底線代表不在意參數識別名稱，即為可忽略的意思。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func plus(AAA a :Int,BBB b:Int){
  print(a+b)
}
plus(AAA:1, BBB:3)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;型別方法&#34;&gt;型別方法&lt;/h2&gt;

&lt;p&gt;在class中要宣告class方法(非object方法)，可以用關鍵字&lt;strong&gt;class&lt;/strong&gt;或&lt;strong&gt;static&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SomeClass {
    // 定義一個型別方法
    class func someTypeMethod() {
        print(&amp;quot;型別方法&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;closure&#34;&gt;Closure&lt;/h2&gt;

&lt;h3 id=&#34;函式也是一種型別&#34;&gt;函式也是一種型別&lt;/h3&gt;

&lt;p&gt;型別名稱為&lt;br /&gt;
(參數型別)-&amp;gt;回傳型別&lt;/p&gt;

&lt;h3 id=&#34;化function為clousure&#34;&gt;化function為Clousure&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;刪掉func與函式名&lt;/li&gt;
&lt;li&gt;將大括號移到最外側&lt;/li&gt;
&lt;li&gt;在參數後面加上in&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;before&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func add(x:Int, y:Int)-&amp;gt;Int{
	return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;after&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;{
	(x:Int, y:Int)-&amp;gt;Int in
  return x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;closure簡寫&#34;&gt;Closure簡寫&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果已經知道參數跟回傳值的型別的話，可以省略Clousure裡的參數與回傳值型別&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;	let numberArray=[1,3,6,8,10,45]
numberArray.map( {(number) in return number+10} ) // 省略型別
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果Closure有回傳值，而且程式碼是一行的話，可以省略return，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;	let numberArray=[1,3,6,8,10,45]
numberArray.map( {(number) in number+10} ) // 回傳number+10
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以用$0, $1 &amp;hellip; 代表參數。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;	let numberArray=[1,3,6,8,10,45]
numberArray.map( {$0 + 10} ) // 省略參數，利用$0代表參數
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果Closure是最後一個參數的話，可以把clousure寫在小括號的外面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  let numberArray=[1,3,6,8,10,45]
  numberArray.map(){$0 + 10} // 寫在小括號的外面
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果Closure是唯一的參數的話，可以省略小括號
	&lt;code&gt;swift
	let numberArray=[1,3,6,8,10,45]
	  numberArray.map{$0 + 10} // 直接省掉小括號
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;guard的用途&#34;&gt;guard的用途&lt;/h2&gt;

&lt;p&gt;guard比if能更好的實行Defensive Programming，因為在guard中的可選綁定可以在接下來code中使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var text:String? = &amp;quot;abc&amp;quot;
if let apple = text{
	print(apple)
}
// 在這邊用會失敗
// print(apple)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var text:String? = &amp;quot;abc&amp;quot;
guard let apple = text else{
	print(apple)
}
// 照用
print(apple)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;error&#34;&gt;Error&lt;/h2&gt;

&lt;p&gt;Swift丟出的異常是一種enum，實作時繼承Error。&lt;br /&gt;
有幾種方法&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;最基本的do try catch&lt;/li&gt;
&lt;li&gt;向上拋擲function填throw&lt;/li&gt;
&lt;li&gt;try? : 如果出現錯誤則回傳nil(不用再寫do catch)，可搭配optinal binding&lt;/li&gt;
&lt;li&gt;try! : 一定成功。(若沒成功會crash)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;init&#34;&gt;init&lt;/h2&gt;

&lt;h3 id=&#34;init-1&#34;&gt;init?&lt;/h3&gt;

&lt;p&gt;init?代表可以回傳nil，也就是可能init失敗。&lt;br /&gt;
參看下面的code&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Baby{
	var age:Int
	init?(age:Int){
  	if age &amp;lt; 0{
    	return nil
    }
  	self.age = age
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一個寶寶生出來小於一歲是不合理的，所以init失敗回傳nil&lt;/p&gt;

&lt;h3 id=&#34;init的順序&#34;&gt;init的順序&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;原則1：屬性的初始,必須在當初宣告屬性的類別裡進⾏。&lt;/li&gt;
&lt;li&gt;原則2：⼦類別得先完成⾃⼰屬性的初始後，才能進⾏⽗類別屬性的初始。

&lt;ul&gt;
&lt;li&gt;此原則是為了防止繼承的class複寫基礎class的方法，而基礎的class使用此方法來初始化。&lt;/li&gt;
&lt;li&gt;若此function剛好動用到繼承class之porperty，那就會出現問題。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假設有一個基礎型別寶寶&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Baby{
    var age:Int
    init(age:Int){
        self.age = age
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正確的範例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SuperBaby: Baby{
    var magic:Int
    init(age:Int, magic:Int){
        self.magic = magic
        super.init(age: age)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;錯誤的範例: 違反原則1，age屬性的初始化不在宣告的類別裡。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SuperBaby: Baby{
    var magic:Int
    init(age:Int, magic:Int){
        self.magic = magic
        self.age = age
        super.init(age: age)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;錯誤的範例: 違反原則2，必須先將自己的屬性先初始化完畢，才能call super init&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SuperBaby: Baby{
    var magic:Int
    init(age:Int, magic:Int){
    		super.init(age: age)
        self.magic = magic
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正確的範例: 在age初始化後才改變age的值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class SuperBaby: Baby{
    var magic:Int
    init(age:Int, magic:Int){
        self.magic = magic
        super.init(age: age)
        self.age = age
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;convenience-init&#34;&gt;convenience init&lt;/h3&gt;

&lt;p&gt;有兩種類型的init&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;designated initializer : 一般的init&lt;/li&gt;
&lt;li&gt;convenience initializer : 加了關鍵字convenience的init&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;擁有convenience關鍵字的init才可以call其他init function，來減少重複工作，非常&lt;strong&gt;方便&lt;/strong&gt;。&lt;br /&gt;
舉例來說：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;class Baby{
    var age:Int
    var name:String
    init(age:Int, name:String){
        self.age = age
        self.name = name
    }
    
    convenience init(name:String){
    		self.init(age:1, name:name)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;init的繼承&#34;&gt;init的繼承&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;designated initializer的繼承

&lt;ul&gt;
&lt;li&gt;子類別沒有定義任何designated initializer，預設全部自動繼承。&lt;/li&gt;
&lt;li&gt;子類別定義了任意init，不會自動繼承父類別的init。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;convenience initializer的繼承

&lt;ul&gt;
&lt;li&gt;子類別沒有定義任何designated initializer，預設全部自動繼承。&lt;/li&gt;
&lt;li&gt;子類別覆寫了父類別所有的designated initializer，則自動繼承所有convenience initializer。&lt;/li&gt;
&lt;li&gt;子類別複寫不完全，則不會繼承convenience initializer。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用required防止init失傳&#34;&gt;使用required防止init失傳&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>Swift 不同Controller互動 與 Navigation Bar</title>
      <link>https://cdfq152313.github.io/post/2016-10-03/</link>
      <pubDate>Mon, 03 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-10-03/</guid>
      <description>

&lt;h2 id=&#34;controller之間的呼叫&#34;&gt;Controller之間的呼叫&lt;/h2&gt;

&lt;h3 id=&#34;present-與-dismiss&#34;&gt;present 與 dismiss&lt;/h3&gt;

&lt;p&gt;想要跳轉頁面，我們可以靠storyBoard拉出present的線，也可以靠程式碼。&lt;br /&gt;
在StoryBoard中只要按住ctrl，將button拉到另一個controller後再選present即可。&lt;br /&gt;
在程式碼的話&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 因為此ViewController什麼都沒設定，所以會是一片黑
present(ViewController(), animated: true, completion: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有跳過去，就有返回，想返回時使用dismiss function。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;dismiss(animated: true, completion: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dismiss的原理是，直接呼叫時，請求presentingViewController把你關掉。&lt;br /&gt;
間接呼叫時，把後面的presentedViewController們關掉。&lt;br /&gt;
至於這兩個是什麼意思請參看下節。&lt;/p&gt;

&lt;h3 id=&#34;presentingviewcontroller-與-presentedviewcontroller&#34;&gt;presentingViewController 與 presentedViewController&lt;/h3&gt;

&lt;p&gt;每個controller皆有兩個重要的屬性，可以分辨這個controller是被誰present，或是present了誰。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;presentingViewController：present Controller的Controller&lt;/li&gt;
&lt;li&gt;presentedViewController：被present的Controller&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假設ABC皆為Controller，A present B，B present C，那對於B來說。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A為B之presentingViewController&lt;/li&gt;
&lt;li&gt;C為B之presentedViewController&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;navigation-bar&#34;&gt;Navigation bar&lt;/h2&gt;

&lt;h3 id=&#34;push-與-pop&#34;&gt;push 與 pop&lt;/h3&gt;

&lt;p&gt;與present / dismiss相似，進到navigation controller後要使用 navigation屬性的push/pop方法，不然會跳出navigation controller的頁，失去Navigation Bar的效果。&lt;/p&gt;

&lt;p&gt;程式碼的形式如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 推上下一個頁面
self.navigationController?.pushViewController(ViewController(), animated: true)
// 回到上一頁
self.navigationController?.popViewController(animated: true)
// 直接回到navigation最開頭
self.navigationController?.popToRootViewController(animated: true)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;前後的controller&#34;&gt;前後的controller&lt;/h3&gt;

&lt;p&gt;如同present / dismiss可以拿到前後關係一樣，navigation controller也是可以拿到前後關係的。&lt;br /&gt;
所有經過的controller都放在self.navigationController?.viewControllers這個array裡可以拿取。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;self.navigationController?.viewControllers[0]
self.navigationController?.viewControllers[1]
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;navigation-controller的建立&#34;&gt;Navigation Controller的建立&lt;/h3&gt;

&lt;p&gt;Navigation Contrller本身並不帶有頁面資訊，而是在Navigation Controller的下一個Controller才會開始顯示。&lt;br /&gt;
那兩者之間要建立連線，必須要指定Navigation Controller當中的Root View Controller才行。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方法1: Navigation綁定Root Controller，有兩種做法

&lt;ul&gt;
&lt;li&gt;按住Ctrl並將Navigation Controller拉到想要顯示的第一個Controller，鬆開後選擇Root view Controller&lt;/li&gt;
&lt;li&gt;在Navigation Controller的Triggered Segue中，指定Root view Controller&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方法2: 在StoryBoard中，點擊已經存在的Controller。並從上方選單Editor =&amp;gt; Embed in =&amp;gt; NavigatioController即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;上面的title和向右鈕&#34;&gt;上面的title和向右鈕&lt;/h3&gt;

&lt;p&gt;預設只有Navigation Controller後第一個Bar可以編輯Title，若要加入新title則要從StoryBoard中拉入&lt;strong&gt;Navigation item&lt;/strong&gt;&lt;br /&gt;
預設上方並無向右鍵，只有返回鍵，若要加入則拉入&lt;strong&gt;Bar Button Item&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;tab-bar-controller&#34;&gt;Tab Bar Controller&lt;/h2&gt;

&lt;p&gt;與Navigation View許多做法類似，想加上新的tab可以&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方法1: TabViewController綁定View Controllers，有兩種做法

&lt;ul&gt;
&lt;li&gt;按住Ctrl並將TabViewController拉到想要加上的Controller，鬆開後選擇View Controllers&lt;/li&gt;
&lt;li&gt;在TabViewController的Triggered Segue中，指定新的View Controllers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方法2: 在StoryBoard中，點擊已經存在的Controller。並從上方選單Editor =&amp;gt; Embed in =&amp;gt; TabViewController即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;tab-bar-controller下的controller們&#34;&gt;tab bar controller下的controller們&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;self.tabBarController?.viewControllers[0]
self.tabBarController?.viewControllers[1]
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要注意的是，如果是tab bar controller下包著navigation controller，在存取時要先轉型成navigation controller，再取用navigation controller裡面的controller，才不會錯誤。&lt;/p&gt;

&lt;h3 id=&#34;切換tab&#34;&gt;切換tab&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;self.tabBarController?.selectedIndex = 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;隱藏tab&#34;&gt;隱藏tab&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;self.tabBarController?.tabBar.isHidden = true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;在不同的controller之間跳轉&#34;&gt;在不同的Controller之間跳轉&lt;/h2&gt;

&lt;h3 id=&#34;方法1-直接拖拉&#34;&gt;方法1 直接拖拉&lt;/h3&gt;

&lt;p&gt;在storyboard上&lt;br /&gt;
按住ctrl點下來源Controller之button拉到要呈現的Controller後鬆開，選擇show或present即可。&lt;br /&gt;
show會在啟用navigation bar的時候自動使用navigation.push，若無navigation bar則是使用present。&lt;/p&gt;

&lt;h3 id=&#34;方法2-利用segue&#34;&gt;方法2 利用segue&lt;/h3&gt;

&lt;p&gt;在storyboard上&lt;br /&gt;
按住ctrl點下來源Controller，拉到要呈現的Controller，會多一條segue連線，幫此條連線取名字(identifer)&lt;br /&gt;
接下來在想切換的情況下使用performSegue即可(參數為剛剛取的identifer)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;performSegue(withIdentifier: &amp;quot;goToView2&amp;quot;, sender: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法3-指定storyboard以及controller-通常用在更換story-board的時候&#34;&gt;方法3 指定StoryBoard以及Controller (通常用在更換Story Board的時候)&lt;/h3&gt;

&lt;p&gt;將要呈現的Controller取名字(StoryBoardID)&lt;br /&gt;
並在程式碼中指定&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;位於哪個StoryBoard&lt;/li&gt;
&lt;li&gt;Controller的StoryBoardID&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最後present或push即可&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let myStoryBoard = UIStoryboard(name: &amp;quot;Main&amp;quot;, bundle: nil)
let whiteViewController = myStoryBoard.instantiateViewController(withIdentifier: &amp;quot;whiteView&amp;quot;)
present(whiteViewController, animated:true, completion:nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是位於同一個storyboard，也可以拿到自己的storyboard&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let myStoryBoard = self.storyboard!
let whiteViewController = myStoryBoard.instantiateInitialViewController(withIdentifier: &amp;quot;whiteView&amp;quot;)
present(whiteViewController, animated:true, completion:nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法4-storyboard-reference-通常用在更換story-board的時候&#34;&gt;方法4 StoryBoard Reference (通常用在更換Story Board的時候)&lt;/h3&gt;

&lt;p&gt;在StoryBoard中，將StoryBoard Reference&lt;br /&gt;
拖到畫面上，指定StoryBoard Reference上的StoryBoard和ControllerID&lt;br /&gt;
接下來利用方法1或2拖拉即可成功&lt;/p&gt;

&lt;h3 id=&#34;方法5-逃生門-通常用在要返回前一個controller的時候&#34;&gt;方法5 逃生門 (通常用在要返回前一個Controller的時候)&lt;/h3&gt;

&lt;h4 id=&#34;情況&#34;&gt;情況&lt;/h4&gt;

&lt;p&gt;假設最初的controller取名叫parent controller&lt;br /&gt;
parent controller可以連到許多child controller&lt;br /&gt;
當child controller想返回parent controller的時候&lt;/p&gt;

&lt;h4 id=&#34;作法&#34;&gt;作法&lt;/h4&gt;

&lt;p&gt;先寫在parent controller&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;@IBAction func backToMain(_ segue:UIStoryboardSegue){
	print(&amp;quot;back to main&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再用StoryBoard選擇child controller&lt;br /&gt;
按鈕按住ctrl往該controller的逃生門拉 (上方最右邊的圖示)&lt;br /&gt;
即會出現backToMain的方法&lt;br /&gt;
如果parent controller在child controller返回後想執行什麼動作也可在此function中填入&lt;/p&gt;

&lt;h2 id=&#34;controller之間傳遞訊息&#34;&gt;Controller之間傳遞訊息&lt;/h2&gt;

&lt;h3 id=&#34;方法1-利用destination-controller的property-呼叫下一個controller時&#34;&gt;方法1. 利用destination controller的property (呼叫下一個Controller時)&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;複寫Source Controller的prepare Function&lt;/li&gt;
&lt;li&gt;參數segue之屬性destionation即為destination controller&lt;/li&gt;
&lt;li&gt;強制轉型為destination controller&lt;/li&gt;
&lt;li&gt;將其塞入數值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;這裡要注意的是，不能把值塞進destination controller的UI元件內(Ex: Label)，因為這個時候畫面元件還沒生成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// Source Controller
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
	if segue.destination is SecondViewController{
    let des = segue.destination as! SecondViewController
  	des.textFromFirstView = &amp;quot;Hello World&amp;quot;
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法2-利用前後階層關係-僅適用於返回controller時&#34;&gt;方法2. 利用前後階層關係(僅適用於返回controller時)&lt;/h3&gt;

&lt;p&gt;前面有說過present可以靠&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;presentingViewController&lt;/li&gt;
&lt;li&gt;presentedViewController&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;navigation bar可以靠&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;self.navigationController?.viewControllers[0]&lt;/li&gt;
&lt;li&gt;self.navigationController?.viewControllers[1]&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;來獲得前面的controller元件
取得controller後再參考方法1塞入值&lt;/p&gt;

&lt;h3 id=&#34;方法3-protocol-返回前一個controller時&#34;&gt;方法3. protocol (返回前一個controller時)&lt;/h3&gt;

&lt;p&gt;將前一個controller名為FirstViewController&lt;br /&gt;
現在這個controller名為SecondViewController&lt;br /&gt;
令一個protocol叫做SecondViewControllerDelegate&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;將SecondViewControllerDelegate當作SecondViewController的屬性&lt;/li&gt;
&lt;li&gt;在FirstViewController跳轉到SecondViewController前，通過方法1塞進自己實作的SecondViewControllerDelegate&lt;/li&gt;
&lt;li&gt;SecondViewController消失前，執行該protocol的method (透過複寫viewWillDisapear來達成)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;SecondController&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var delegate:SecondViewControllerDelegate?
@IBAction func goBack(_ sender: UIButton) {
	let _ = navigationController?.popViewController(animated: true)
}

override func viewWillDisappear(_ animated: Bool) {
  super.viewWillDisappear(animated)
  if self.isMovingFromParentViewController{
		delegate?.setColor(colorType: &amp;quot;red&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hint: 可以靠 self.isMovingFromParentViewController來測試是否為返回到前一個Controller&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;SecondViewControllerDelegate&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;protocol SecondViewControllerDelegate{
	func setColor(colorType:String)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;FirstViewController (實作SecondViewControllerDelegate)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
  if let des = segue.destination as? SecondViewController{
    des.delegate = self
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法4-notification-返回前一個controller時&#34;&gt;方法4. notification (返回前一個controller時)&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;parent controller先監聽事件

&lt;ul&gt;
&lt;li&gt;撰寫接收到監聽後要執行的function&lt;/li&gt;
&lt;li&gt;註冊監聽事件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;child controller發送notification&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ParentController&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 接收到事件後要執行的任務
func getUpdateNoti(noti:Notification) {
	let data = noti.userInfo![&amp;quot;data&amp;quot;] as! String
	print(data)
}

override func viewDidLoad() {
  super.viewDidLoad()
	
  // 註冊事件
  let notificationName = Notification.Name(&amp;quot;GetUpdateNoti&amp;quot;)
  NotificationCenter.default.addObserver(self, selector: #selector(ViewController.getUpdateNoti(noti:)), name: notificationName, object: nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ChildController&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 發送事件
let notificationName = Notification.Name(&amp;quot;GetUpdateNoti&amp;quot;)
NotificationCenter.default().post(name: notificationName,object: nil, userInfo: [&amp;quot;data&amp;quot;:&amp;quot;Hello World&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;方法5-全域變數&#34;&gt;方法5. 全域變數&lt;/h3&gt;

&lt;p&gt;在AppDelegate增加property&lt;br /&gt;
並在想要使用的class裡面，將UIApplication.shared.delegate轉型為AppDelegate&lt;br /&gt;
即可使用裡面的property&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if let appDelegate = UIApplication.shared.delegate as? AppDelegate{
	if let colorName = appDelegate.color{
    setColor(colorType: colorName)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全域變數還有很多做法，像是singleton或是寫在class之外，有機會再開一篇講。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift 快速筆記</title>
      <link>https://cdfq152313.github.io/post/2016-09-13/</link>
      <pubDate>Tue, 13 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-09-13/</guid>
      <description>

&lt;h2 id=&#34;autolayout&#34;&gt;AutoLayout&lt;/h2&gt;

&lt;p&gt;只要確定好下面的參數，autoLayout就不會跑警告&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;x&lt;/li&gt;
&lt;li&gt;y&lt;/li&gt;
&lt;li&gt;width&lt;/li&gt;
&lt;li&gt;height&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;alertcontroller&#34;&gt;AlertController&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;新增AlertController

&lt;ul&gt;
&lt;li&gt;.ActionSheet可藉由點警告視窗外面而取消&lt;/li&gt;
&lt;li&gt;.alert不可藉由點警告視窗外面而取消&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果需要&amp;rdquo;OK&amp;rdquo;等選項的話，新增UIAction (.alert必做，不然會回不去)&lt;/li&gt;
&lt;li&gt;將UIAction放置到AlertController上&lt;/li&gt;
&lt;li&gt;present&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let myAlert = UIAlertController(title: &amp;quot;Please enter something&amp;quot;, message: nil, preferredStyle: .alert)
let myAction = UIAlertAction(title: &amp;quot;OK&amp;quot;, style: .default, handler:nil)
myAlert.addAction(myAction)
present(myAlert, animated: true, completion: nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嘗試加入文字框&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let myAlert = UIAlertController(title: &amp;quot;Add New Task&amp;quot;, message: nil, preferredStyle: .alert)
myAlert.addTextField {
  (textfield:UITextField) in
  textfield.placeholder = &amp;quot;Add New Task&#39;&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嘗試對加入的UIAction執行一些動作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let ok = UIAlertAction(title: &amp;quot;OK&amp;quot;, style: .default){
	(action) in
  // action是UIAlertAction
  // 在下面填入想要執行的動作
  ...
  ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;讓鍵盤自動彈出&#34;&gt;讓鍵盤自動彈出&lt;/h2&gt;

&lt;p&gt;在可輸入的View中(Ex: textfield)，會有&lt;code&gt;becomeFirstResponder()&lt;/code&gt;方法&lt;/p&gt;

&lt;h2 id=&#34;pickerview&#34;&gt;PickerView&lt;/h2&gt;

&lt;h3 id=&#34;選中某一列後立刻執行某動作&#34;&gt;選中某一列後立刻執行某動作&lt;/h3&gt;

&lt;p&gt;複寫&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {
	chooseColor = colorArray[row]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;得知目前是選中哪一列&#34;&gt;得知目前是選中哪一列&lt;/h3&gt;

&lt;p&gt;call function，並指定是哪個Component&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;myPickerView.selectedRow(inComponent: 0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;更為簡單的datepickerview&#34;&gt;更為簡單的DatePickerView&lt;/h3&gt;

&lt;p&gt;若想得知DatePickerView所擷取到的日期或時間只要使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let date = myDatePicker.date
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一行即可，其他的都是date格式的問題。&lt;br /&gt;
DatePickerView的樣式可以從storyBoard中選擇。&lt;/p&gt;

&lt;h2 id=&#34;播放影片&#34;&gt;播放影片&lt;/h2&gt;

&lt;h3 id=&#34;流程&#34;&gt;流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;找到播放影片URL&lt;/li&gt;
&lt;li&gt;初始化AVPlayer(將URL放進去)&lt;/li&gt;
&lt;li&gt;初始化AVPlayerViewController&lt;/li&gt;
&lt;li&gt;將AVPlayerController的player設成剛剛的AVPlayer&lt;/li&gt;
&lt;li&gt;present並播放&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;guard let path = Bundle.main.url(forResource: &amp;quot;HipHop&amp;quot;, withExtension: &amp;quot;mp4&amp;quot;) else {
	return
}

let videoPlayer = AVPlayer(url: path)
let videoPlayerController = AVPlayerViewController()
videoPlayerController.player = videoPlayer
present(videoPlayerController, animated: true, completion: nil)
videoPlayer.play()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;重複播放&#34;&gt;重複播放&lt;/h3&gt;

&lt;p&gt;不同於播放音樂可以簡單設置loop，重複播放影片是要傾聽影片播完後所發送的notification。&lt;/p&gt;

&lt;p&gt;監聽播放完成notification&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;NotificationCenter.default.addObserver(self, selector: #selector(ViewController.playerDidReachEnd(notification:)), name: Notification.Name.AVPlayerItemDidPlayToEndTime, object: nil)

// 監聽function
func playerDidReachEnd(notification:Notification){
    videoPlayer?.currentItem?.seek(to: kCMTimeZero)
    videoPlayer?.play()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;錄影&#34;&gt;錄影&lt;/h2&gt;

&lt;h2 id=&#34;照相&#34;&gt;照相&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;在info.plist設定照相權限&lt;/li&gt;
&lt;li&gt;產生image picker Controller&lt;/li&gt;
&lt;li&gt;設定 sourceType&lt;/li&gt;
&lt;li&gt;設定delegate屬性，決定照相完畢後要做什麼&lt;/li&gt;
&lt;li&gt;推出image Picker&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;這邊要特別注意，模擬器是沒有camera的，所以若要用模擬器最好先檢查。&lt;/p&gt;

&lt;p&gt;照相權限&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/Yf8lCmd.png&#34; alt=&#34;照相權限&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let imagePicker = UIImagePickerController()
imagePicker.sourceType = .camera
imagePicker.delegate = self
present(imagePicker, animated:true, completion:nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;delegate寫法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) {
  guard let image = info[UIImagePickerControllerMediaURL] as? UIImage{
    print(&amp;quot;Cannot get picture url&amp;quot;)
    return
  }
  myImageView.image = image
  dismiss(animated: true, completion: nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;其他實用方法&#34;&gt;其他實用方法&lt;/h3&gt;

&lt;p&gt;若想存檔可使用下方程式碼&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;若想直接從已拍照圖庫裡面選擇圖片，可以透過更改sourcetype來完成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;imagePicker.sourceType = .photoLibrary
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用資源&#34;&gt;使用資源&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;先找路徑再找URL&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let path = Bundle.main.path(forResource: &amp;quot;Right&amp;quot;, ofType:&amp;quot;mp3&amp;quot;)
let audioURL = URL(fileURLWithPath: path)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;直接找URL&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let path = Bundle.main.url(forResource: &amp;quot;HipHop&amp;quot;, withExtension: &amp;quot;mp4&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;存資料-物件&#34;&gt;存資料(物件)&lt;/h2&gt;

&lt;p&gt;使用UserDefaults.standard.set和UserDefaults.standard.synchronize&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;用set並給一個key&lt;/li&gt;
&lt;li&gt;synchronize&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;var toDo = [&amp;quot;Buy milk&amp;quot;, &amp;quot;iOS exam&amp;quot;, &amp;quot;Sleep&amp;quot;, &amp;quot;Make money&amp;quot;]
UserDefaults.standard.set(toDo, forKey:&amp;quot;todo&amp;quot;)
UserDefaults.standard.synchronize()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取值，要記得取出來是anyObject，必須轉型，而且可能為nil(key不存在)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;guard let loaded = UserDefaults.standard.object(forKey: &amp;quot;toDo&amp;quot;) as? [String] else{
  print(&amp;quot;No such key&amp;quot;)
  return
}
print(loaded)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果存的是預設型別(像是Int)，取值方法可以不用轉型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;guard let loaded = UserDefaults.standard.integer(forKey: &amp;quot;toDo&amp;quot;) else{
  print(&amp;quot;No such key&amp;quot;)
  return
}
print(loaded)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;property-list-plist&#34;&gt;Property List (Plist)&lt;/h2&gt;

&lt;p&gt;Info.plist就是一種Property List的檔案。&lt;br /&gt;
plist可以很方便地幫你用Array或dictionary的形式存取資訊(String, Int &amp;hellip;)，個人覺得跟json沒兩樣。&lt;br /&gt;
使用的步驟如下&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;新增一個Property List檔案&lt;/li&gt;
&lt;li&gt;在上面加上一些資訊(假設是一串Array)&lt;/li&gt;
&lt;li&gt;使用Bundle.main.path拿到資源(檔案型態是plist)&lt;/li&gt;
&lt;li&gt;利用NSArray將檔案轉成Array，或是NSDictionary檔案轉成dict&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;guard let scorePlist = Bundle.main.path(forResource: &amp;quot;Score&amp;quot;, ofType: &amp;quot;plist&amp;quot;),
  let scoreArray = NSArray(contentsOfFile: scorePlist) else{
    print(&amp;quot;Get Plist Error&amp;quot;)
    return
}
print(scoreArray)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;activity-indicator&#34;&gt;Activity Indicator&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用StoryBoard直接拉&lt;/li&gt;
&lt;li&gt;記得把Hides when stop打勾，不然圖案一直都在&lt;/li&gt;
&lt;li&gt;startAnimating()開始轉&lt;/li&gt;
&lt;li&gt;stopAnimationg()停止轉&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cocoapods&#34;&gt;COCOAPODS&lt;/h2&gt;

&lt;p&gt;先安裝 &lt;a href=&#34;https://cocoapods.org/&#34;&gt;https://cocoapods.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在Xcode專案底下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pod init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;編輯生出來podfile&lt;br /&gt;
加入需要的pod 專案&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Podfile&#34;&gt;# Uncomment the next line to define a global platform for your project
# platform :ios, &#39;9.0&#39;

target &#39;HelloCoCoaPods&#39; do
  # Comment the next line if you&#39;re not using Swift and don&#39;t want to use dynamic frameworks
  use_frameworks!

  # Pods for HelloCoCoaPods
  pod &#39;Firebase/Database&#39;

end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安裝專案&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pod install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reachability-測試有無連網&#34;&gt;Reachability 測試有無連網&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;下載&lt;a href=&#34;https://developer.apple.com/library/content/samplecode/Reachability/Introduction/Intro.html&#34;&gt;reachability&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;將Reachablility.h 及.m一起拖到專案，選擇新增Bridge&lt;/li&gt;
&lt;li&gt;Bridege中寫入&lt;code&gt;#import &amp;quot;Reachability.h&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;初始化&lt;code&gt;Reachability(hostName: &amp;quot;www.apple.com&amp;quot;)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;必須指定一個可連線的網址&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用方法startNotifier&lt;/li&gt;
&lt;li&gt;addObserver&lt;/li&gt;
&lt;li&gt;接收notification&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;xml&#34;&gt;XML&lt;/h2&gt;

&lt;p&gt;解析XML XML delegate&lt;/p&gt;

&lt;h2 id=&#34;值得用的app&#34;&gt;值得用的APP&lt;/h2&gt;

&lt;p&gt;figure&lt;/p&gt;

&lt;h2 id=&#34;登入與非登入狀態用不同的controller&#34;&gt;登入與非登入狀態用不同的Controller&lt;/h2&gt;

&lt;p&gt;在Appdelegate裡面&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&amp;gt; Bool {
  if check != 1 {
  	let controller = UIStoryboard(name: &amp;quot;LogIn&amp;quot;, bundle: nil).instantiateViewController(withIdentifier: &amp;quot;logIn&amp;quot;)
  	self.window?.rootViewController = controller
  } else {
  	let controller = UIStoryboard(name: &amp;quot;Main&amp;quot;, bundle: nil).instantiateViewController(withIdentifier: &amp;quot;tab&amp;quot;)
  	self.window?.rootViewController = controller
  }
	return true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;keyboard&#34;&gt;keyboard&lt;/h1&gt;

&lt;h2 id=&#34;彈出來時畫面自動向上&#34;&gt;彈出來時畫面自動向上&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/25693130/move-textfield-when-keyboard-appears-swift&#34;&gt;http://stackoverflow.com/questions/25693130/move-textfield-when-keyboard-appears-swift&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;點旁邊畫面自動縮回去&#34;&gt;點旁邊畫面自動縮回去&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/24126678/close-ios-keyboard-by-touching-anywhere-using-swift&#34;&gt;http://stackoverflow.com/questions/24126678/close-ios-keyboard-by-touching-anywhere-using-swift&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>