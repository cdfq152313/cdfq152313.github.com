	<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.19" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  <title>Swift 基礎語法筆記 &middot; Denny&#39;s Blog</title>
  

  
  <link rel="stylesheet" href="https://cdfq152313.github.io/css/poole.css">
  <link rel="stylesheet" href="https://cdfq152313.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://cdfq152313.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Denny&#39;s Blog" />
</head>

	<body class="theme-base-0f ">
		<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://cdfq152313.github.io/"><h1>Denny&#39;s Blog</h1></a>
      <p class="lead">
       獸控天地 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      
        <li><a href="/categories/notes"> 程式筆記 </a></li>
      
        <li><a href="/categories/misc"> 心得雜感 </a></li>
      
        <li><a href="/tags/"> 標籤列表 </a></li>
      
        <li><a href="/about/"> 關於我 </a></li>
      
    </ul>

    <p>&copy; 2017. All rights reserved. </p>
  </div>
</div>


		<div class="content container">
			<div class="post">
			 	<h1>Swift 基礎語法筆記</h1>
			  <span class="post-date">Tue, Oct 4, 2016</span>
			      

<h1 id="參考資料">參考資料</h1>

<p>感謝大大～～
<a href="https://itisjoe.gitbooks.io/swiftgo/content/">https://itisjoe.gitbooks.io/swiftgo/content/</a>
因應swift3，筆記內容與gitbook上略有不同</p>

<h1 id="struct和enum是value-type-class是reference-type">struct和enum是value type, class是reference type</h1>

<ul>
<li>struct宣告為常數，就無法更改內部的值，但class可以。</li>
<li>struct和enum這種value type，內部member function不能修改member data的值</li>
<li>如果真的要修改要加上mutating修飾字</li>
</ul>

<pre><code class="language-swift">struct Apple{
    var x = 0.0
    mutating func add(num:Double){
        x += num
    }
}

var x = Apple(x:1.2)
x.add(1.5)
print(x.x)
</code></pre>

<ul>
<li>mutating 還可以替換掉本身的實體結構</li>
</ul>

<pre><code class="language-swift">struct Apple{
    var x = 0.0
    mutating func new(num:Double){
        x = Apple()
    }
}
</code></pre>

<h1 id="function注意事項">function注意事項</h1>

<p>call function時，參數後要指定參數名稱，不可以省略</p>

<pre><code class="language-swift">func plus(a :Int, b:Int){
  print(a+b)
}
plus(a:1, b:3)
</code></pre>

<p>如果要省略要加上底線</p>

<pre><code class="language-swift">func plus(_ a :Int,_ b:Int){
  print(a+b)
}
plus(1, 3)
</code></pre>

<h2 id="外部參數名稱-external-parameter-name">外部參數名稱(External parameter Name)</h2>

<p>事實上a前面的底線是External parameter Name的意思。External parameter Name用於外部呼叫Function時的參數識別名，若不寫則與內部名稱相同。
而底線代表不在意參數識別名稱，即為可忽略的意思。</p>

<pre><code class="language-swift">func plus(AAA a :Int,BBB b:Int){
  print(a+b)
}
plus(AAA:1, BBB:3)
</code></pre>

<h1 id="型別方法">型別方法</h1>

<p>在class中要宣告class方法(非object方法)，可以用關鍵字<strong>class</strong>或<strong>static</strong></p>

<pre><code class="language-swift">class SomeClass {
    // 定義一個型別方法
    class func someTypeMethod() {
        print(&quot;型別方法&quot;)
    }
}
</code></pre>

<h1 id="closure">Closure</h1>

<h2 id="函式也是一種型別">函式也是一種型別</h2>

<p>型別名稱為
(參數型別)-&gt;回傳型別</p>

<h2 id="化function為clousure">化function為Clousure</h2>

<ol>
<li>刪掉func與函式名</li>
<li>將大括號移到最外側</li>
<li>在參數後面加上in</li>
</ol>

<p>before</p>

<pre><code class="language-swift">func add(x:Int, y:Int)-&gt;Int{
    return x + y
}
</code></pre>

<p>after</p>

<pre><code class="language-swift">{
    (x:Int, y:Int)-&gt;Int in
  return x + y
}
</code></pre>

<h2 id="closure簡寫">Closure簡寫</h2>

<ol>
<li><p>如果已經知道參數跟回傳值的型別的話，可以省略Clousure裡的參數與回傳值型別</p>

<pre><code class="language-swift">let numberArray=[1,3,6,8,10,45]
  numberArray.map( {(number) in return number+10} ) // 省略型別
</code></pre></li>

<li><p>如果Closure有回傳值，而且程式碼是一行的話，可以省略return，</p>

<pre><code class="language-swift">let numberArray=[1,3,6,8,10,45]
  numberArray.map( {(number) in number+10} ) // 回傳number+10
</code></pre></li>

<li><p>可以用$0, $1 &hellip; 代表參數。</p>

<pre><code class="language-swift">let numberArray=[1,3,6,8,10,45]
  numberArray.map( {$0 + 10} ) // 省略參數，利用$0代表參數
</code></pre></li>

<li><p>如果Closure是最後一個參數的話，可以把clousure寫在小括號的外面。</p>

<pre><code class="language-swift">  let numberArray=[1,3,6,8,10,45]
  numberArray.map(){$0 + 10} // 寫在小括號的外面
</code></pre></li>

<li><p>如果Closure是唯一的參數的話，可以省略小括號</p>

<pre><code class="language-swift">let numberArray=[1,3,6,8,10,45]
  numberArray.map{$0 + 10} // 直接省掉小括號
</code></pre></li>
</ol>

<h1 id="guard的用途">guard的用途</h1>

<p>guard比if能更好的實行Defensive Programming，因為在guard中的可選綁定可以在接下來code中使用。</p>

<pre><code class="language-swift">var text:String? = &quot;abc&quot;
if let apple = text{
    print(apple)
}
// 在這邊用會失敗
// print(apple)
</code></pre>

<pre><code class="language-swift">var text:String? = &quot;abc&quot;
guard let apple = text else{
    print(apple)
}
// 照用
print(apple)
</code></pre>

<h1 id="error">Error</h1>

<p>Swift丟出的異常是一種enum，實作時繼承Error。
有幾種方法
1. 最基本的do try catch
2. 向上拋擲function填throw
3. try? : 如果出現錯誤則回傳nil(不用再寫do catch)，可搭配optinal binding
4. try! : 一定成功。(若沒成功會crash)</p>

<h1 id="init">init</h1>

<h2 id="init-1">init?</h2>

<p>init?代表可以回傳nil，也就是可能init失敗。
參看下面的code</p>

<pre><code class="language-swift">class Baby{
    var age:Int
    init?(age:Int){
    if age &lt; 0{
        return nil
    }
    self.age = age
  }
}
</code></pre>

<p>一個寶寶生出來小於一歲是不合理的，所以init失敗回傳nil</p>

<h2 id="init的順序">init的順序</h2>

<ul>
<li>原則1：屬性的初始,必須在當初宣告屬性的類別裡進⾏。</li>
<li>原則2：⼦類別得先完成⾃⼰屬性的初始後，才能進⾏⽗類別屬性的初始。

<ul>
<li>此原則是為了防止繼承的class複寫基礎class的方法，而基礎的class使用此方法來初始化。</li>
<li>若此function剛好動用到繼承class之porperty，那就會出現問題。</li>
</ul></li>
</ul>

<p>假設有一個基礎型別寶寶</p>

<pre><code class="language-swift">class Baby{
    var age:Int
    init(age:Int){
        self.age = age
    }
}
</code></pre>

<p>正確的範例</p>

<pre><code class="language-swift">class SuperBaby: Baby{
    var magic:Int
    init(age:Int, magic:Int){
        self.magic = magic
        super.init(age: age)
    }
}
</code></pre>

<p>錯誤的範例: 違反原則1，age屬性的初始化不在宣告的類別裡。</p>

<pre><code class="language-swift">class SuperBaby: Baby{
    var magic:Int
    init(age:Int, magic:Int){
        self.magic = magic
        self.age = age
        super.init(age: age)
    }
}
</code></pre>

<p>錯誤的範例: 違反原則2，必須先將自己的屬性先初始化完畢，才能call super init</p>

<pre><code class="language-swift">class SuperBaby: Baby{
    var magic:Int
    init(age:Int, magic:Int){
            super.init(age: age)
        self.magic = magic
    }
}
</code></pre>

<p>正確的範例: 在age初始化後才改變age的值</p>

<pre><code class="language-swift">class SuperBaby: Baby{
    var magic:Int
    init(age:Int, magic:Int){
        self.magic = magic
        super.init(age: age)
        self.age = age
    }
}
</code></pre>

<h2 id="convenience-init">convenience init</h2>

<p>有兩種類型的init
- designated initializer : 一般的init
- convenience initializer : 加了關鍵字convenience的init</p>

<p>擁有convenience關鍵字的init才可以call其他init function，來減少重複工作，非常<strong>方便</strong>。
舉例來說：</p>

<pre><code class="language-swift">class Baby{
    var age:Int
    var name:String
    init(age:Int, name:String){
        self.age = age
        self.name = name
    }
    
    convenience init(name:String){
            self.init(age:1, name:name)
    }
}
</code></pre>

<h2 id="init的繼承">init的繼承</h2>

<ul>
<li>designated initializer的繼承

<ul>
<li>子類別沒有定義任何designated initializer，預設全部自動繼承。</li>
<li>子類別定義了任意init，不會自動繼承父類別的init。</li>
</ul></li>
<li>convenience initializer的繼承

<ul>
<li>子類別沒有定義任何designated initializer，預設全部自動繼承。</li>
<li>子類別覆寫了父類別所有的designated initializer，則自動繼承所有convenience initializer。</li>
<li>子類別複寫不完全，則不會繼承convenience initializer。</li>
</ul></li>
</ul>

<pre><code class="language-swift">
</code></pre>

<pre><code class="language-swift">
</code></pre>

<h2 id="使用required防止init失傳">使用required防止init失傳</h2>

			</div>

			
		</div>

  </body>
</html>
