<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jni on Denny&#39;s Blog</title>
    <link>https://cdfq152313.github.io/tags/jni/</link>
    <description>Recent content in Jni on Denny&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 05 Aug 2016 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://cdfq152313.github.io/tags/jni/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Android JNI 環境建置</title>
      <link>https://cdfq152313.github.io/post/2016-08-05/</link>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-08-05/</guid>
      <description>介紹 主要參考這篇：Android studio 1.5.1 NDK JNI環境安裝與執行原理
不過Android 2.1.2上步驟稍有簡化，還是可以達到同樣效果。
 載NDK 設定external tool (僅javah) 在java中增加native code，並利用javah產生JNI header 實作JNI 設定gradle (僅ndk區塊)  載NDK 開啟SDK Manager，選擇SDK Tools，將NDK之選項給打勾。
設定external tool 與連結相同，不過只要設定javah即可，其他不需要。
快速複製區 來源
$JDKPath$/bin/javah -v -jni -d $ModuleFileDir$/src/main/jni $FileClass$ $SourcepathEntry$  Windows和Linux在第1行稍有分別，只有在Windows系統中，執行檔的副檔名才是.exe。Mac和Linux皆否。 個人是用linux系統，所以第1行javah後面並不接.exe，若是Windows系統則第1行變為。
$JDKPath$/bin/javah.exe  JNI header 在想要使用JNI的class加入如下的程式碼。
 static { System.loadLibrary(&amp;quot;myJNI&amp;quot;); } public native String getMycstring(); public native void testLog();  static區塊中的myJNI會變成將來再build gradle當中的moduleName
method加上native關鍵詞後，程式就會知道這是需要依靠JNI實作之程式碼。
再來在該java檔上按右鍵，使用剛剛建置好的external library javah，自動的產生JNI header。
此時在java目錄下，應該會多出一個jni的資料夾，裡頭放置著 OOXX.h
打開.h檔，建置出來的code應該會如下形式
/* DO NOT EDIT THIS FILE - it is machine generated */ #include &amp;lt;jni.</description>
    </item>
    
  </channel>
</rss>