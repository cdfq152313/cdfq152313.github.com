<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Denny&#39;s Blog</title>
    <link>https://cdfq152313.github.io/index.xml</link>
    <description>Recent content on Denny&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 02 Apr 2017 15:23:51 +0800</lastBuildDate>
    <atom:link href="https://cdfq152313.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Android 利用gson解析json</title>
      <link>https://cdfq152313.github.io/post/2017-04-01/</link>
      <pubDate>Sun, 02 Apr 2017 15:23:51 +0800</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2017-04-01/</guid>
      <description>

&lt;h1 id=&#34;android-利用gson解析json&#34;&gt;Android 利用gson解析json&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/shaosks/p/5201837.html&#34;&gt;反射和序列化&lt;/a&gt;&lt;br /&gt;
在開始前先貼篇文章暖暖身，讓大家了解Reflection(反射)和Serialization(序列化)的不同&lt;/p&gt;

&lt;p&gt;常常在串接API時，伺服器端傳過來的是json格式。
我個人是很不相信自己的眼睛，所以直接用string get field的動作我是盡量不寫的。
取而代之的是用Gson提供的Deserializatione(反序列化)工具來達成這個目標，反序列化底層的實作是依賴Reflection(反射)機制而達成，不過不是這篇的重點。&lt;/p&gt;

&lt;p&gt;如果有json data如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
    &amp;quot;fruit&amp;quot;: &amp;quot;apple&amp;quot;,
    &amp;quot;hello&amp;quot;: &amp;quot;world&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我會用一個class，有著跟json檔一模一樣的field。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Data{
    public String fruit;
    public String hello;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後利用Gson的fromJson函式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Data jsonData(String jsonStr){
    Gson gson = new Gson();
    Data result = gson.fromJson(jsonStr, Data.class);
    return result;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;將檔案給解析出來，如果實際的json物件屬性跟class資料屬性對不上的話，就會拋擲異常。
fromJson這個函式就是Gson的反序列化工具。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Android Dialog取消動作</title>
      <link>https://cdfq152313.github.io/post/2017-03-27/</link>
      <pubDate>Mon, 27 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2017-03-27/</guid>
      <description>&lt;p&gt;使用AlertDialog時，當點在Dialog的外圍，Android會讓此Dialog消失，並且什麼動作都不執行。
如果剛好positive和negative的按鈕都是有明確動作的，並不想被取消，可以透過&lt;strong&gt;setCancelable(boolean)&lt;/strong&gt;這個函式來強制使用者不得取消。
不過有時會希望使用者可以透過點擊按鈕或點擊Dialog外圍來執行取消動作(非null空動作)，但在AlertDialog的函式庫中是無能為力的，我查了&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;setOnCancelListener&lt;/li&gt;
&lt;li&gt;setOnDismissListener&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;這兩個函式都會導致程式異常停止。最後查到應該使用DialogFragment當中的onCancel動作來解決這個問題。
以下範例程式碼&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MyDialogFragment extends DialogFragment {
    private final static String TAG = &amp;quot;MyDialog&amp;quot;;

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        builder.setTitle(&amp;quot;Hello&amp;quot;)
                .setPositiveButton(&amp;quot;YA&amp;quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        Log.i(TAG, &amp;quot;Positive&amp;quot;);
                    }
                })
                .setNegativeButton(&amp;quot;NO&amp;quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        Log.i(TAG, &amp;quot;Negative&amp;quot;);
                    }
                });
        return builder.create();
    }

    @Override
    public void onCancel(DialogInterface dialog) {
        super.onCancel(dialog);
        Log.i(TAG, &amp;quot;OnCancel&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重點如下
1. 繼承DialogFragment
2. 複寫onCreateDialog方法，並回傳一個Dialog (跟以往AlertDialog的使用方法一樣)
3. 複寫onCancel方法，裡面放上&lt;strong&gt;點擊外框使AlertDialog消失&lt;/strong&gt;時要觸發的事件。
    - 注意：如果是點positive Button或negative Button皆不會觸發這個函式。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python AES (PyCrypto)</title>
      <link>https://cdfq152313.github.io/post/2017-02-23/</link>
      <pubDate>Thu, 23 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2017-02-23/</guid>
      <description>

&lt;h1 id=&#34;程式碼&#34;&gt;程式碼&lt;/h1&gt;

&lt;p&gt;為了易於保存，所有金鑰、向量、輸出結果都是以Base64編碼。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from Crypto.Cipher import AES
from Crypto import Random
import base64

BS = AES.block_size
pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)
unpad = lambda s : s[0:-ord(s[-1])]

class AES_HELPER(object):
    def __init__(self):
        print &#39;init&#39;

    def key_generator(self, bits=256):
        random = Random.new()
        key = random.read( bits/8 )
        return base64.b64encode(key)

    def iv_generator(self):
        &#39;&#39;&#39;
        AES Initialization Vector is 128 bits(16 bytes).
        &#39;&#39;&#39;
        random = Random.new()
        key = random.read( 16 )
        return base64.b64encode(key)

    def encrypt(self, b64key, b64iv, data):
        key = base64.b64decode(b64key)
        iv = base64.b64decode(b64iv)

        cryptor = AES.new(key, AES.MODE_CBC, iv)
        data = pad(data)
        encrypted = cryptor.encrypt(data)
        encrypted = base64.b64encode(encrypted)
        return encrypted

    def decrypt(self, b64key, b64iv, data):
        key = base64.b64decode(b64key)
        iv = base64.b64decode(b64iv)

        cryptor = AES.new(key, AES.MODE_CBC, iv)
        decrypted = base64.b64decode(data)
        decrypted = cryptor.decrypt(decrypted)
        decrypted = unpad( decrypted )
        return decrypted

aes_helper = AES_HELPER()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用上也蠻容易的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if __name__ == &#39;__main__&#39;:
    key = aes_helper.key_generator()
    iv = aes_helper.iv_generator()
    data = &amp;quot;Hello moto. I&#39;m fire. Thank you. I got fired. Thank you. Madadabi meow meow Madadabi meow.&amp;quot;
    encrypted = aes_helper.encrypt(key, iv, data)
    decrypted = aes_helper.decrypt(key, iv, encrypted)
    print (&#39;data: %s&#39; % data )
    print (&#39;encrypted: %s&#39; % encrypted )
    print (&#39;decrypted: %s&#39; % decrypted )
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;random的使用&#34;&gt;Random的使用&lt;/h1&gt;

&lt;p&gt;在使用AES的時候會需要用到兩個隨機生產的東西
1. 金鑰: 可為128 192 256 bits，金鑰長度越長越不容易被破解。
2. 初始化向量: 只有128 bits的形式，為了避免同樣的文章在同一金鑰下會被加密為同樣密文，從而增加被破解風險。&lt;/p&gt;

&lt;p&gt;這邊要特別注意的是必須使用pycrypto所提供的Random，而不能用python原生地random，不然亂數會不夠安全。
以下為產生金鑰的程式碼&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from Crypto import Random
import base64

def key_generator(bits=256):
  random = Random.new()
  key = random.read( bits/8 )
  return base64.b64encode(key)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用random.read()來產生隨機的金鑰串，裡面的參數決定了金鑰串的長度，&lt;strong&gt;單位是bytes&lt;/strong&gt;。
初始向量也是同樣的作法，只是這次要限制在128 bits(16 bytes)&lt;/p&gt;

&lt;h1 id=&#34;padding-pkcs5-pkcs7&#34;&gt;Padding (PKCS5 / PKCS7)&lt;/h1&gt;

&lt;p&gt;這邊要特別注意有所謂的padding問題，在網路上找了一些解決的方法，以下是程式碼。
&lt;a href=&#34;http://likang.me/blog/2013/06/05/python-pycrypto-aes-ecb-pkcs-5/&#34;&gt;http://likang.me/blog/2013/06/05/python-pycrypto-aes-ecb-pkcs-5/&lt;/a&gt;
&lt;a href=&#34;https://gist.github.com/crmccreary/5610068&#34;&gt;https://gist.github.com/crmccreary/5610068&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;BS = 16
pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS) 
unpad = lambda s : s[0:-ord(s[-1])]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Java (Android) AES</title>
      <link>https://cdfq152313.github.io/post/2017-02-22/</link>
      <pubDate>Wed, 22 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2017-02-22/</guid>
      <description>

&lt;h1 id=&#34;平台&#34;&gt;平台&lt;/h1&gt;

&lt;p&gt;Android Studio
- compileSdkVersion 25
- buildToolsVersion &amp;ldquo;25.0.1&amp;rdquo;&lt;/p&gt;

&lt;h1 id=&#34;全域變數&#34;&gt;全域變數&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SecretKey secretKey; // 金鑰
AlgorithmParameterSpec mAlgorithmParameterSpec; // 之後要放置初始化向量的參數
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;初始化&#34;&gt;初始化&lt;/h1&gt;

&lt;h2 id=&#34;金鑰初始化&#34;&gt;金鑰初始化&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void genAESKey() throws Exception {
  KeyGenerator keyGen = KeyGenerator.getInstance(&amp;quot;AES&amp;quot;); // 指定AES演算法
  keyGen.init(256, new SecureRandom()); // 指定256位元，並使用SecureRandom
  secretKey = keyGen.generateKey(); // 產生AES金鑰
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;初始向量初始化&#34;&gt;初始向量初始化&lt;/h2&gt;

&lt;p&gt;private void genInitializationVector() throws NoSuchPaddingException, NoSuchAlgorithmException {
  cipher = Cipher.getInstance(&amp;ldquo;AES/CBC/PKCS5Padding&amp;rdquo;); // 指定AES演算法
  byte [] iVAES = new byte[ cipher.getBlockSize() ]; // new AES演算法所需的block size
  SecureRandom random = new SecureRandom();
  random.nextBytes(iVAES); // 填充向量
  mAlgorithmParameterSpec = new IvParameterSpec(iVAES); // 向量初始化
}&lt;/p&gt;

&lt;h1 id=&#34;將字串加密&#34;&gt;將字串加密&lt;/h1&gt;

&lt;p&gt;在AES加密完之後，用Base64把結果轉成可讀的字串以便以http傳送。
不做Base64亦可，只是到時候要以byte為單位做傳送。
初始化模式為 ENCRYPT_MODE&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private String encrypt(String content) throws Exception {
    cipher = Cipher.getInstance(&amp;quot;AES/CBC/PKCS5Padding&amp;quot;);
    cipher.init(Cipher.ENCRYPT_MODE, secretKey, mAlgorithmParameterSpec);
    byte [] encrypt = cipher.doFinal(contentB64);
  return Base64.encodeToString(encrypt, Base64.DEFAULT);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;將字串解密&#34;&gt;將字串解密&lt;/h1&gt;

&lt;p&gt;初始化模式為 DECRYPT_MODE&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private String decrypt(String content) throws Exception{
  cipher = Cipher.getInstance(&amp;quot;AES/CBC/PKCS5Padding&amp;quot;);
  cipher.init(Cipher.DECRYPT_MODE, secretKey, mAlgorithmParameterSpec);
  byte [] temp = Base64.decode(content, Base64.DEFAULT); // 將字串還原為bytes
  byte [] decodeBytes = cipher.doFinal(temp); // 解密
  return new String(decodeBytes); // 編回字串
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;匯出金鑰&#34;&gt;匯出金鑰&lt;/h1&gt;

&lt;p&gt;SecretKey使用getEncoded()可以獲得金鑰，為byte形式，若要方便閱讀與傳送可以轉換為Base64
初始化向量本身有getIV()這個method可以使用，一樣為byte形式，可轉換為Base64。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void export(){
  String secretKeyB64 = Base64.encodeToString(secretKey.getEncoded(), Base64.DEFAULT);
  IvParameterSpec iv = (IvParameterSpec) mAlgorithmParameterSpec;
  String vectorB64 = Base64.encodeToString(iv.getIV(), Base64.DEFAULT);

  Log.i(&amp;quot;Secret Key Base64&amp;quot;, secretKeyB64);
  Log.i(&amp;quot;Vector Base64&amp;quot;, vectorB64);
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Android 文章整理</title>
      <link>https://cdfq152313.github.io/post/2017-02-08/</link>
      <pubDate>Wed, 08 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2017-02-08/</guid>
      <description>

&lt;h1 id=&#34;linearlayout&#34;&gt;Linearlayout&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/xiaanming/article/details/13630837&#34;&gt;Android 对Layout_weight属性完全解析以及使用ListView来实现表格&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;fragment&#34;&gt;fragment&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/guide/components/fragments.html?hl=zh-tw&#34;&gt;官方API Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/xiaanming/article/details/13630837&#34;&gt;Android Fragment 真正的完全解析（上）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/lmj623565791/article/details/37992017&#34;&gt;Android Fragment 真正的完全解析（下）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/32077086/android-onattachcontext-not-called-for-api-23&#34;&gt;Fragment Lifecycle中的onAttach&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;toolbar&#34;&gt;Toolbar&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/training/appbar/index.html&#34;&gt;官方API Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/lovexieyuan520/article/details/9974929&#34;&gt;Toolbar左上方的返回鈕&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stackoverflow.com/questions/26778701/how-to-add-buttons-like-refresh-and-search-in-toolbar-in-android&#34;&gt;加入新的圖示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://wuxiaolong.me/2015/11/10/toolbar/&#34;&gt;Toolbar在Activity和Fragment下的使用情況&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;recyclerview-和-listview&#34;&gt;RecyclerView 和 ListView&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jianshu.com/p/f592f3715ae2&#34;&gt;RecyclerView 和 ListView的對比&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;ui-ux&#34;&gt;UI/UX&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wasabeef/awesome-android-ui&#34;&gt;List of Android UI/UX Libraries&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/medyo/Fancybuttons&#34;&gt;Fancy Button&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;testing&#34;&gt;Testing&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://chriszou.com/2016/04/16/android-unit-testing-about-why.html&#34;&gt;Android单元测试（二）：再来谈谈为什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chriszou.com/2016/04/29/android-unit-testing-mockito.html&#34;&gt;Android单元测试（四）：Mock以及Mockito的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://chriszou.com/2016/08/06/android-unit-testing-async.html&#34;&gt;安卓单元测试(十一)：异步代码怎么测试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;library整合&#34;&gt;Library整合&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://guides.codepath.com/android/Must-Have-Libraries&#34;&gt;整合1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;parcelable-vs-serializable&#34;&gt;Parcelable vs Serializable&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/trinea/archive/2012/11/09/2763213.html&#34;&gt;Android Parcelable和Serializable的區別&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;權限管理&#34;&gt;權限管理&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://litotom.com/2016/05/15/android-6-permission/&#34;&gt;Android綠豆湯 - Android 6.0的Permission權限設計&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;檔案處理&#34;&gt;檔案處理&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.android.com/training/basics/data-storage/files.html?hl=zh-tw&#34;&gt;Android developer - 儲存檔案&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;心得&#34;&gt;心得&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/futurice/android-best-practices&#34;&gt;Best practice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>寫給朋友看的function與class</title>
      <link>https://cdfq152313.github.io/misc/2017-01-15/</link>
      <pubDate>Sun, 15 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/misc/2017-01-15/</guid>
      <description>

&lt;h1 id=&#34;今天有個簡易的app功能如下&#34;&gt;今天有個簡易的app功能如下&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;只有一個ViewController&lt;/li&gt;
&lt;li&gt;這個ViewController上只有兩個UITextView&lt;/li&gt;
&lt;li&gt;Input: &amp;ldquo;01/15&amp;rdquo; 代表1月15日&lt;/li&gt;
&lt;li&gt;想要結果: 在第一個UITextView上呈現 &amp;ldquo;1 月&amp;rdquo;，在第二個UITextView上呈現&amp;rdquo;15日&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;這時候可能會寫一個function在Controller裡頭，叫做split，input為字串，output為陣列。
input為&amp;rdquo;01/15&amp;rdquo;的話，會出現output [&amp;ldquo;01&amp;rdquo;, &amp;ldquo;15&amp;rdquo;]
然後call一下這個function，分別把兩個UITextView給賦值陣列0和陣列1，就可以運作得很完美了。&lt;/p&gt;

&lt;h1 id=&#34;接下來追加規格&#34;&gt;接下來追加規格&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;多了兩三個ViewController，同樣需要展示日期。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;這時候笨方法是把剛剛的function複製到四個不同的ViewController，然後再一一呼叫。
聰明一點的方法是放到全域變數，這樣不用重寫function，但是每一個Controller都能呼叫。&lt;/p&gt;

&lt;h1 id=&#34;再度追加規格&#34;&gt;再度追加規格&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;除了顯示月日的function，我還想要展示年分。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;這次可能會依樣畫葫蘆，寫個叫做splityearmonthday的function，放在全域變數裡面，讓所有Controller都能使用。&lt;/p&gt;

&lt;h1 id=&#34;再再度追加規格&#34;&gt;再再度追加規格&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;這個APP多了付款功能所以需要展示金額。&lt;/li&gt;
&lt;li&gt;這個展示金額靠著另外兩個UITextView，第一個UITextView展現整數，第二個UITextView展現小數。&lt;/li&gt;
&lt;li&gt;假設input &amp;ldquo;23.7&amp;rdquo;，那會在第一個UITextView出現23 第二個UITextView出現.7&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;於是又寫了一個splitmoney的funcion，放在全域變數裡。&lt;/p&gt;

&lt;h1 id=&#34;反思&#34;&gt;反思&lt;/h1&gt;

&lt;p&gt;到了這裡可以開始反思這是不是一個良好的設計了，起初APP的功能的確很簡單，但是隨著需求的擴張，分割日期的function就出現了兩種。後期更出現了分割金額的function。我們假設需求繼續擴張下去，接下來有&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;10個分割日期的function&lt;/li&gt;
&lt;li&gt;5個分割金額的function&lt;/li&gt;
&lt;li&gt;8個分割OOXX的function&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;你光看全域變數上的function頭就要昏了，而且還得注意名稱不得重複，每個名稱都取的又臭又長，即使這都是一些小小的function，依然會對開發人員帶來負擔。&lt;/p&gt;

&lt;p&gt;此時，如果你用class將分割日期、分割金額、分割OOXX的職責區分開來，程式碼或許會變得清晰? 舉例來說
func splityearmonthday()
func splitmonthday()
改為
=&amp;gt;
class DateSplit{
    func yearmonth()
    func monthday()
}&lt;/p&gt;

&lt;h1 id=&#34;總結&#34;&gt;總結&lt;/h1&gt;

&lt;p&gt;簡單總結：
class的作用在於區分職責，不同功能的function盡可能的放在不同的class，這是為了可讀性。
程式規模小的時候，可以不必花太多心力把每個功能都丟一個class，但是當程式開始漸漸擴張，就要開始思考，我這些function之間是否有類似的職責，能夠被包成一個class來執行?
再來就是，其實並不是每件事情都可以靠function的input output就解決，有時候你可能會想記錄狀態。
舉例來說，如果你寫了一個計算機的程式，那你會希望計算機記得你上次按了什麼按鈕，這時候如果你再使用全域變數和全域function來解決問題，等老闆要求你&amp;rdquo;我今天要兩個計算機，不要一個&amp;rdquo;，的時候就尷尬了，因為你的狀態是靠全域變數來記，兩個計算機參考到同一個全域變數，就G_G惹。
希望有幫助到你。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python Mac Sierra pyinstaller py2app 的權限問題</title>
      <link>https://cdfq152313.github.io/post/2016-12-27/</link>
      <pubDate>Tue, 27 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-12-27/</guid>
      <description>&lt;p&gt;最近遇到一個問題，使用pyinstaller製作執行檔後，在本機運作上ok，但是一傳給別人使用就會出問題。
可是用右鍵show packages裡面的Content/MacOS/執行檔，是可以正常使用的。
這讓我非常困惑，後來才發現是Sierra權限設定更改。&lt;/p&gt;

&lt;p&gt;英文好的可以直接看下面就解決了：
&lt;a href=&#34;http://lapcatsoftware.com/articles/app-translocation.html&#34;&gt;http://lapcatsoftware.com/articles/app-translocation.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;英文不好的簡單翻譯就是：
解壓縮zip後的任何app檔，在執行期的時候會自動放入App Translocation這個唯讀資料夾運行。
因為是唯讀資料夾，所以不能寫入，我的程式就是因為有寫入功能才失敗。
解決方法是拖拉這個app到任意其他位置(ex:桌面)，OSX就不會再幫你把這個app放進唯讀資料夾執行。&lt;/p&gt;

&lt;p&gt;還記得幾乎所有的MAC app都需要拖拉到應用程式裡面才能使用嗎? MAC應該就是希望你對想使用的APP進行過此一確認才加上這個功能。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[讀書心得] 圖解密碼學與比特幣原理</title>
      <link>https://cdfq152313.github.io/misc/2016-12-27/</link>
      <pubDate>Tue, 27 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/misc/2016-12-27/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.tenlong.com.tw/items/9864761935?item_id=1025404&#34;&gt;圖解密碼學與比特幣原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;花了很久才斷斷續續的看完這本，覺得是一本很不錯的科普書，沒有太艱深的數學。&lt;/p&gt;

&lt;p&gt;書中有系統的把目前密碼學的發展介紹了一遍，非常著重在oo密碼技術可以解決xx難題，或是oo技術無法解決xx難題。以及oo技術中的yy演算法目前無人破解，或是oo技術的yy演算法已經被破解。&lt;/p&gt;

&lt;p&gt;書中最後也提到了不少混合型密碼系統在現今世界上的應用，讓這本書不會只流於技術介紹的紙上談兵。對我這個密碼學大外行幫助很大，好書，極推。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java RSA</title>
      <link>https://cdfq152313.github.io/post/2016-12-01/</link>
      <pubDate>Thu, 01 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-12-01/</guid>
      <description>

&lt;h1 id=&#34;讀金鑰&#34;&gt;讀金鑰&lt;/h1&gt;

&lt;p&gt;感謝大大無私分享，大大一生平安
&lt;a href=&#34;http://stackoverflow.com/questions/11410770/load-rsa-public-key-from-file&#34;&gt;http://stackoverflow.com/questions/11410770/load-rsa-public-key-from-file&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;加密&#34;&gt;加密&lt;/h1&gt;

&lt;p&gt;感謝大大無私分享，大大一生平安
&lt;a href=&#34;http://jimwayne.blogspot.tw/2012/06/java_25.html&#34;&gt;http://jimwayne.blogspot.tw/2012/06/java_25.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>基礎知識惡補 - Http協定</title>
      <link>https://cdfq152313.github.io/post/2016-11-24/</link>
      <pubDate>Thu, 24 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-11-24/</guid>
      <description>

&lt;p&gt;來源網址：&lt;a href=&#34;https://read01.com/J8P4L.html&#34;&gt;https://read01.com/J8P4L.html&lt;/a&gt;
要注意最後一段說get比較不安全是錯的，你他媽的不轉成https通通都是不安全。&lt;/p&gt;

&lt;h1 id=&#34;client端&#34;&gt;Client端&lt;/h1&gt;

&lt;p&gt;分三區塊
- Request line
- Request header
- Body&lt;/p&gt;

&lt;h2 id=&#34;request-line&#34;&gt;Request line&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;有著方法描述，資源位置，協議版本&lt;/li&gt;
&lt;li&gt;例如：GET &lt;a href=&#34;http://www.cnblogs.com/&#34;&gt;http://www.cnblogs.com/&lt;/a&gt; HTTP/1.1&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;request-header&#34;&gt;Request header&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Accept：client告知server可以接受的媒體類型(json, xml, html &amp;hellip;)，大部分使用*/*代表全部都接受。&lt;/li&gt;
&lt;li&gt;Referer：告訴伺服器端我是從哪裡連過來&lt;/li&gt;
&lt;li&gt;Accept-Language：瀏覽器端接受的語言

&lt;ul&gt;
&lt;li&gt;EX: 中文、英文&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Accept-Charset：瀏覽器端接受的字符集

&lt;ul&gt;
&lt;li&gt;EX: BIG5, UTF-8, GBK &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Content-Type

&lt;ul&gt;
&lt;li&gt;Body的檔案類型&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://webmasters.stackexchange.com/questions/31212/difference-between-the-accept-and-content-type-http-headers&#34;&gt;補充資料&lt;/a&gt;，與Accept的差別&lt;/li&gt;
&lt;li&gt;簡單的說，當client傳送檔案給server，content-type可以描述這個檔案的類型。當server吐response回給client，content-type一樣可以描述這個檔案的類型。&lt;/li&gt;
&lt;li&gt;accept是請求對方返回的類型，content-type是實際一個request或response中夾帶的類型。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Accept-Encoding：client端的編碼(壓縮)方法&lt;/li&gt;
&lt;li&gt;User-Agent：client端的作業系統，瀏覽器名稱&lt;/li&gt;
&lt;li&gt;Connection

&lt;ul&gt;
&lt;li&gt;是否在接收完檔案後立刻斷開TCP&lt;/li&gt;
&lt;li&gt;[補充資料])(&lt;a href=&#34;https://www.byvoid.com/zht/blog/http-keep-alive-header&#34;&gt;https://www.byvoid.com/zht/blog/http-keep-alive-header&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Content-length: 訊息長度&lt;/li&gt;
&lt;li&gt;Host：該資源的domain Name&lt;/li&gt;
&lt;li&gt;剩下一些懶得看

&lt;ul&gt;
&lt;li&gt;Pragma&lt;/li&gt;
&lt;li&gt;Cookie&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;body&#34;&gt;Body&lt;/h2&gt;

&lt;p&gt;就是個Body&lt;/p&gt;

&lt;h1 id=&#34;server端&#34;&gt;Server端&lt;/h1&gt;

&lt;p&gt;一樣分三區塊
- Response line
- Response header
- Body&lt;/p&gt;

&lt;h2 id=&#34;response-line&#34;&gt;Response line&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;協議版本及狀態碼&lt;/li&gt;
&lt;li&gt;例如：HTTP/1.1 200 OK&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;response-header&#34;&gt;Response header&lt;/h2&gt;

&lt;p&gt;有些部分跟request一樣，少部分懶得看。&lt;/p&gt;

&lt;p&gt;Content-Type：回傳資料的型態
Expired：回傳資料過期時間
- 懶得看
    - Cache-Control
  - Last-Modified:
    - Server
    - X-AspNet-Version:
    - X-Powered-By:
    - Connection
    - Content-Length
    - Date&lt;/p&gt;

&lt;h2 id=&#34;body-1&#34;&gt;Body&lt;/h2&gt;

&lt;p&gt;就只是個Body&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift Mail &amp; Message</title>
      <link>https://cdfq152313.github.io/post/2016-11-02/</link>
      <pubDate>Wed, 02 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-11-02/</guid>
      <description>

&lt;h1 id=&#34;mail&#34;&gt;Mail&lt;/h1&gt;

&lt;p&gt;不能在模擬器上跑，會crash。&lt;/p&gt;

&lt;h2 id=&#34;簡單流程&#34;&gt;簡單流程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;初始化MFMailComposeViewController&lt;/li&gt;
&lt;li&gt;設定標題以及收件者&lt;/li&gt;
&lt;li&gt;推出MFMailComposeViewController&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import MessageUI

func sendMail(){
  let mailController = MFMailComposeViewController()
  mailController.setSubject(&amp;quot;swift程式設計入門&amp;quot;)
  mailController.setToRecipients([&amp;quot;cdfq152313@gmail.com&amp;quot;])
  self.present(mailController, animated: true, completion: nil)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;測試能不能使用mail功能&#34;&gt;測試能不能使用Mail功能&lt;/h2&gt;

&lt;p&gt;像是在模擬器上就不能使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;if MFMailComposeViewController.canSendMail(){
    // 可以寄信
}
else{
    // 不能寄信
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mailcomposedelegate&#34;&gt;mailComposeDelegate&lt;/h2&gt;

&lt;p&gt;設定mailComposeDelegate可以讓寄信完後，dismiss到原來畫面，這邊要注意的是不要設成一般delegate了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;mailController.mailComposeDelegate = self

func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) {
        dismiss(animated: true, completion: nil)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果想知道寄信後的狀態可參考第二個參數didFinishWith result。按住command + 滑鼠左鍵在MFMailCompseResult可以知道有下列狀態。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;public enum MFMailComposeResult : Int {
    case cancelled
    case saved
    case sent
    case failed
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;夾帶圖片&#34;&gt;夾帶圖片&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 夾一張圖片
func mailCo
var image = UIImage(named: &amp;quot;book1&amp;quot;)
var data = UIImageJPEGRepresentation(image!, 0.9)
mailController.addAttachmentData(data!, mimeType:&amp;quot;image/jpg&amp;quot;, fileName: &amp;quot;book1.jpg&amp;quot;)

// 可以夾不只一個圖片
image = UIImage(named: &amp;quot;book2&amp;quot;)
data = UIImageJPEGRepresentation(image!, 0.9)
mailController.addAttachmentData(data!, mimeType: &amp;quot;image/jpg&amp;quot;, fileName: &amp;quot;book2.jpg&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;放置html檔&#34;&gt;放置HTML檔&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let body = &amp;quot;&amp;lt;h1&amp;gt;HelloWorld&amp;lt;/h1&amp;gt;&amp;quot;
mailController.setMessageBody(body, isHTML:true)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;message&#34;&gt;Message&lt;/h1&gt;

&lt;p&gt;同樣不能在模擬器上跑，會crash。&lt;/p&gt;

&lt;h2 id=&#34;簡單流程-1&#34;&gt;簡單流程&lt;/h2&gt;

&lt;p&gt;由於是訊息，只要填body即可。
收件者可以是
- 人名
- 手機號碼
- 郵件信箱&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func sendMessage(){
  let controller = MFMessageComposeViewController()
  controller.body = &amp;quot;hello&amp;quot;
  controller.recipients = [&amp;quot;Denny&amp;quot;, &amp;quot;0978948787&amp;quot;, &amp;quot;cdfq152313@gmail.com&amp;quot;]
  self.present(controller, animated: true, completion: nil)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Swift TableView 與 Collection View</title>
      <link>https://cdfq152313.github.io/post/2016-10-25/</link>
      <pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-10-25/</guid>
      <description>

&lt;h1 id=&#34;tableview&#34;&gt;TableView&lt;/h1&gt;

&lt;h2 id=&#34;indexpath-section-row&#34;&gt;IndexPath: Section &amp;amp; Row&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/razNcl9.png&#34; alt=&#34;Section and Row&#34; /&gt;
看圖應該可以明瞭Section和Row的含意，Apple把tableView劃分為section，每個section下又有row。
在IOS中有一個叫做IndexPath的類別專門儲存這兩個值，在tableView以後要override的方法會經常看到。&lt;/p&gt;

&lt;h2 id=&#34;必定要override的method-幾個section-幾個row&#34;&gt;必定要override的method: 幾個section 幾個row&lt;/h2&gt;

&lt;p&gt;使用tableView必須指定DataSource和Delegate (若是TableViewController則已經指定好自己作為這兩個protocol的實作)&lt;/p&gt;

&lt;p&gt;其中有些function是必定要override的
1. 總共有幾個section
2. 每個section裡面有幾個row&lt;/p&gt;

&lt;p&gt;在這個範例中，我指定兩個section，section 0有2 row，section 1有3 row。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 總共幾個section
override func numberOfSections(in tableView: UITableView) -&amp;gt; Int {
  return 2
}

// 每個section裡面有幾個row
override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int {
    if section == 0{
    return 2
  }
  else{
    return 3
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;某一列的內容&#34;&gt;某一列的內容&lt;/h2&gt;

&lt;p&gt;但是只有這樣，顯示出來會是空白一片，所以必須要回傳顯示的內容。
在做這個項目之前，必須先到storyBoard，將tableView裏頭的cell指定一個identifier，否則會錯誤。
在此我指定cell的identifier為myCell
&lt;img src=&#34;http://i.imgur.com/0mgnfd6.png&#34; alt=&#34;Identifier&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然後才可以在程式碼中使用myCell&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&amp;gt; UITableViewCell {
  let cell = tableView.dequeueReusableCell(withIdentifier: &amp;quot;myCell&amp;quot;, for: indexPath)

  // 顯示目前是第幾Row
  cell.textLabel?.text = &amp;quot;Row &amp;quot; + String(indexPath.row)
  return cell
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/MFz1Rhv.png&#34; alt=&#34;目前畫面&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;section-title&#34;&gt;Section Title&lt;/h2&gt;

&lt;p&gt;但是這樣少了每個section的title，沒有段落感，所以用以下的code加上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&amp;gt; String? {
  if section == 0{
    return &amp;quot;Section 0&amp;quot;
  }
  else{
    return &amp;quot;Section 1&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/razNcl9.png&#34; alt=&#34;目前畫面&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;點擊某列跳轉到下一個controller-並傳值&#34;&gt;點擊某列跳轉到下一個Controller，並傳值&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://dennycheng-blog.logdown.com/posts/946492-controller-interaction&#34;&gt;請參閱之前的傳值方法&lt;/a&gt;，我們選用方法一。這邊要補充的是：可以藉由tableview中的indexPathForselectedRow屬性來得知哪一列被選中。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;在prepare裡裡面進行傳值的預備動作。&lt;/li&gt;
&lt;li&gt;轉型Controller，這樣才可以塞property

&lt;ul&gt;
&lt;li&gt;在此我們假設SecondViewController中有selectedIndexPath這個屬性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可以藉由tableView中的indexPathForselectedRow來判定哪個Row被選中。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
  if let indexPath = tableView.indexPathForSelectedRow{
    let controller = segue.destination as! SecondViewController
    controller.selectedIndexPath = indexPath
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;滑動刪除&#34;&gt;滑動刪除&lt;/h2&gt;

&lt;p&gt;只要複寫方法即可，記得必須同時刪除實際的Array以及畫面上的元件，否則會造成畫面與實際資料不同步的問題。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {
  if editingStyle == .delete {
    // 刪除元素
    myArray.remove(at: indexPath.row)
    // 刪除畫面上的元素
    tableView.deleteRows(at: [indexPath], with: .fade)
  } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但使用這個方法，只能滑出一個按鈕。如果想滑動時有多個按鈕可以選擇請看下節。&lt;/p&gt;

&lt;h2 id=&#34;自訂滑動選項&#34;&gt;自訂滑動選項&lt;/h2&gt;

&lt;p&gt;如果想要自訂滑動按鈕的文字樣式，或是想指定多個滑動按鈕，那就不能使用上述的複寫方法。而必須改用下面這個。
1. 複寫方法
2. 自訂UITableViewRowAction
3. 回傳UITableViewRowAction陣列
因為此方法回傳陣列，所以可以塞進多個按鈕。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;override func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&amp;gt; [UITableViewRowAction]? {
        let addAction = UITableViewRowAction(style: .normal, title: &amp;quot;insert&amp;quot;) { 
            (action, indexPath) in
          // 下面可寫插入元素的動作  
        }
        
        let deleteAction = UITableViewRowAction(style: .default, title: &amp;quot;delete&amp;quot;) { 
            (action, indexPath) in
          // 下面可寫刪除元素的動作  
        }
        return [deleteAction, addAction]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;更新畫面的method&#34;&gt;更新畫面的method&lt;/h2&gt;

&lt;p&gt;TableView裡面有三個method可以更新畫面。列表如下
- 刪除：需提供IndexPath的陣列，一次可以刪一串。
- 插入：需提供IndexPath的陣列，一次可以加入一串。
- 重新整理&lt;/p&gt;

&lt;p&gt;程式碼如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;tableView.deleteRows(at: [indexPath], with: .fade)
tableView.insertRows(at: [indexPath], with: .fade)
tableView.reloadData()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;更換位置&#34;&gt;更換位置&lt;/h2&gt;

&lt;h2 id=&#34;下拉更新&#34;&gt;下拉更新&lt;/h2&gt;

&lt;p&gt;常常會看到有APP在tableView下拉時畫面會開始轉圈圈，然後更新，現在試著製作這個效果。
1. 在StoryBoard中點選TableViewController。
2. 將Refreshing設定成enable
3. 此時左方會出現一個Refresh Control，將其拉到程式碼中，選擇Action，動作為value changed。
    - &lt;img src=&#34;http://i.imgur.com/QYt5WVC.png&#34; alt=&#34;設定&#34; /&gt;
4. 接下來就可以對剛剛拉出的action做一些事，做完後使用self.refreshControl?.endRefreshing()，就可以結束轉圈圈的畫面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;  @IBAction func reload(_ sender: AnyObject) {
      // do something
      self.refreshControl?.endRefreshing()
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;搜尋&#34;&gt;搜尋&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let searchController = UISearchController(searchResultsController: nil)
searchController.searchResultsUpdater = self
self.tableView.tableHeaderView = searchController.searchBar
searchController.dimsBackgroundDuringPresentation = false
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;uicollectionview&#34;&gt;UICollectionView&lt;/h1&gt;

&lt;h2 id=&#34;uicollectionviewdelegateflowlayout&#34;&gt;UICollectionViewDelegateFlowLayout&lt;/h2&gt;

&lt;p&gt;可以調整cell的大小&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift Map 地圖功能</title>
      <link>https://cdfq152313.github.io/post/2016-10-21/</link>
      <pubDate>Fri, 21 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-10-21/</guid>
      <description>

&lt;h1 id=&#34;環境設定&#34;&gt;環境設定&lt;/h1&gt;

&lt;h2 id=&#34;權限&#34;&gt;權限&lt;/h2&gt;

&lt;p&gt;開啟地圖本身不需要權限，如果若需要GPS位置，請在info.plist中開啟
&lt;img src=&#34;http://i.imgur.com/sHeMOKN.png&#34; alt=&#34;Alt Text&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;storyboard-iboutlet&#34;&gt;StoryBoard &amp;amp; IBOutlet&lt;/h2&gt;

&lt;p&gt;在StoryBoard上地圖套件名稱叫做&lt;strong&gt;Map Kit View&lt;/strong&gt;
如果想要拉IBOutlet到自己的class中，會發現出現Error，這是因為Map class並不包含在UIKit當中。
所以請import Mapkit&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Mapkit
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;mkmapviewdelegate&#34;&gt;MKMapViewDelegate&lt;/h2&gt;

&lt;p&gt;最後就是記得設定mapView的delegate
如果需要特殊效果的時候非常有用，例如：開始讀取map位置的時候要做什麼，結束讀取位置的時候要做什麼&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;將地址解析為gps&#34;&gt;將地址解析為GPS&lt;/h1&gt;

&lt;p&gt;可以利用CLGeocoder這個class來達成，以下是一個簡單的範例
1. 初始化CLGeocoder
2. 使用geocodeAddressString此方法，傳入兩個參數
    - 需解析之address (字串)
  - 解析完後的動作(closure)，參數如下
    - [CLPlacemark]?: 一個地址有多個可能符合之GPS位置，所以是一個Array。
    - Error?: 若無則為nil
3. 在closure當中，把經緯度印出來
    - 我們可以從CLPlacemark的location屬性當中，找到經度和緯度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;// 初始化
let geoCoder = CLGeocoder()

// 解析字串
geoCoder.geocodeAddressString(address) {
    (places, error) in
  // 如果解析失敗，直接回傳不做任何事
    guard error == nil else {
        print (&amp;quot;Get position error&amp;quot;)
        return
    }
    
  // 印出位置
    if(places?.count)! &amp;gt; 0 {
        let placeMark = places?.first
        print(&amp;quot;Location: \(placeMark?.location)&amp;quot;)
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;標註位置&#34;&gt;標註位置&lt;/h1&gt;

&lt;p&gt;先拿到要標註的GPS位置，再開始進行標註。
1. 初始化MKPointAnnotation
2. 設定title / subtitle / image等等欄位
3. 設定GPS位置
4. 使用方法addAnnotation方法將大頭針插在地圖上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func setAnnotation(placeMark:CLPlacemark){
    // 開始進行標註
    let annotation = MKPointAnnotation()
    annotation.title = &amp;quot;Hello~~&amp;quot;
    annotation.subtitle = &amp;quot;Moto&amp;quot;
    annotation.coordinate = (placeMark.location?.coordinate)!
    self.mapView.addAnnotation(annotation)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;將畫面拉到特定位置&#34;&gt;將畫面拉到特定位置&lt;/h1&gt;

&lt;p&gt;標註畫面只是將大頭針插上位置，地圖並沒有移動。如果想要將地圖zoom in到某個地點附近，就必須使用這個功能。
1. 初始化座標，需要使用到經緯度。
2. 初始化想顯示範圍，MKCoordinateSpanMake的兩個參數分別代表經緯度長度。
3. 用上述兩個參數初始化MKCoordinateRegion
4. 使用setRegion方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func zoomInMap(placeMark:CLPlacemark){
        // set region
    let cl2d = CLLocationCoordinate2D(latitude: (placeMark.location?.coordinate.latitude)!, longitude: (placeMark.location?.coordinate.longitude)!)
        let span = MKCoordinateSpanMake(0.075, 0.075)
        let region = MKCoordinateRegion(center: cl2d, span: span)
        self.mapView.setRegion(region, animated: true)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;以下難產中&#34;&gt;以下難產中&lt;/h1&gt;

&lt;h1 id=&#34;mapkit-位置改變時定位&#34;&gt;MapKit 位置改變時定位&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>.net的RSA加解密與UWP</title>
      <link>https://cdfq152313.github.io/post/2016-10-18/</link>
      <pubDate>Tue, 18 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-10-18/</guid>
      <description>

&lt;h1 id=&#34;前言牢騷&#34;&gt;前言牢騷&lt;/h1&gt;

&lt;p&gt;我是要在uwp下使用加密演算法並傳送到server去，由Server進行解密。於是在google中下關鍵字&amp;rdquo;.net rsa encrypt&amp;rdquo;，所以就找到了最舊也最多人討論的RSACryptoServiceProvider。我使用Visual studio 2015開command line，想在弄到uwp前先行測試，結果發現了許多與伺服器(python)的解密不相容之處，不管是金鑰格式，還是填補方法。等到把這些問題都搞定了，又發現不能在UWP中使用，真是想死的心都有了&amp;hellip;。再次google了&amp;rdquo;uwp encrpyt&amp;rdquo;後找到了CryptographicEngine + AsymmetricKeyAlgorithmProvider這組library，才終於搞定加解密問題。&lt;/p&gt;

&lt;p&gt;這篇文章會大概描述下列兩種加解密方法與金鑰格式。
1. RSACryptoServiceProvider/RSACng
2. CryptographicEngine + AsymmetricKeyAlgorithmProvider&lt;/p&gt;

&lt;h1 id=&#34;net-rsa-api概觀&#34;&gt;.net RSA API概觀&lt;/h1&gt;

&lt;p&gt;在.net中RSA的加解密有三組。分別是
1. &lt;a href=&#34;https://msdn.microsoft.com/zh-tw/library/system.security.cryptography.rsacryptoserviceprovider(v=vs.110).aspx&#34;&gt;RSACryptoServiceProvider&lt;/a&gt;
2. &lt;a href=&#34;https://msdn.microsoft.com/zh-tw/library/system.security.cryptography.rsacng(v=vs.110).aspx&#34;&gt;RSACng&lt;/a&gt;
3. &lt;a href=&#34;https://msdn.microsoft.com/library/windows/apps/br241490&#34;&gt;CryptographicEngine&lt;/a&gt; + &lt;a href=&#34;https://msdn.microsoft.com/library/windows/apps/br241478&#34;&gt;AsymmetricKeyAlgorithmProvider&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以格式來說，1,2是同一組介面實作，有著類似的操作方式，AsymmetricKeyAlgorithmProvider則是另外的class.
以新舊來說，RSACryptoServiceProvider是最舊的，提供的填補格式極少。RSACng是後繼更加完善的class，但是要在.net4.6後才能用，選擇版本時要注意。至於CryptographicEngine，只能在windows app(含uwp)當中使用。&lt;/p&gt;

&lt;h1 id=&#34;rsacryptoserviceprovider與rsacng&#34;&gt;RSACryptoServiceProvider與RSACng&lt;/h1&gt;

&lt;h2 id=&#34;加密&#34;&gt;加密&lt;/h2&gt;

&lt;p&gt;步驟如下
1. 先將字串轉換成Byte (可以用ASCIIEncoding或UTF8Encdoing，記得怎麼轉回來就好)
2. 初始化RSACryptoServiceProvider (可用來加解密，在此只用來加密)
3. 進行加密
4. 對加密結果進行Base64(理由說明如下)
    - RSA對byte進行加密，結果也是byte。
  - 將加密結果直接轉回string，看起來是亂碼，會涵蓋許多無法顯示的字元。
  - 因此如果要進行傳輸，最好以Base64重新編碼過，出來的字串才會全部都是可顯示的文字。
  - &lt;a href=&#34;https://zh.wikipedia.org/wiki/Base64&#34;&gt;Base64介紹&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;static String Encrypt(String _content)
{
    // 先轉成Byte再加密
  Encoding ByteConverter = new ASCIIEncoding();
  var content = ByteConverter.GetBytes(_content);

  // 初始化RSACryptoServiceProvider
  RSACryptoServiceProvider rsa = getRSACrypto();

  // 加密
  var encrypt = rsa.Encrypt(content, false);
  // 轉成base64
  var encryptStr = System.Convert.ToBase64String(encrypt);
  return encryptStr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在步驟2的時候，我使用了自己撰寫的getRSACrypto，透過匯入金鑰來產生實體，在下一小節會說明。
不過從來沒有產生過金鑰的人，可能會需要自己先行產生。程式碼如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;// 指定金鑰長度在2048以上比較安全
RSACryptoServiceProvider rsa = RSACryptoServiceProvider (2048);
String publickey = rsa.ToXmlString(false)
String privatekey = rsa.ToXmlString(true)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再將這兩個key儲存起來即可。&lt;/p&gt;

&lt;h2 id=&#34;匯入金鑰&#34;&gt;匯入金鑰&lt;/h2&gt;

&lt;p&gt;那來看看要如何匯入金鑰，其實只要引用FromXmlString即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;static RSACryptoServiceProvider getRSACrypto()
{
  RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();
  var pubkey = &amp;quot;&amp;lt;RSAKeyValue&amp;gt;&amp;lt;Modulus&amp;gt;w3XOM8su/sXvgAIhwlNhpihgVIjWQUhW9zoocwCNWGI8b4YtU/qfOlX3bsWzqw6IqRF/Ncmkbs6Rr5uiDzhHwt7cz/+vgZ9Hm346OM6K2N70a7Lbzr/LlDDb4Yt/PzBEOHEffCkKnpy31KL6Xkfg2a0OkZiF8dny9PbKQaYbXQUJIhCx9YcZ4JZ5cRGMvpNKpS+Wx2q22GV5akKVZ6jVcIgotAgp+MtMJoSr8av61eX6sOl0JborsuuX8Cao278MGKCkUldU1hUDTJtH6IOQfeeJhWolEUS6KXj0FAReWR76aYXBDQ3xJAQHvB/mjMLSiB4mpfk0JETz9Bh0o9FvXw==&amp;lt;/Modulus&amp;gt;&amp;lt;Exponent&amp;gt;AQAB&amp;lt;/Exponent&amp;gt;&amp;lt;/RSAKeyValue&amp;gt;&amp;quot;;
  rsa.FromXmlString(pubkey);
  return rsa;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;特別將金鑰的地方提出來看看，是一個XML
```xml publickey.xml
&lt;RSAKeyValue&gt;
&lt;Modulus&gt;
w3XOM8su/sXvgAIhwlNhpihgVIjWQUhW9zoocwCNWGI8b4YtU/qfOlX3bsWzqw6IqRF/Ncmkbs6Rr5uiDzhHwt7cz/+vgZ9Hm346OM6K2N70a7Lbzr/LlDDb4Yt/PzBEOHEffCkKnpy31KL6Xkfg2a0OkZiF8dny9PbKQaYbXQUJIhCx9YcZ4JZ5cRGMvpNKpS+Wx2q22GV5akKVZ6jVcIgotAgp+MtMJoSr8av61eX6sOl0JborsuuX8Cao278MGKCkUldU1hUDTJtH6IOQfeeJhWolEUS6KXj0FAReWR76aYXBDQ3xJAQHvB/mjMLSiB4mpfk0JETz9Bh0o9FvXw==
&lt;/Modulus&gt;
&lt;Exponent&gt;AQAB&lt;/Exponent&gt;
&lt;/RSAKeyValue&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
## PEM to XML
上述的金鑰有一個問題，目前大多數的linux server產出的金鑰都是PEM格式，頂多是base64後的PEM格式，根本沒辦法匯入RSACryptoServiceProvider。
幸好網路上有人幫忙解決這個問題[RSA Key Converter
](https://superdry.apphb.com/tools/online-rsa-key-converter)，不過美中不足的是XML to PEM似乎有BUG。以server產key來說，應該還堪用就是。

## RSACng與填補
RSACng的使用方法與RSACryptoServiceProvider幾乎一模一樣，只在加密的時候，可以選擇更多種類的填補。
關於填補的種類可以參閱[RSAEncryptionPadding](https://msdn.microsoft.com/zh-tw/library/system.security.cryptography.rsaencryptionpadding(v=vs.110).aspx)此一class。注意，只有.net4.6以上才支援此class。
RSACryptoServiceProvider的Encrypt只有
- OaepSHA1
- Pkcs1

RASCng除了上述兩種外還有
- OaepSHA256
- OaepSHA384
- OaepSHA512

# CryptographicEngine + AsymmetricKeyAlgorithmProvider
CryptographicEngine和AsymmetricKeyAlgorithmProvider是用在**Windows app(UWP)**上的Library，在**一般的.net中似乎無法使用**。

## 加密
大致流程如下
1. 先將字串轉換成IBuffer，可藉由先轉成Byte，再使用AsBuffer來轉換
2. 初始化CryptographicKey，此key包含指定的加密之演算法與金鑰
3. 利用CryptographicEngine進行加密，需匯入步驟2的key與想加密的內容
4. 對加密結果進行Base64(理由剛剛已經說明過了)

```csharp
public String Encrypt(string _content)
{
  // 將字串轉換成IBuffer
  Encoding ByteConverter = new ASCIIEncoding();
  byte[] contentByte = ByteConverter.GetBytes(_content);
  IBuffer content = contentByte.AsBuffer();

    CryptographicKey key = getCryptographicKey();
  // 加密
  IBuffer encrypt = CryptographicEngine.Encrypt(key, content, null);
  
  // 轉換成Base64
  String encryptStr = CryptographicBuffer.EncodeToBase64String(encrypt);

  return encryptStr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在步驟2的時候，我使用了自己撰寫的getCryptographicKey，透過選擇演算法和匯入金鑰來產生實體，在下一小節會說明。&lt;/p&gt;

&lt;h2 id=&#34;cryptographickey的初始化&#34;&gt;CryptographicKey的初始化&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;使用AsymmetricKeyAlgorithmProvider.OpenAlgorithm選擇加密演算法，返回一個實體

&lt;ul&gt;
&lt;li&gt;演算法種類可以上&lt;a href=&#34;https://msdn.microsoft.com/en-us/library/windows/apps/windows.security.cryptography.core.asymmetricalgorithmnames.aspx&#34;&gt;MSDN&lt;/a&gt;查詢&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用此實體指定金鑰(ImportKeyPair / ImportPublicKey)，會產生一個CryptographicKey實體

&lt;ul&gt;
&lt;li&gt;值得注意的是，這次的金鑰不再是XML格式，而是大部分通用之pem格式&lt;/li&gt;
&lt;li&gt;ImportPublicKey這個method似乎還可以讀取更多的格式，詳請請參閱&lt;a href=&#34;https://msdn.microsoft.com/en-us/library/windows/apps/hh967858.aspx&#34;&gt;MSDN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public Encrypter getCryptographicKey()
{
    String publickey = &amp;quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAw3XOM8su/sXvgAIhwlNhpihgVIjWQUhW9zoocwCNWGI8b4YtU/qfOlX3bsWzqw6IqRF/Ncmkbs6Rr5uiDzhHwt7cz/+vgZ9Hm346OM6K2N70a7Lbzr/LlDDb4Yt/PzBEOHEffCkKnpy31KL6Xkfg2a0OkZiF8dny9PbKQaYbXQUJIhCx9YcZ4JZ5cRGMvpNKpS+Wx2q22GV5akKVZ6jVcIgotAgp+MtMJoSr8av61eX6sOl0JborsuuX8Cao278MGKCkUldU1hUDTJtH6IOQfeeJhWolEUS6KXj0FAReWR76aYXBDQ3xJAQHvB/mjMLSiB4mpfk0JETz9Bh0o9FvXwIDAQAB&amp;quot;;
  AsymmetricKeyAlgorithmProvider asymmAlg = AsymmetricKeyAlgorithmProvider.OpenAlgorithm(AsymmetricAlgorithmNames.RsaPkcs1);
  CryptographicKey key = asymmAlg.ImportPublicKey(CryptographicBuffer.DecodeFromBase64String(publickey), CryptographicPublicKeyBlobType.X509SubjectPublicKeyInfo);
  return key;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;單獨把pulbic key拿出來看，是一個pem格式的金鑰。
```pem publickey
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAw3XOM8su/sXvgAIhwlNhpihgVIjWQUhW9zoocwCNWGI8b4YtU/qfOlX3bsWzqw6IqRF/Ncmkbs6Rr5uiDzhHwt7cz/+vgZ9Hm346OM6K2N70a7Lbzr/LlDDb4Yt/PzBEOHEffCkKnpy31KL6Xkfg2a0OkZiF8dny9PbKQaYbXQUJIhCx9YcZ4JZ5cRGMvpNKpS+Wx2q22GV5akKVZ6jVcIgotAgp+MtMJoSr8av61eX6sOl0JborsuuX8Cao278MGKCkUldU1hUDTJtH6IOQfeeJhWolEUS6KXj0FAReWR76aYXBDQ3xJAQHvB/mjMLSiB4mpfk0JETz9Bh0o9FvXwIDAQAB&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
# 與python共舞
如果安裝pycrypto並使用
```python
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Crypto.Cipher裡似乎有很多不同Module，我目前測試只有PKCS1_v1_5可以和.net的三個library互通。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;RSACryptoServiceProvider：Encrypt時選Pkcs1(或false)&lt;/li&gt;
&lt;li&gt;RSACng：Encrypt時選Pkcs1&lt;/li&gt;
&lt;li&gt;AsymmetricKeyAlgorithmProvider：OpenAlgorithm時選RsaPkcs1&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果有其他種類可以互通請務必留言給我知道XD&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift 多執行緒與檔案下載</title>
      <link>https://cdfq152313.github.io/post/2016-10-14/</link>
      <pubDate>Fri, 14 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-10-14/</guid>
      <description>

&lt;p&gt;Swift的執行緒分為主要和背景。
Main Queue / Concurrent Queue
主執行緒不能執行同步工作，只能執行非同步工作。&lt;/p&gt;

&lt;h1 id=&#34;主執行緒語法&#34;&gt;主執行緒語法&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;let task1 = {
    for i in 1...5{
        print (&amp;quot;Task1: (\i)&amp;quot;)
    }
}

// DispatchQueue.main.sync(execute: task1)
DispatchQueue.main.async(execute: task1)

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;背景執行緒語法&#34;&gt;背景執行緒語法&lt;/h1&gt;

&lt;p&gt;不指定執行緒&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;DispatchQueue.global().sync(execute: task1)
DispatchQueue.global().async(execute: task1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定執行緒&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;DispatchQueue.global(qos: .background).sync(execute:task1)
DispatchQueue.global(qos: .background).async(execute:task1)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;下載方法&#34;&gt;下載方法&lt;/h1&gt;

&lt;h2 id=&#34;nsdata&#34;&gt;NSData&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;利用url生出網址&lt;/li&gt;
&lt;li&gt;利用Data Class下載(以前叫NSData)&lt;/li&gt;
&lt;li&gt;把下載下來的資料指定給想要的檔案&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;記得要使用DispatchQueue.global().async使用此function，否則畫面會被block住。
下載完畢後要更新UI時要使用ispatchQueue.main.async否則畫面不會即時更新。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func download(){
  if let url = URL(string: &amp;quot;http://www.carlosicaza.com/wp-content/uploads/2014/07/Swift-logo.png&amp;quot;){
    do {
      let data = try Data(contentsOf:url)
      let image = UIImage(data:data)
      DispatchQueue.main.async{
        self.myImage.image = image
      }
    }
    catch{
      print(&amp;quot;Cannot download image&amp;quot;)
    }
  }
}

DispatchQueue.global().async {
    self.download()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;session&#34;&gt;Session&lt;/h2&gt;

&lt;p&gt;改利用Session來下載
Session的ataTask本身即是非同步，所以不會擋住UI畫面。
一樣在任務結束要更新UI時要使用main thread來更新。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;利用url生出網址&lt;/li&gt;
&lt;li&gt;利用Session的dataTask

&lt;ul&gt;
&lt;li&gt;指定網址&lt;/li&gt;
&lt;li&gt;指定下載完成後要做的事 (若要更新UI，記得要在Mainthread執行)&lt;/li&gt;
&lt;li&gt;會回傳一個URLSessionDataTask的instance作為此任務的標記&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;將剛剛接收到的instance.resume()才會開始執行任務&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;self.image = nil
let task = session.dataTask(with: url) {
    (data, response, error) in
    if error != nil{
        return
    }
    
    if let loadedData = data{
        let loadedImage = UIImage(data: loadedData)
        DispatchQueue.main.async{
            self.image = loadedImage
            self.loading?.stopAnimating()
        }
    }
    
}
task.resume()
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>