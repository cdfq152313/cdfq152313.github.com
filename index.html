<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.19" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  
  <title>Denny&#39;s Blog</title>
  

  
  <link rel="stylesheet" href="https://cdfq152313.github.io/css/poole.css">
  <link rel="stylesheet" href="https://cdfq152313.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://cdfq152313.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="https://cdfq152313.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Denny&#39;s Blog" />
</head>

<body class="theme-base-0f ">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://cdfq152313.github.io/"><h1>Denny&#39;s Blog</h1></a>
      <p class="lead">
       獸控天地 
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="/">Home</a> </li>
      
        <li><a href="/categories/notes"> 程式筆記 </a></li>
      
        <li><a href="/categories/misc"> 心得雜感 </a></li>
      
        <li><a href="/tags/"> 標籤列表 </a></li>
      
        <li><a href="/about/"> 關於我 </a></li>
      
    </ul>

    <p>&copy; 2017. All rights reserved. </p>
  </div>
</div>


    <div class="content container">
<div class="posts">

      
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2017-03-27/">
        Android Dialog取消動作
      </a>
    </h1>

    <span class="post-date">Mon, Mar 27, 2017</span>

    <p>使用AlertDialog時，當點在Dialog的外圍，Android會讓此Dialog消失，並且什麼動作都不執行。
如果剛好positive和negative的按鈕都是有明確動作的，並不想被取消，可以透過<strong>setCancelable(boolean)</strong>這個函式來強制使用者不得取消。
不過有時會希望使用者可以透過點擊按鈕或點擊Dialog外圍來執行取消動作(非null空動作)，但在AlertDialog的函式庫中是無能為力的，我查了</p>

<ul>
<li>setOnCancelListener</li>
<li>setOnDismissListener</li>
</ul>

<p>這兩個函式都會導致程式異常停止。最後查到應該使用DialogFragment當中的onCancel動作來解決這個問題。
以下範例程式碼</p>

<pre><code class="language-java">public class MyDialogFragment extends DialogFragment {
    private final static String TAG = &quot;MyDialog&quot;;

    @Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {
        AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
        builder.setTitle(&quot;Hello&quot;)
                .setPositiveButton(&quot;YA&quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        Log.i(TAG, &quot;Positive&quot;);
                    }
                })
                .setNegativeButton(&quot;NO&quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        Log.i(TAG, &quot;Negative&quot;);
                    }
                });
        return builder.create();
    }

    @Override
    public void onCancel(DialogInterface dialog) {
        super.onCancel(dialog);
        Log.i(TAG, &quot;OnCancel&quot;);
    }
}
</code></pre>

<p>重點如下
1. 繼承DialogFragment
2. 複寫onCreateDialog方法，並回傳一個Dialog (跟以往AlertDialog的使用方法一樣)
3. 複寫onCancel方法，裡面放上<strong>點擊外框使AlertDialog消失</strong>時要觸發的事件。
    - 注意：如果是點positive Button或negative Button皆不會觸發這個函式。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2017-02-23/">
        Python AES (PyCrypto)
      </a>
    </h1>

    <span class="post-date">Thu, Feb 23, 2017</span>

    

<h1 id="程式碼">程式碼</h1>

<p>為了易於保存，所有金鑰、向量、輸出結果都是以Base64編碼。</p>

<pre><code class="language-python">from Crypto.Cipher import AES
from Crypto import Random
import base64

BS = AES.block_size
pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)
unpad = lambda s : s[0:-ord(s[-1])]

class AES_HELPER(object):
    def __init__(self):
        print 'init'

    def key_generator(self, bits=256):
        random = Random.new()
        key = random.read( bits/8 )
        return base64.b64encode(key)

    def iv_generator(self):
        '''
        AES Initialization Vector is 128 bits(16 bytes).
        '''
        random = Random.new()
        key = random.read( 16 )
        return base64.b64encode(key)

    def encrypt(self, b64key, b64iv, data):
        key = base64.b64decode(b64key)
        iv = base64.b64decode(b64iv)

        cryptor = AES.new(key, AES.MODE_CBC, iv)
        data = pad(data)
        encrypted = cryptor.encrypt(data)
        encrypted = base64.b64encode(encrypted)
        return encrypted

    def decrypt(self, b64key, b64iv, data):
        key = base64.b64decode(b64key)
        iv = base64.b64decode(b64iv)

        cryptor = AES.new(key, AES.MODE_CBC, iv)
        decrypted = base64.b64decode(data)
        decrypted = cryptor.decrypt(decrypted)
        decrypted = unpad( decrypted )
        return decrypted

aes_helper = AES_HELPER()
</code></pre>

<p>使用上也蠻容易的</p>

<pre><code class="language-python">if __name__ == '__main__':
    key = aes_helper.key_generator()
    iv = aes_helper.iv_generator()
    data = &quot;Hello moto. I'm fire. Thank you. I got fired. Thank you. Madadabi meow meow Madadabi meow.&quot;
    encrypted = aes_helper.encrypt(key, iv, data)
    decrypted = aes_helper.decrypt(key, iv, encrypted)
    print ('data: %s' % data )
    print ('encrypted: %s' % encrypted )
    print ('decrypted: %s' % decrypted )
</code></pre>

<h1 id="random的使用">Random的使用</h1>

<p>在使用AES的時候會需要用到兩個隨機生產的東西
1. 金鑰: 可為128 192 256 bits，金鑰長度越長越不容易被破解。
2. 初始化向量: 只有128 bits的形式，為了避免同樣的文章在同一金鑰下會被加密為同樣密文，從而增加被破解風險。</p>

<p>這邊要特別注意的是必須使用pycrypto所提供的Random，而不能用python原生地random，不然亂數會不夠安全。
以下為產生金鑰的程式碼</p>

<pre><code class="language-python">from Crypto import Random
import base64

def key_generator(bits=256):
  random = Random.new()
  key = random.read( bits/8 )
  return base64.b64encode(key)
</code></pre>

<p>使用random.read()來產生隨機的金鑰串，裡面的參數決定了金鑰串的長度，<strong>單位是bytes</strong>。
初始向量也是同樣的作法，只是這次要限制在128 bits(16 bytes)</p>

<h1 id="padding-pkcs5-pkcs7">Padding (PKCS5 / PKCS7)</h1>

<p>這邊要特別注意有所謂的padding問題，在網路上找了一些解決的方法，以下是程式碼。
<a href="http://likang.me/blog/2013/06/05/python-pycrypto-aes-ecb-pkcs-5/">http://likang.me/blog/2013/06/05/python-pycrypto-aes-ecb-pkcs-5/</a>
<a href="https://gist.github.com/crmccreary/5610068">https://gist.github.com/crmccreary/5610068</a></p>

<pre><code class="language-python">BS = 16
pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS) 
unpad = lambda s : s[0:-ord(s[-1])]
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2017-02-22/">
        Java (Android) AES
      </a>
    </h1>

    <span class="post-date">Wed, Feb 22, 2017</span>

    

<h1 id="平台">平台</h1>

<p>Android Studio
- compileSdkVersion 25
- buildToolsVersion &ldquo;25.0.1&rdquo;</p>

<h1 id="全域變數">全域變數</h1>

<pre><code class="language-java">SecretKey secretKey; // 金鑰
AlgorithmParameterSpec mAlgorithmParameterSpec; // 之後要放置初始化向量的參數
</code></pre>

<h1 id="初始化">初始化</h1>

<h2 id="金鑰初始化">金鑰初始化</h2>

<pre><code class="language-java">private void genAESKey() throws Exception {
  KeyGenerator keyGen = KeyGenerator.getInstance(&quot;AES&quot;); // 指定AES演算法
  keyGen.init(256, new SecureRandom()); // 指定256位元，並使用SecureRandom
  secretKey = keyGen.generateKey(); // 產生AES金鑰
}
</code></pre>

<h2 id="初始向量初始化">初始向量初始化</h2>

<p>private void genInitializationVector() throws NoSuchPaddingException, NoSuchAlgorithmException {
  cipher = Cipher.getInstance(&ldquo;AES/CBC/PKCS5Padding&rdquo;); // 指定AES演算法
  byte [] iVAES = new byte[ cipher.getBlockSize() ]; // new AES演算法所需的block size
  SecureRandom random = new SecureRandom();
  random.nextBytes(iVAES); // 填充向量
  mAlgorithmParameterSpec = new IvParameterSpec(iVAES); // 向量初始化
}</p>

<h1 id="將字串加密">將字串加密</h1>

<p>在AES加密完之後，用Base64把結果轉成可讀的字串以便以http傳送。
不做Base64亦可，只是到時候要以byte為單位做傳送。
初始化模式為 ENCRYPT_MODE</p>

<pre><code class="language-java">private String encrypt(String content) throws Exception {
    cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    cipher.init(Cipher.ENCRYPT_MODE, secretKey, mAlgorithmParameterSpec);
    byte [] encrypt = cipher.doFinal(contentB64);
  return Base64.encodeToString(encrypt, Base64.DEFAULT);
}
</code></pre>

<h1 id="將字串解密">將字串解密</h1>

<p>初始化模式為 DECRYPT_MODE</p>

<pre><code class="language-java">private String decrypt(String content) throws Exception{
  cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
  cipher.init(Cipher.DECRYPT_MODE, secretKey, mAlgorithmParameterSpec);
  byte [] temp = Base64.decode(content, Base64.DEFAULT); // 將字串還原為bytes
  byte [] decodeBytes = cipher.doFinal(temp); // 解密
  return new String(decodeBytes); // 編回字串
}
</code></pre>

<h1 id="匯出金鑰">匯出金鑰</h1>

<p>SecretKey使用getEncoded()可以獲得金鑰，為byte形式，若要方便閱讀與傳送可以轉換為Base64
初始化向量本身有getIV()這個method可以使用，一樣為byte形式，可轉換為Base64。</p>

<pre><code class="language-java">private void export(){
  String secretKeyB64 = Base64.encodeToString(secretKey.getEncoded(), Base64.DEFAULT);
  IvParameterSpec iv = (IvParameterSpec) mAlgorithmParameterSpec;
  String vectorB64 = Base64.encodeToString(iv.getIV(), Base64.DEFAULT);

  Log.i(&quot;Secret Key Base64&quot;, secretKeyB64);
  Log.i(&quot;Vector Base64&quot;, vectorB64);
}
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2017-02-08/">
        Android 文章整理
      </a>
    </h1>

    <span class="post-date">Wed, Feb 8, 2017</span>

    

<h1 id="linearlayout">Linearlayout</h1>

<ul>
<li><a href="http://blog.csdn.net/xiaanming/article/details/13630837">Android 对Layout_weight属性完全解析以及使用ListView来实现表格</a></li>
</ul>

<h1 id="fragment">fragment</h1>

<ul>
<li><a href="https://developer.android.com/guide/components/fragments.html?hl=zh-tw">官方API Guide</a></li>
<li><a href="http://blog.csdn.net/xiaanming/article/details/13630837">Android Fragment 真正的完全解析（上）</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/37992017">Android Fragment 真正的完全解析（下）</a></li>
<li><a href="http://stackoverflow.com/questions/32077086/android-onattachcontext-not-called-for-api-23">Fragment Lifecycle中的onAttach</a></li>
</ul>

<h1 id="toolbar">Toolbar</h1>

<ul>
<li><a href="https://developer.android.com/training/appbar/index.html">官方API Guide</a></li>
<li><a href="http://blog.csdn.net/lovexieyuan520/article/details/9974929">Toolbar左上方的返回鈕</a></li>
<li><a href="http://stackoverflow.com/questions/26778701/how-to-add-buttons-like-refresh-and-search-in-toolbar-in-android">加入新的圖示</a></li>
<li><a href="http://wuxiaolong.me/2015/11/10/toolbar/">Toolbar在Activity和Fragment下的使用情況</a></li>
</ul>

<h1 id="recyclerview-和-listview">RecyclerView 和 ListView</h1>

<ul>
<li><a href="http://www.jianshu.com/p/f592f3715ae2">RecyclerView 和 ListView的對比</a></li>
</ul>

<h1 id="ui-ux">UI/UX</h1>

<ul>
<li><a href="https://github.com/wasabeef/awesome-android-ui">List of Android UI/UX Libraries</a></li>
<li><a href="https://github.com/medyo/Fancybuttons">Fancy Button</a></li>
</ul>

<h1 id="testing">Testing</h1>

<ul>
<li><a href="http://chriszou.com/2016/04/16/android-unit-testing-about-why.html">Android单元测试（二）：再来谈谈为什么</a></li>
<li><a href="http://chriszou.com/2016/04/29/android-unit-testing-mockito.html">Android单元测试（四）：Mock以及Mockito的使用</a></li>
<li><a href="http://chriszou.com/2016/08/06/android-unit-testing-async.html">安卓单元测试(十一)：异步代码怎么测试</a></li>
</ul>

<h1 id="library整合">Library整合</h1>

<ul>
<li><a href="https://guides.codepath.com/android/Must-Have-Libraries">整合1</a></li>
</ul>

<h1 id="parcelable-vs-serializable">Parcelable vs Serializable</h1>

<ul>
<li><a href="http://www.cnblogs.com/trinea/archive/2012/11/09/2763213.html">Android Parcelable和Serializable的區別</a></li>
</ul>

<h1 id="權限管理">權限管理</h1>

<ul>
<li><a href="https://litotom.com/2016/05/15/android-6-permission/">Android綠豆湯 - Android 6.0的Permission權限設計</a></li>
</ul>

<h1 id="檔案處理">檔案處理</h1>

<ul>
<li><a href="https://developer.android.com/training/basics/data-storage/files.html?hl=zh-tw">Android developer - 儲存檔案</a></li>
</ul>

<h1 id="心得">心得</h1>

<ul>
<li><a href="https://github.com/futurice/android-best-practices">Best practice</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/misc/2017-01-15/">
        寫給朋友看的function與class
      </a>
    </h1>

    <span class="post-date">Sun, Jan 15, 2017</span>

    

<h1 id="今天有個簡易的app功能如下">今天有個簡易的app功能如下</h1>

<ol>
<li>只有一個ViewController</li>
<li>這個ViewController上只有兩個UITextView</li>
<li>Input: &ldquo;01/15&rdquo; 代表1月15日</li>
<li>想要結果: 在第一個UITextView上呈現 &ldquo;1 月&rdquo;，在第二個UITextView上呈現&rdquo;15日&rdquo;</li>
</ol>

<p>這時候可能會寫一個function在Controller裡頭，叫做split，input為字串，output為陣列。
input為&rdquo;01/15&rdquo;的話，會出現output [&ldquo;01&rdquo;, &ldquo;15&rdquo;]
然後call一下這個function，分別把兩個UITextView給賦值陣列0和陣列1，就可以運作得很完美了。</p>

<h1 id="接下來追加規格">接下來追加規格</h1>

<ol>
<li>多了兩三個ViewController，同樣需要展示日期。</li>
</ol>

<p>這時候笨方法是把剛剛的function複製到四個不同的ViewController，然後再一一呼叫。
聰明一點的方法是放到全域變數，這樣不用重寫function，但是每一個Controller都能呼叫。</p>

<h1 id="再度追加規格">再度追加規格</h1>

<ol>
<li>除了顯示月日的function，我還想要展示年分。</li>
</ol>

<p>這次可能會依樣畫葫蘆，寫個叫做splityearmonthday的function，放在全域變數裡面，讓所有Controller都能使用。</p>

<h1 id="再再度追加規格">再再度追加規格</h1>

<ol>
<li>這個APP多了付款功能所以需要展示金額。</li>
<li>這個展示金額靠著另外兩個UITextView，第一個UITextView展現整數，第二個UITextView展現小數。</li>
<li>假設input &ldquo;23.7&rdquo;，那會在第一個UITextView出現23 第二個UITextView出現.7</li>
</ol>

<p>於是又寫了一個splitmoney的funcion，放在全域變數裡。</p>

<h1 id="反思">反思</h1>

<p>到了這裡可以開始反思這是不是一個良好的設計了，起初APP的功能的確很簡單，但是隨著需求的擴張，分割日期的function就出現了兩種。後期更出現了分割金額的function。我們假設需求繼續擴張下去，接下來有</p>

<ol>
<li>10個分割日期的function</li>
<li>5個分割金額的function</li>
<li>8個分割OOXX的function</li>
</ol>

<p>你光看全域變數上的function頭就要昏了，而且還得注意名稱不得重複，每個名稱都取的又臭又長，即使這都是一些小小的function，依然會對開發人員帶來負擔。</p>

<p>此時，如果你用class將分割日期、分割金額、分割OOXX的職責區分開來，程式碼或許會變得清晰? 舉例來說
func splityearmonthday()
func splitmonthday()
改為
=&gt;
class DateSplit{
    func yearmonth()
    func monthday()
}</p>

<h1 id="總結">總結</h1>

<p>簡單總結：
class的作用在於區分職責，不同功能的function盡可能的放在不同的class，這是為了可讀性。
程式規模小的時候，可以不必花太多心力把每個功能都丟一個class，但是當程式開始漸漸擴張，就要開始思考，我這些function之間是否有類似的職責，能夠被包成一個class來執行?
再來就是，其實並不是每件事情都可以靠function的input output就解決，有時候你可能會想記錄狀態。
舉例來說，如果你寫了一個計算機的程式，那你會希望計算機記得你上次按了什麼按鈕，這時候如果你再使用全域變數和全域function來解決問題，等老闆要求你&rdquo;我今天要兩個計算機，不要一個&rdquo;，的時候就尷尬了，因為你的狀態是靠全域變數來記，兩個計算機參考到同一個全域變數，就G_G惹。
希望有幫助到你。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-12-27/">
        Python Mac Sierra pyinstaller py2app 的權限問題
      </a>
    </h1>

    <span class="post-date">Tue, Dec 27, 2016</span>

    <p>最近遇到一個問題，使用pyinstaller製作執行檔後，在本機運作上ok，但是一傳給別人使用就會出問題。
可是用右鍵show packages裡面的Content/MacOS/執行檔，是可以正常使用的。
這讓我非常困惑，後來才發現是Sierra權限設定更改。</p>

<p>英文好的可以直接看下面就解決了：
<a href="http://lapcatsoftware.com/articles/app-translocation.html">http://lapcatsoftware.com/articles/app-translocation.html</a></p>

<p>英文不好的簡單翻譯就是：
解壓縮zip後的任何app檔，在執行期的時候會自動放入App Translocation這個唯讀資料夾運行。
因為是唯讀資料夾，所以不能寫入，我的程式就是因為有寫入功能才失敗。
解決方法是拖拉這個app到任意其他位置(ex:桌面)，OSX就不會再幫你把這個app放進唯讀資料夾執行。</p>

<p>還記得幾乎所有的MAC app都需要拖拉到應用程式裡面才能使用嗎? MAC應該就是希望你對想使用的APP進行過此一確認才加上這個功能。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/misc/2016-12-27/">
        [讀書心得] 圖解密碼學與比特幣原理
      </a>
    </h1>

    <span class="post-date">Tue, Dec 27, 2016</span>

    <p><a href="https://www.tenlong.com.tw/items/9864761935?item_id=1025404">圖解密碼學與比特幣原理</a></p>

<p>花了很久才斷斷續續的看完這本，覺得是一本很不錯的科普書，沒有太艱深的數學。</p>

<p>書中有系統的把目前密碼學的發展介紹了一遍，非常著重在oo密碼技術可以解決xx難題，或是oo技術無法解決xx難題。以及oo技術中的yy演算法目前無人破解，或是oo技術的yy演算法已經被破解。</p>

<p>書中最後也提到了不少混合型密碼系統在現今世界上的應用，讓這本書不會只流於技術介紹的紙上談兵。對我這個密碼學大外行幫助很大，好書，極推。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-12-01/">
        Java RSA
      </a>
    </h1>

    <span class="post-date">Thu, Dec 1, 2016</span>

    

<h1 id="讀金鑰">讀金鑰</h1>

<p>感謝大大無私分享，大大一生平安
<a href="http://stackoverflow.com/questions/11410770/load-rsa-public-key-from-file">http://stackoverflow.com/questions/11410770/load-rsa-public-key-from-file</a></p>

<h1 id="加密">加密</h1>

<p>感謝大大無私分享，大大一生平安
<a href="http://jimwayne.blogspot.tw/2012/06/java_25.html">http://jimwayne.blogspot.tw/2012/06/java_25.html</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-11-24/">
        基礎知識惡補 - Http協定
      </a>
    </h1>

    <span class="post-date">Thu, Nov 24, 2016</span>

    

<p>來源網址：<a href="https://read01.com/J8P4L.html">https://read01.com/J8P4L.html</a>
要注意最後一段說get比較不安全是錯的，你他媽的不轉成https通通都是不安全。</p>

<h1 id="client端">Client端</h1>

<p>分三區塊
- Request line
- Request header
- Body</p>

<h2 id="request-line">Request line</h2>

<ul>
<li>有著方法描述，資源位置，協議版本</li>
<li>例如：GET <a href="http://www.cnblogs.com/">http://www.cnblogs.com/</a> HTTP/1.1</li>
</ul>

<h2 id="request-header">Request header</h2>

<ul>
<li>Accept：client告知server可以接受的媒體類型(json, xml, html &hellip;)，大部分使用*/*代表全部都接受。</li>
<li>Referer：告訴伺服器端我是從哪裡連過來</li>
<li>Accept-Language：瀏覽器端接受的語言

<ul>
<li>EX: 中文、英文&hellip;</li>
</ul></li>
<li>Accept-Charset：瀏覽器端接受的字符集

<ul>
<li>EX: BIG5, UTF-8, GBK &hellip;</li>
</ul></li>
<li>Content-Type

<ul>
<li>Body的檔案類型</li>
<li><a href="http://webmasters.stackexchange.com/questions/31212/difference-between-the-accept-and-content-type-http-headers">補充資料</a>，與Accept的差別</li>
<li>簡單的說，當client傳送檔案給server，content-type可以描述這個檔案的類型。當server吐response回給client，content-type一樣可以描述這個檔案的類型。</li>
<li>accept是請求對方返回的類型，content-type是實際一個request或response中夾帶的類型。</li>
</ul></li>
<li>Accept-Encoding：client端的編碼(壓縮)方法</li>
<li>User-Agent：client端的作業系統，瀏覽器名稱</li>
<li>Connection

<ul>
<li>是否在接收完檔案後立刻斷開TCP</li>
<li>[補充資料])(<a href="https://www.byvoid.com/zht/blog/http-keep-alive-header">https://www.byvoid.com/zht/blog/http-keep-alive-header</a>)</li>
</ul></li>
<li>Content-length: 訊息長度</li>
<li>Host：該資源的domain Name</li>
<li>剩下一些懶得看

<ul>
<li>Pragma</li>
<li>Cookie</li>
</ul></li>
</ul>

<h2 id="body">Body</h2>

<p>就是個Body</p>

<h1 id="server端">Server端</h1>

<p>一樣分三區塊
- Response line
- Response header
- Body</p>

<h2 id="response-line">Response line</h2>

<ul>
<li>協議版本及狀態碼</li>
<li>例如：HTTP/1.1 200 OK</li>
</ul>

<h2 id="response-header">Response header</h2>

<p>有些部分跟request一樣，少部分懶得看。</p>

<p>Content-Type：回傳資料的型態
Expired：回傳資料過期時間
- 懶得看
    - Cache-Control
  - Last-Modified:
    - Server
    - X-AspNet-Version:
    - X-Powered-By:
    - Connection
    - Content-Length
    - Date</p>

<h2 id="body-1">Body</h2>

<p>就只是個Body</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-11-02/">
        Swift Mail &amp; Message
      </a>
    </h1>

    <span class="post-date">Wed, Nov 2, 2016</span>

    

<h1 id="mail">Mail</h1>

<p>不能在模擬器上跑，會crash。</p>

<h2 id="簡單流程">簡單流程</h2>

<ol>
<li>初始化MFMailComposeViewController</li>
<li>設定標題以及收件者</li>
<li>推出MFMailComposeViewController</li>
</ol>

<pre><code class="language-swift">import MessageUI

func sendMail(){
  let mailController = MFMailComposeViewController()
  mailController.setSubject(&quot;swift程式設計入門&quot;)
  mailController.setToRecipients([&quot;cdfq152313@gmail.com&quot;])
  self.present(mailController, animated: true, completion: nil)
}
</code></pre>

<h2 id="測試能不能使用mail功能">測試能不能使用Mail功能</h2>

<p>像是在模擬器上就不能使用。</p>

<pre><code class="language-swift">if MFMailComposeViewController.canSendMail(){
    // 可以寄信
}
else{
    // 不能寄信
}
</code></pre>

<h2 id="mailcomposedelegate">mailComposeDelegate</h2>

<p>設定mailComposeDelegate可以讓寄信完後，dismiss到原來畫面，這邊要注意的是不要設成一般delegate了。</p>

<pre><code class="language-swift">mailController.mailComposeDelegate = self

func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) {
        dismiss(animated: true, completion: nil)
}

</code></pre>

<p>如果想知道寄信後的狀態可參考第二個參數didFinishWith result。按住command + 滑鼠左鍵在MFMailCompseResult可以知道有下列狀態。</p>

<pre><code class="language-swift">public enum MFMailComposeResult : Int {
    case cancelled
    case saved
    case sent
    case failed
}
</code></pre>

<h2 id="夾帶圖片">夾帶圖片</h2>

<pre><code class="language-swift">// 夾一張圖片
func mailCo
var image = UIImage(named: &quot;book1&quot;)
var data = UIImageJPEGRepresentation(image!, 0.9)
mailController.addAttachmentData(data!, mimeType:&quot;image/jpg&quot;, fileName: &quot;book1.jpg&quot;)

// 可以夾不只一個圖片
image = UIImage(named: &quot;book2&quot;)
data = UIImageJPEGRepresentation(image!, 0.9)
mailController.addAttachmentData(data!, mimeType: &quot;image/jpg&quot;, fileName: &quot;book2.jpg&quot;)
</code></pre>

<h2 id="放置html檔">放置HTML檔</h2>

<pre><code class="language-swift">let body = &quot;&lt;h1&gt;HelloWorld&lt;/h1&gt;&quot;
mailController.setMessageBody(body, isHTML:true)
</code></pre>

<h1 id="message">Message</h1>

<p>同樣不能在模擬器上跑，會crash。</p>

<h2 id="簡單流程-1">簡單流程</h2>

<p>由於是訊息，只要填body即可。
收件者可以是
- 人名
- 手機號碼
- 郵件信箱</p>

<pre><code class="language-swift">func sendMessage(){
  let controller = MFMessageComposeViewController()
  controller.body = &quot;hello&quot;
  controller.recipients = [&quot;Denny&quot;, &quot;0978948787&quot;, &quot;cdfq152313@gmail.com&quot;]
  self.present(controller, animated: true, completion: nil)
}
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-10-25/">
        Swift TableView 與 Collection View
      </a>
    </h1>

    <span class="post-date">Tue, Oct 25, 2016</span>

    

<h1 id="tableview">TableView</h1>

<h2 id="indexpath-section-row">IndexPath: Section &amp; Row</h2>

<p><img src="http://i.imgur.com/razNcl9.png" alt="Section and Row" />
看圖應該可以明瞭Section和Row的含意，Apple把tableView劃分為section，每個section下又有row。
在IOS中有一個叫做IndexPath的類別專門儲存這兩個值，在tableView以後要override的方法會經常看到。</p>

<h2 id="必定要override的method-幾個section-幾個row">必定要override的method: 幾個section 幾個row</h2>

<p>使用tableView必須指定DataSource和Delegate (若是TableViewController則已經指定好自己作為這兩個protocol的實作)</p>

<p>其中有些function是必定要override的
1. 總共有幾個section
2. 每個section裡面有幾個row</p>

<p>在這個範例中，我指定兩個section，section 0有2 row，section 1有3 row。</p>

<pre><code class="language-swift">// 總共幾個section
override func numberOfSections(in tableView: UITableView) -&gt; Int {
  return 2
}

// 每個section裡面有幾個row
override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
    if section == 0{
    return 2
  }
  else{
    return 3
    }
}
</code></pre>

<h2 id="某一列的內容">某一列的內容</h2>

<p>但是只有這樣，顯示出來會是空白一片，所以必須要回傳顯示的內容。
在做這個項目之前，必須先到storyBoard，將tableView裏頭的cell指定一個identifier，否則會錯誤。
在此我指定cell的identifier為myCell
<img src="http://i.imgur.com/0mgnfd6.png" alt="Identifier" /></p>

<p>然後才可以在程式碼中使用myCell</p>

<pre><code class="language-swift">override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {
  let cell = tableView.dequeueReusableCell(withIdentifier: &quot;myCell&quot;, for: indexPath)

  // 顯示目前是第幾Row
  cell.textLabel?.text = &quot;Row &quot; + String(indexPath.row)
  return cell
}
</code></pre>

<p><img src="http://i.imgur.com/MFz1Rhv.png" alt="目前畫面" /></p>

<h2 id="section-title">Section Title</h2>

<p>但是這樣少了每個section的title，沒有段落感，所以用以下的code加上。</p>

<pre><code class="language-swift">override func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? {
  if section == 0{
    return &quot;Section 0&quot;
  }
  else{
    return &quot;Section 1&quot;
  }
}
</code></pre>

<p><img src="http://i.imgur.com/razNcl9.png" alt="目前畫面" /></p>

<h2 id="點擊某列跳轉到下一個controller-並傳值">點擊某列跳轉到下一個Controller，並傳值</h2>

<p><a href="http://dennycheng-blog.logdown.com/posts/946492-controller-interaction">請參閱之前的傳值方法</a>，我們選用方法一。這邊要補充的是：可以藉由tableview中的indexPathForselectedRow屬性來得知哪一列被選中。</p>

<ol>
<li>在prepare裡裡面進行傳值的預備動作。</li>
<li>轉型Controller，這樣才可以塞property

<ul>
<li>在此我們假設SecondViewController中有selectedIndexPath這個屬性。</li>
</ul></li>
<li>可以藉由tableView中的indexPathForselectedRow來判定哪個Row被選中。</li>
</ol>

<pre><code class="language-swift">override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
  if let indexPath = tableView.indexPathForSelectedRow{
    let controller = segue.destination as! SecondViewController
    controller.selectedIndexPath = indexPath
  }
}
</code></pre>

<h2 id="滑動刪除">滑動刪除</h2>

<p>只要複寫方法即可，記得必須同時刪除實際的Array以及畫面上的元件，否則會造成畫面與實際資料不同步的問題。</p>

<pre><code class="language-swift">override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) {
  if editingStyle == .delete {
    // 刪除元素
    myArray.remove(at: indexPath.row)
    // 刪除畫面上的元素
    tableView.deleteRows(at: [indexPath], with: .fade)
  } 
}
</code></pre>

<p>但使用這個方法，只能滑出一個按鈕。如果想滑動時有多個按鈕可以選擇請看下節。</p>

<h2 id="自訂滑動選項">自訂滑動選項</h2>

<p>如果想要自訂滑動按鈕的文字樣式，或是想指定多個滑動按鈕，那就不能使用上述的複寫方法。而必須改用下面這個。
1. 複寫方法
2. 自訂UITableViewRowAction
3. 回傳UITableViewRowAction陣列
因為此方法回傳陣列，所以可以塞進多個按鈕。</p>

<pre><code class="language-swift">override func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&gt; [UITableViewRowAction]? {
        let addAction = UITableViewRowAction(style: .normal, title: &quot;insert&quot;) { 
            (action, indexPath) in
          // 下面可寫插入元素的動作  
        }
        
        let deleteAction = UITableViewRowAction(style: .default, title: &quot;delete&quot;) { 
            (action, indexPath) in
          // 下面可寫刪除元素的動作  
        }
        return [deleteAction, addAction]
    }
</code></pre>

<h2 id="更新畫面的method">更新畫面的method</h2>

<p>TableView裡面有三個method可以更新畫面。列表如下
- 刪除：需提供IndexPath的陣列，一次可以刪一串。
- 插入：需提供IndexPath的陣列，一次可以加入一串。
- 重新整理</p>

<p>程式碼如下</p>

<pre><code class="language-swift">tableView.deleteRows(at: [indexPath], with: .fade)
tableView.insertRows(at: [indexPath], with: .fade)
tableView.reloadData()
</code></pre>

<h2 id="更換位置">更換位置</h2>

<h2 id="下拉更新">下拉更新</h2>

<p>常常會看到有APP在tableView下拉時畫面會開始轉圈圈，然後更新，現在試著製作這個效果。
1. 在StoryBoard中點選TableViewController。
2. 將Refreshing設定成enable
3. 此時左方會出現一個Refresh Control，將其拉到程式碼中，選擇Action，動作為value changed。
    - <img src="http://i.imgur.com/QYt5WVC.png" alt="設定" />
4. 接下來就可以對剛剛拉出的action做一些事，做完後使用self.refreshControl?.endRefreshing()，就可以結束轉圈圈的畫面。</p>

<pre><code class="language-swift">  @IBAction func reload(_ sender: AnyObject) {
      // do something
      self.refreshControl?.endRefreshing()
  }
</code></pre>

<h2 id="搜尋">搜尋</h2>

<pre><code class="language-swift">let searchController = UISearchController(searchResultsController: nil)
searchController.searchResultsUpdater = self
self.tableView.tableHeaderView = searchController.searchBar
searchController.dimsBackgroundDuringPresentation = false
</code></pre>

<h1 id="uicollectionview">UICollectionView</h1>

<h2 id="uicollectionviewdelegateflowlayout">UICollectionViewDelegateFlowLayout</h2>

<p>可以調整cell的大小</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-10-21/">
        Swift Map 地圖功能
      </a>
    </h1>

    <span class="post-date">Fri, Oct 21, 2016</span>

    

<h1 id="環境設定">環境設定</h1>

<h2 id="權限">權限</h2>

<p>開啟地圖本身不需要權限，如果若需要GPS位置，請在info.plist中開啟
<img src="http://i.imgur.com/sHeMOKN.png" alt="Alt Text" /></p>

<h2 id="storyboard-iboutlet">StoryBoard &amp; IBOutlet</h2>

<p>在StoryBoard上地圖套件名稱叫做<strong>Map Kit View</strong>
如果想要拉IBOutlet到自己的class中，會發現出現Error，這是因為Map class並不包含在UIKit當中。
所以請import Mapkit</p>

<pre><code class="language-swift">import Mapkit
</code></pre>

<h2 id="mkmapviewdelegate">MKMapViewDelegate</h2>

<p>最後就是記得設定mapView的delegate
如果需要特殊效果的時候非常有用，例如：開始讀取map位置的時候要做什麼，結束讀取位置的時候要做什麼&hellip;</p>

<h1 id="將地址解析為gps">將地址解析為GPS</h1>

<p>可以利用CLGeocoder這個class來達成，以下是一個簡單的範例
1. 初始化CLGeocoder
2. 使用geocodeAddressString此方法，傳入兩個參數
    - 需解析之address (字串)
  - 解析完後的動作(closure)，參數如下
    - [CLPlacemark]?: 一個地址有多個可能符合之GPS位置，所以是一個Array。
    - Error?: 若無則為nil
3. 在closure當中，把經緯度印出來
    - 我們可以從CLPlacemark的location屬性當中，找到經度和緯度。</p>

<pre><code class="language-swift">// 初始化
let geoCoder = CLGeocoder()

// 解析字串
geoCoder.geocodeAddressString(address) {
    (places, error) in
  // 如果解析失敗，直接回傳不做任何事
    guard error == nil else {
        print (&quot;Get position error&quot;)
        return
    }
    
  // 印出位置
    if(places?.count)! &gt; 0 {
        let placeMark = places?.first
        print(&quot;Location: \(placeMark?.location)&quot;)
    }

}
</code></pre>

<h1 id="標註位置">標註位置</h1>

<p>先拿到要標註的GPS位置，再開始進行標註。
1. 初始化MKPointAnnotation
2. 設定title / subtitle / image等等欄位
3. 設定GPS位置
4. 使用方法addAnnotation方法將大頭針插在地圖上</p>

<pre><code class="language-swift">func setAnnotation(placeMark:CLPlacemark){
    // 開始進行標註
    let annotation = MKPointAnnotation()
    annotation.title = &quot;Hello~~&quot;
    annotation.subtitle = &quot;Moto&quot;
    annotation.coordinate = (placeMark.location?.coordinate)!
    self.mapView.addAnnotation(annotation)
}
</code></pre>

<h1 id="將畫面拉到特定位置">將畫面拉到特定位置</h1>

<p>標註畫面只是將大頭針插上位置，地圖並沒有移動。如果想要將地圖zoom in到某個地點附近，就必須使用這個功能。
1. 初始化座標，需要使用到經緯度。
2. 初始化想顯示範圍，MKCoordinateSpanMake的兩個參數分別代表經緯度長度。
3. 用上述兩個參數初始化MKCoordinateRegion
4. 使用setRegion方法</p>

<pre><code class="language-swift">func zoomInMap(placeMark:CLPlacemark){
        // set region
    let cl2d = CLLocationCoordinate2D(latitude: (placeMark.location?.coordinate.latitude)!, longitude: (placeMark.location?.coordinate.longitude)!)
        let span = MKCoordinateSpanMake(0.075, 0.075)
        let region = MKCoordinateRegion(center: cl2d, span: span)
        self.mapView.setRegion(region, animated: true)
}
</code></pre>

<h1 id="以下難產中">以下難產中</h1>

<h1 id="mapkit-位置改變時定位">MapKit 位置改變時定位</h1>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-10-18/">
        .net的RSA加解密與UWP
      </a>
    </h1>

    <span class="post-date">Tue, Oct 18, 2016</span>

    

<h1 id="前言牢騷">前言牢騷</h1>

<p>我是要在uwp下使用加密演算法並傳送到server去，由Server進行解密。於是在google中下關鍵字&rdquo;.net rsa encrypt&rdquo;，所以就找到了最舊也最多人討論的RSACryptoServiceProvider。我使用Visual studio 2015開command line，想在弄到uwp前先行測試，結果發現了許多與伺服器(python)的解密不相容之處，不管是金鑰格式，還是填補方法。等到把這些問題都搞定了，又發現不能在UWP中使用，真是想死的心都有了&hellip;。再次google了&rdquo;uwp encrpyt&rdquo;後找到了CryptographicEngine + AsymmetricKeyAlgorithmProvider這組library，才終於搞定加解密問題。</p>

<p>這篇文章會大概描述下列兩種加解密方法與金鑰格式。
1. RSACryptoServiceProvider/RSACng
2. CryptographicEngine + AsymmetricKeyAlgorithmProvider</p>

<h1 id="net-rsa-api概觀">.net RSA API概觀</h1>

<p>在.net中RSA的加解密有三組。分別是
1. <a href="https://msdn.microsoft.com/zh-tw/library/system.security.cryptography.rsacryptoserviceprovider(v=vs.110).aspx">RSACryptoServiceProvider</a>
2. <a href="https://msdn.microsoft.com/zh-tw/library/system.security.cryptography.rsacng(v=vs.110).aspx">RSACng</a>
3. <a href="https://msdn.microsoft.com/library/windows/apps/br241490">CryptographicEngine</a> + <a href="https://msdn.microsoft.com/library/windows/apps/br241478">AsymmetricKeyAlgorithmProvider</a></p>

<p>以格式來說，1,2是同一組介面實作，有著類似的操作方式，AsymmetricKeyAlgorithmProvider則是另外的class.
以新舊來說，RSACryptoServiceProvider是最舊的，提供的填補格式極少。RSACng是後繼更加完善的class，但是要在.net4.6後才能用，選擇版本時要注意。至於CryptographicEngine，只能在windows app(含uwp)當中使用。</p>

<h1 id="rsacryptoserviceprovider與rsacng">RSACryptoServiceProvider與RSACng</h1>

<h2 id="加密">加密</h2>

<p>步驟如下
1. 先將字串轉換成Byte (可以用ASCIIEncoding或UTF8Encdoing，記得怎麼轉回來就好)
2. 初始化RSACryptoServiceProvider (可用來加解密，在此只用來加密)
3. 進行加密
4. 對加密結果進行Base64(理由說明如下)
    - RSA對byte進行加密，結果也是byte。
  - 將加密結果直接轉回string，看起來是亂碼，會涵蓋許多無法顯示的字元。
  - 因此如果要進行傳輸，最好以Base64重新編碼過，出來的字串才會全部都是可顯示的文字。
  - <a href="https://zh.wikipedia.org/wiki/Base64">Base64介紹</a></p>

<pre><code class="language-csharp">static String Encrypt(String _content)
{
    // 先轉成Byte再加密
  Encoding ByteConverter = new ASCIIEncoding();
  var content = ByteConverter.GetBytes(_content);

  // 初始化RSACryptoServiceProvider
  RSACryptoServiceProvider rsa = getRSACrypto();

  // 加密
  var encrypt = rsa.Encrypt(content, false);
  // 轉成base64
  var encryptStr = System.Convert.ToBase64String(encrypt);
  return encryptStr;
}
</code></pre>

<p>在步驟2的時候，我使用了自己撰寫的getRSACrypto，透過匯入金鑰來產生實體，在下一小節會說明。
不過從來沒有產生過金鑰的人，可能會需要自己先行產生。程式碼如下。</p>

<pre><code class="language-csharp">// 指定金鑰長度在2048以上比較安全
RSACryptoServiceProvider rsa = RSACryptoServiceProvider (2048);
String publickey = rsa.ToXmlString(false)
String privatekey = rsa.ToXmlString(true)
</code></pre>

<p>再將這兩個key儲存起來即可。</p>

<h2 id="匯入金鑰">匯入金鑰</h2>

<p>那來看看要如何匯入金鑰，其實只要引用FromXmlString即可。</p>

<pre><code class="language-csharp">static RSACryptoServiceProvider getRSACrypto()
{
  RSACryptoServiceProvider rsa = new RSACryptoServiceProvider();
  var pubkey = &quot;&lt;RSAKeyValue&gt;&lt;Modulus&gt;w3XOM8su/sXvgAIhwlNhpihgVIjWQUhW9zoocwCNWGI8b4YtU/qfOlX3bsWzqw6IqRF/Ncmkbs6Rr5uiDzhHwt7cz/+vgZ9Hm346OM6K2N70a7Lbzr/LlDDb4Yt/PzBEOHEffCkKnpy31KL6Xkfg2a0OkZiF8dny9PbKQaYbXQUJIhCx9YcZ4JZ5cRGMvpNKpS+Wx2q22GV5akKVZ6jVcIgotAgp+MtMJoSr8av61eX6sOl0JborsuuX8Cao278MGKCkUldU1hUDTJtH6IOQfeeJhWolEUS6KXj0FAReWR76aYXBDQ3xJAQHvB/mjMLSiB4mpfk0JETz9Bh0o9FvXw==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;&quot;;
  rsa.FromXmlString(pubkey);
  return rsa;
}
</code></pre>

<p>特別將金鑰的地方提出來看看，是一個XML
```xml publickey.xml
<RSAKeyValue>
<Modulus>
w3XOM8su/sXvgAIhwlNhpihgVIjWQUhW9zoocwCNWGI8b4YtU/qfOlX3bsWzqw6IqRF/Ncmkbs6Rr5uiDzhHwt7cz/+vgZ9Hm346OM6K2N70a7Lbzr/LlDDb4Yt/PzBEOHEffCkKnpy31KL6Xkfg2a0OkZiF8dny9PbKQaYbXQUJIhCx9YcZ4JZ5cRGMvpNKpS+Wx2q22GV5akKVZ6jVcIgotAgp+MtMJoSr8av61eX6sOl0JborsuuX8Cao278MGKCkUldU1hUDTJtH6IOQfeeJhWolEUS6KXj0FAReWR76aYXBDQ3xJAQHvB/mjMLSiB4mpfk0JETz9Bh0o9FvXw==
</Modulus>
<Exponent>AQAB</Exponent>
</RSAKeyValue></p>

<pre><code>
## PEM to XML
上述的金鑰有一個問題，目前大多數的linux server產出的金鑰都是PEM格式，頂多是base64後的PEM格式，根本沒辦法匯入RSACryptoServiceProvider。
幸好網路上有人幫忙解決這個問題[RSA Key Converter
](https://superdry.apphb.com/tools/online-rsa-key-converter)，不過美中不足的是XML to PEM似乎有BUG。以server產key來說，應該還堪用就是。

## RSACng與填補
RSACng的使用方法與RSACryptoServiceProvider幾乎一模一樣，只在加密的時候，可以選擇更多種類的填補。
關於填補的種類可以參閱[RSAEncryptionPadding](https://msdn.microsoft.com/zh-tw/library/system.security.cryptography.rsaencryptionpadding(v=vs.110).aspx)此一class。注意，只有.net4.6以上才支援此class。
RSACryptoServiceProvider的Encrypt只有
- OaepSHA1
- Pkcs1

RASCng除了上述兩種外還有
- OaepSHA256
- OaepSHA384
- OaepSHA512

# CryptographicEngine + AsymmetricKeyAlgorithmProvider
CryptographicEngine和AsymmetricKeyAlgorithmProvider是用在**Windows app(UWP)**上的Library，在**一般的.net中似乎無法使用**。

## 加密
大致流程如下
1. 先將字串轉換成IBuffer，可藉由先轉成Byte，再使用AsBuffer來轉換
2. 初始化CryptographicKey，此key包含指定的加密之演算法與金鑰
3. 利用CryptographicEngine進行加密，需匯入步驟2的key與想加密的內容
4. 對加密結果進行Base64(理由剛剛已經說明過了)

```csharp
public String Encrypt(string _content)
{
  // 將字串轉換成IBuffer
  Encoding ByteConverter = new ASCIIEncoding();
  byte[] contentByte = ByteConverter.GetBytes(_content);
  IBuffer content = contentByte.AsBuffer();

    CryptographicKey key = getCryptographicKey();
  // 加密
  IBuffer encrypt = CryptographicEngine.Encrypt(key, content, null);
  
  // 轉換成Base64
  String encryptStr = CryptographicBuffer.EncodeToBase64String(encrypt);

  return encryptStr;
}
</code></pre>

<p>在步驟2的時候，我使用了自己撰寫的getCryptographicKey，透過選擇演算法和匯入金鑰來產生實體，在下一小節會說明。</p>

<h2 id="cryptographickey的初始化">CryptographicKey的初始化</h2>

<ol>
<li>使用AsymmetricKeyAlgorithmProvider.OpenAlgorithm選擇加密演算法，返回一個實體

<ul>
<li>演算法種類可以上<a href="https://msdn.microsoft.com/en-us/library/windows/apps/windows.security.cryptography.core.asymmetricalgorithmnames.aspx">MSDN</a>查詢</li>
</ul></li>
<li>使用此實體指定金鑰(ImportKeyPair / ImportPublicKey)，會產生一個CryptographicKey實體

<ul>
<li>值得注意的是，這次的金鑰不再是XML格式，而是大部分通用之pem格式</li>
<li>ImportPublicKey這個method似乎還可以讀取更多的格式，詳請請參閱<a href="https://msdn.microsoft.com/en-us/library/windows/apps/hh967858.aspx">MSDN</a></li>
</ul></li>
</ol>

<pre><code class="language-csharp">public Encrypter getCryptographicKey()
{
    String publickey = &quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAw3XOM8su/sXvgAIhwlNhpihgVIjWQUhW9zoocwCNWGI8b4YtU/qfOlX3bsWzqw6IqRF/Ncmkbs6Rr5uiDzhHwt7cz/+vgZ9Hm346OM6K2N70a7Lbzr/LlDDb4Yt/PzBEOHEffCkKnpy31KL6Xkfg2a0OkZiF8dny9PbKQaYbXQUJIhCx9YcZ4JZ5cRGMvpNKpS+Wx2q22GV5akKVZ6jVcIgotAgp+MtMJoSr8av61eX6sOl0JborsuuX8Cao278MGKCkUldU1hUDTJtH6IOQfeeJhWolEUS6KXj0FAReWR76aYXBDQ3xJAQHvB/mjMLSiB4mpfk0JETz9Bh0o9FvXwIDAQAB&quot;;
  AsymmetricKeyAlgorithmProvider asymmAlg = AsymmetricKeyAlgorithmProvider.OpenAlgorithm(AsymmetricAlgorithmNames.RsaPkcs1);
  CryptographicKey key = asymmAlg.ImportPublicKey(CryptographicBuffer.DecodeFromBase64String(publickey), CryptographicPublicKeyBlobType.X509SubjectPublicKeyInfo);
  return key;
}
</code></pre>

<p>單獨把pulbic key拿出來看，是一個pem格式的金鑰。
```pem publickey
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAw3XOM8su/sXvgAIhwlNhpihgVIjWQUhW9zoocwCNWGI8b4YtU/qfOlX3bsWzqw6IqRF/Ncmkbs6Rr5uiDzhHwt7cz/+vgZ9Hm346OM6K2N70a7Lbzr/LlDDb4Yt/PzBEOHEffCkKnpy31KL6Xkfg2a0OkZiF8dny9PbKQaYbXQUJIhCx9YcZ4JZ5cRGMvpNKpS+Wx2q22GV5akKVZ6jVcIgotAgp+MtMJoSr8av61eX6sOl0JborsuuX8Cao278MGKCkUldU1hUDTJtH6IOQfeeJhWolEUS6KXj0FAReWR76aYXBDQ3xJAQHvB/mjMLSiB4mpfk0JETz9Bh0o9FvXwIDAQAB</p>

<pre><code>
# 與python共舞
如果安裝pycrypto並使用
```python
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5
</code></pre>

<p>Crypto.Cipher裡似乎有很多不同Module，我目前測試只有PKCS1_v1_5可以和.net的三個library互通。</p>

<ol>
<li>RSACryptoServiceProvider：Encrypt時選Pkcs1(或false)</li>
<li>RSACng：Encrypt時選Pkcs1</li>
<li>AsymmetricKeyAlgorithmProvider：OpenAlgorithm時選RsaPkcs1</li>
</ol>

<p>如果有其他種類可以互通請務必留言給我知道XD</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-10-14/">
        Swift 多執行緒與檔案下載
      </a>
    </h1>

    <span class="post-date">Fri, Oct 14, 2016</span>

    

<p>Swift的執行緒分為主要和背景。
Main Queue / Concurrent Queue
主執行緒不能執行同步工作，只能執行非同步工作。</p>

<h1 id="主執行緒語法">主執行緒語法</h1>

<pre><code class="language-swift">let task1 = {
    for i in 1...5{
        print (&quot;Task1: (\i)&quot;)
    }
}

// DispatchQueue.main.sync(execute: task1)
DispatchQueue.main.async(execute: task1)

</code></pre>

<h1 id="背景執行緒語法">背景執行緒語法</h1>

<p>不指定執行緒</p>

<pre><code class="language-swift">DispatchQueue.global().sync(execute: task1)
DispatchQueue.global().async(execute: task1)
</code></pre>

<p>指定執行緒</p>

<pre><code class="language-swift">DispatchQueue.global(qos: .background).sync(execute:task1)
DispatchQueue.global(qos: .background).async(execute:task1)
</code></pre>

<h1 id="下載方法">下載方法</h1>

<h2 id="nsdata">NSData</h2>

<ol>
<li>利用url生出網址</li>
<li>利用Data Class下載(以前叫NSData)</li>
<li>把下載下來的資料指定給想要的檔案</li>
</ol>

<p>記得要使用DispatchQueue.global().async使用此function，否則畫面會被block住。
下載完畢後要更新UI時要使用ispatchQueue.main.async否則畫面不會即時更新。</p>

<pre><code class="language-swift">func download(){
  if let url = URL(string: &quot;http://www.carlosicaza.com/wp-content/uploads/2014/07/Swift-logo.png&quot;){
    do {
      let data = try Data(contentsOf:url)
      let image = UIImage(data:data)
      DispatchQueue.main.async{
        self.myImage.image = image
      }
    }
    catch{
      print(&quot;Cannot download image&quot;)
    }
  }
}

DispatchQueue.global().async {
    self.download()
}
</code></pre>

<h2 id="session">Session</h2>

<p>改利用Session來下載
Session的ataTask本身即是非同步，所以不會擋住UI畫面。
一樣在任務結束要更新UI時要使用main thread來更新。</p>

<ol>
<li>利用url生出網址</li>
<li>利用Session的dataTask

<ul>
<li>指定網址</li>
<li>指定下載完成後要做的事 (若要更新UI，記得要在Mainthread執行)</li>
<li>會回傳一個URLSessionDataTask的instance作為此任務的標記</li>
</ul></li>
<li>將剛剛接收到的instance.resume()才會開始執行任務</li>
</ol>

<pre><code class="language-swift">self.image = nil
let task = session.dataTask(with: url) {
    (data, response, error) in
    if error != nil{
        return
    }
    
    if let loadedData = data{
        let loadedImage = UIImage(data: loadedData)
        DispatchQueue.main.async{
            self.image = loadedImage
            self.loading?.stopAnimating()
        }
    }
    
}
task.resume()
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-10-11/">
        Swift 檔案路徑與讀寫檔
      </a>
    </h1>

    <span class="post-date">Tue, Oct 11, 2016</span>

    

<h1 id="ios的路徑">iOS的路徑</h1>

<h2 id="專案資料夾內的路徑">專案資料夾內的路徑</h2>

<p>利用Bundle.main獲取
可以指定檔案名稱以及副檔名。</p>

<pre><code class="language-swift">// 得到url
let url = Bundle.main.url(forResource: &quot;myjson&quot;, withExtension: &quot;json&quot;)
// 得到path
let path = Bundle.main.path(forResource: &quot;myjson&quot;, ofType: &quot;json&quot;)
</code></pre>

<h2 id="一般app路徑">一般App路徑</h2>

<p>Document範例</p>

<pre><code class="language-swift">// 透過路徑尋找URL
let path = NSHomeDirectory() + &quot;/Document&quot;
let urlfrompath = URL(fileURLWithPath: path)

// 直接拿取URL，陣列第0個是資料夾本身(雖然也只有一個url)
let url = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
</code></pre>

<p>Caches 範例</p>

<pre><code class="language-swift">// 透過路徑尋找URL
let path = NSHomeDirectory() + &quot;/Library/Caches&quot;
let urlfrompath = URL(fileURLWithPath: path)

// 直接拿取URL
let url = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask)[0]
</code></pre>

<p>Temp 範例</p>

<pre><code class="language-swift">// 兩種路徑取得的方法
let pathFromNSHome = NSHomeDirectory() + &quot;/tmp&quot;
let pathFromLibrary = NSTemporaryDirectory()

// URL
let urlfrompath = URL(fileURLWithPath: pathFromNSHome)
</code></pre>

<h2 id="新增路徑">新增路徑</h2>

<ol>
<li>將想要新增的路徑名稱寫出來</li>
<li>利用FileManager.default.createDirectory新增路徑

<ul>
<li>此方法的withIntermediateDirctories參數若設成true，可以幫你遞迴建立不存在的資料夾
<br /></li>
</ul></li>
</ol>

<pre><code class="language-swift">let directoryPath = NSTemporaryDirectory() + &quot;/images&quot;
do{
    try FileManager.default.createDirectory(atPath: directoryPath, withIntermediateDirectories: true, attributes: nil)
}catch{
    print(&quot;Cannot create directory&quot;)
}
</code></pre>

<h2 id="列出某個路徑下的所有檔案">列出某個路徑下的所有檔案</h2>

<ol>
<li>先找到想列出檔案的路徑</li>
<li>利用 FileManager.default.contentsOfDirectory來列出此資料夾底下的檔案</li>
</ol>

<pre><code class="language-swift">let tempPath = NSTemporaryDirectory()
do{
  let fileList = try FileManager.default.contentsOfDirectory(atPath: tempPath)
  for file in fileList{
    print(file)
  }
}
catch{
    print(&quot;Cannot list directory&quot;)
}
</code></pre>

<h2 id="查看路徑資訊">查看路徑資訊</h2>

<p>FileManager.default.fileExists 可以幫你查看這個檔案是否存在，以及該檔案是否為一個Directory。
需要特別注意的是OBJCBool的使用</p>

<pre><code class="language-swift">let path = NSTemporaryDirectory() + &quot;/images&quot;
var isDirectory:ObjCBool = false
let isExist = FileManager.default.fileExists(atPath: path, isDirectory: &amp;isDirectory)
if isExist == true &amp;&amp; isDirectory.boolValue == true{
    print(&quot;File exist and it is a direcotry&quot;)
}
else if isExist == true &amp;&amp; isDirectory.boolValue == false{
    print(&quot;File exist but it is not a direcotry&quot;)
}
else{
    print(&quot;File isn't exist&quot;)
}
</code></pre>

<h2 id="複製貼上刪除檔案">複製貼上刪除檔案</h2>

<p>使用下方函式，記得加上do try catch。</p>

<pre><code class="language-swift">FileManager.default.copyItem(atPath: path, toPath: cpPath)
FileManager.default.moveItem(atPath: path, toPath: mvPath)
FileManager.default.removeItem(atPath: path)
</code></pre>

<h1 id="一般型別寫檔讀檔">一般型別寫檔讀檔</h1>

<h2 id="讀寫string">讀寫String</h2>

<p>寫檔要呼叫String的方法</p>

<pre><code class="language-swift">let text = &quot;Hello World&quot;
let filePath = NSTemporaryDirectory() + &quot;Text.txt&quot;
do{
    try text.write(toFile: filePath, atomically: true, encoding: .utf8)
}catch{
    print(&quot;Not save correctly&quot;)
}
</code></pre>

<p>讀檔要使用NSString</p>

<pre><code class="language-swift">let filePath = NSTemporaryDirectory() + &quot;Text.txt&quot;
do{
  let loading = try NSString(contentsOfFile: filePath, encoding: String.Encoding.utf8.rawValue)
  print(loading)
}catch{
    print(&quot;No save file&quot;)
}
</code></pre>

<h2 id="讀寫array">讀寫Array</h2>

<p>利用NSArray做寫入</p>

<pre><code class="language-swift">let originalArray = [&quot;Apple&quot;, &quot;Banana&quot;, &quot;MAngo&quot;]
let arrayToSave = NSArray(array: originalArray)
let filePath = NSTemporaryDirectory() + &quot;saveArray.txt&quot;
arrayToSave.write(toFile: filePath, atomically: true)
</code></pre>

<p>利用NSArray做讀出</p>

<pre><code class="language-swift">let filePath = NSTemporaryDirectory() + &quot;saveArray.txt&quot;
if let loadArray = NSArray(contentsOfFile: filePath) as? [String]{
    print(loadArray)
}
</code></pre>

<h2 id="讀寫dict">讀寫Dict</h2>

<p>寫入靠NSDictionary</p>

<pre><code class="language-swift">let originalDict = [&quot;1&quot;:&quot;apple&quot;, &quot;2&quot;:&quot;banana&quot;, &quot;3&quot;:&quot;orange&quot;]
let dictToSave = NSDictionary(dictionary: originalDict)
let filePath = NSTemporaryDirectory() + &quot;saveDict.txt&quot;
dictToSave.write(toFile: filePath, atomically: true)
</code></pre>

<p>讀取靠NSDictionary</p>

<pre><code class="language-swift">let filePath = NSTemporaryDirectory() + &quot;saveDict.txt&quot;
  if let loadDict = NSDictionary(contentsOfFile: filePath) as? [String:String]{
  print(loadDict)
}
</code></pre>

<h1 id="多媒體寫檔讀檔">多媒體寫檔讀檔</h1>

<h2 id="圖檔">圖檔</h2>

<p>存檔
多媒體的寫檔只能依靠URL而不能靠檔案路徑。</p>

<ol>
<li>先拿到要儲存的UIImage (可靠照相機或手機已有的圖片)</li>
<li>以指定格式載入圖片 (UIImagePNGRepresentation或UIImageJPGRepresentation)</li>
<li>產生路徑及URL</li>
<li>在指定URL下存檔</li>
</ol>

<pre><code class="language-swift">// 拿到UIImage
guard let image = UIImage(named: &quot;Tails&quot;) else {
  print (&quot;Cannot find image&quot;)
  return
}

if let dataToSave = UIImagePNGRepresentation(image){
    // 產生路徑
  let filePath = NSTemporaryDirectory() + &quot;savedImage.png&quot;
  let fileURL = URL(fileURLWithPath: filePath)
  // 寫入
  do{
    try dataToSave.write(to: fileURL)
  }catch{
    print(&quot;Can not save Image&quot;)
  }
}
</code></pre>

<p>讀檔
1. 先用UIImage載入
2. 把載入圖片放在UIImageView上面</p>

<pre><code class="language-swift">let filePath = NSTemporaryDirectory() + &quot;savedImage.png&quot;
let image = UIImage(contentsOfFile: filePath)
myImageView.image = image
</code></pre>

<h1 id="自定義class讀寫檔">自定義class讀寫檔</h1>

<p>要寫檔的class必須繼承
- NSObject
- NSCoding</p>

<p>並複寫相關function</p>

<pre><code class="language-swift">class Item : NSObject, NSCoding{
    var name:String?
    var detail:String?
    
    init(name:String, detail:String) {
        self.name = name
        self.detail = detail
    }
    
    required init?(coder aDecoder: NSCoder) {       
        name = aDecoder.decodeObject(forKey: &quot;name&quot;) as! String
        detail = aDecoder.decodeObject(forKey: &quot;detail&quot;) as! String
    }
    
    func encode(with aCoder: NSCoder) {
        aCoder.encode(name, forKey: &quot;name&quot;)
        aCoder.encode(detail, forKey: &quot;detail&quot;)
    }
}
</code></pre>

<p>可以來試著測試了
寫檔
1. 產生物件
2. 利用NSKeyedArchiver.archivedData包裹物件，產生data
3. 找到寫檔路徑
4. 將data寫入指定路徑</p>

<pre><code class="language-swift">let item = Item(name: &quot;危城&quot;, detail: &quot;動作&quot;)
let data = NSKeyedArchiver.archivedData(withRootObject: item)
let docUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
let url = docUrl.appendingPathComponent(&quot;myfile.txt&quot;)
try! data.write(to: url)
</code></pre>

<p>讀檔
1. 找到讀檔路徑
2. 獲取Data
3. 利用NSKeyedUnarchiver.unarchiveObject，將data轉換成指定物件</p>

<pre><code class="language-swift">let docUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
let url = docUrl.appendingPathComponent(&quot;myfile.txt&quot;)
let data = try? Data(contentsOf: url)

if let data = data {
    let item = NSKeyedUnarchiver.unarchiveObject(with: data) as! Item
    print(&quot;=== Read ===&quot;)
    print(item.name)
    print(item.detail)
}
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-10-06/">
        Swift 聲音播放與錄製
      </a>
    </h1>

    <span class="post-date">Thu, Oct 6, 2016</span>

    

<h1 id="播放系統音效">播放系統音效</h1>

<p>超簡單只需要兩行</p>

<pre><code class="language-swift">import AudioToolbox
AudioServicesPlaySystemSound(1000)
</code></pre>

<h1 id="播放自己放在app的音樂">播放自己放在app的音樂</h1>

<p>先把自己的音效拖進Xcode，記得選擇&rdquo;copy items if needed&rdquo;，否則只會放入reference。
可以開一個新的Group(資料夾圖示)來專門放置音檔。</p>

<h2 id="步驟">步驟</h2>

<ol>
<li>找到檔案在哪(用Bundle)</li>
<li>產生URL</li>
<li>產生AVAudioPlayer</li>
</ol>

<pre><code class="language-swift">// AVAudioPlayer初始化
func myPlayerInit()-&gt;AVAudioPlayer?{
    guard let path = Bundle.main.path(forResource: &quot;Right&quot;, ofType:&quot;mp3&quot;) else{
        return nil
    }

  let audioURL = URL(fileURLWithPath: path)
  do{
    return try AVAudioPlayer(contentsOf: audioURL)
  }
  catch{
    print(&quot;AVAudio Player Init failed&quot;)
    return nil
  }
}
</code></pre>

<pre><code class="language-swift">// 利用button播放 每次按下都將聲音時間歸零
let myPlayer = myPlayerInit()
myPlayer?.play()
</code></pre>

<h2 id="其他好用的方法">其他好用的方法</h2>

<pre><code class="language-swift">myPlayer?.stop() // 停止
myPlayer?.currentTime = 0 // 把音檔時間歸零
myPlayer?.numberOfLoops = 2 // 重複播放次數，若為負數則為無限次播放
myPlayer?.volume = 0.5 // 調整音量

// 把播放速度調慢或調快
myPlayer?.enableRate = true
myPlayer?.rate = 0.5
</code></pre>

<h1 id="播放手機內部的音樂">播放手機內部的音樂</h1>

<p>利用MPMediaPickerController，此一Controller會讓你選擇音樂。我們只需要指定選完音樂(或沒選到)要做什麼動作即可。</p>

<h2 id="步驟-1">步驟</h2>

<ol>
<li>在Xcode調整權限

<ul>
<li>在info.plist裡面新增 &ldquo;Privacy - Media Library Ussage Description&rdquo;</li>
<li>在右方新增你的理由</li>
</ul></li>
<li>新增MPMediaPickerController</li>
<li>實作MPMediaPickerController之delegate (MPMediaPickerControllerDelegate)

<ul>
<li>取消不動作</li>
<li>選取到音樂則播放</li>
</ul></li>
<li>指定2實作的delegate給1</li>
</ol>

<h3 id="權限設定">權限設定</h3>

<p><img src="http://i.imgur.com/m9279lW.png" alt="存取影音檔案權限" /></p>

<h3 id="mpmediapickercontrollerdelegate的實作">MPMediaPickerControllerDelegate的實作</h3>

<pre><code class="language-swift">// 取消不動作直接消除視窗
func mediaPickerDidCancel(_ mediaPicker: MPMediaPickerController) {
    dismiss(animated: true, completion: nil)
}

// 選取到音樂則播放
func mediaPicker(_ mediaPicker: MPMediaPickerController, didPickMediaItems mediaItemCollection: MPMediaItemCollection) {
  let musicPlayer = MPMusicPlayerController.applicationMusicPlayer()
  musicPlayer.setQueue(with:mediaItemCollection)
  musicPlayer.play()
  dismiss(animated:true, completion: nil)
}
</code></pre>

<p>若要停止MPmusicPlayerController一樣可以使用.stop函數</p>

<h1 id="錄音">錄音</h1>

<ol>
<li>在info.plist增加麥克風權限</li>
<li>選好放置路徑並產生URL</li>
<li>設定錄音數據(dict)</li>
<li>產生AVAudioRecorder實體</li>
<li>指定AVAudioRecorder的delegate

<ul>
<li>指定錄完音後執行的動作</li>
</ul></li>
<li>開始錄音</li>
</ol>

<h2 id="權限設定-1">權限設定</h2>

<p><img src="http://i.imgur.com/WwJpAMB.png" alt="麥克風權限" /></p>

<h2 id="步驟2-3-4-5">步驟2 3 4 5</h2>

<pre><code class="language-swift">func audioRecorderInit()-&gt;AVAudioRecorder?{
    // 步驟2 設定路徑
  let path = NSHomeDirectory() + &quot;/Documents/user.wav&quot;
  let url = URL(fileURLWithPath: path)
  // 步驟3 設定錄音數據(dict)
  let recordSettings:[String:Any] = [
    AVEncoderAudioQualityKey : AVAudioQuality.min.rawValue,
    AVEncoderBitRateKey: 16,
    AVNumberOfChannelsKey: 2,
    AVSampleRateKey: 44100.0
  ]
  do {
    // 步驟4 5 產生實體並指定delegate
    let audioRecorder = try AVAudioRecorder(url: url, settings:recordSettings)
    audioRecorder.delegate = self
    return audioRecorder
  }
  catch{
    print(&quot;something is worng&quot;)
    return nil
  }
}
</code></pre>

<h2 id="avaudiorecorderdelegate的實作">AVAudioRecorderDelegate的實作</h2>

<p>參數recorder的屬性url可以拿到錄製好的檔案路徑</p>

<pre><code class="language-swift">func audioRecorderDidFinishRecording(_ recorder: AVAudioRecorder, successfully flag: Bool) {
  if flag == true{
    do {
        try audioPlayer = AVAudioPlayer(contentsOf: recorder.url)
    }
    catch{
        print(&quot;something is Wrong...&quot;)
    }
  }
}
</code></pre>

<h2 id="開始錄音">開始錄音</h2>

<p>將AVAudioSession調成AVAudioSessionCatetoryPlayAndRecord，可有效增大錄音音量。若不調整則會很小聲。</p>

<pre><code class="language-swift">do {
    try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayAndRecord)
}
catch{
    print(&quot;can't set audio session&quot;)
}
audioRecorder?.prepareToRecord()
audioRecorder?.record()
</code></pre>

<h2 id="停止錄音">停止錄音</h2>

<p>記得把剛剛的AVAudioSession.sharedInstance()調回原樣</p>

<pre><code class="language-swift">self.audioRecorder?.stop()
do{
    try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryPlayback)
    try AVAudioSession.sharedInstance().setActive(false)
}
catch{
    print(&quot;can't set audio session&quot;)
}
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-10-04/">
        Swift 基礎語法筆記
      </a>
    </h1>

    <span class="post-date">Tue, Oct 4, 2016</span>

    

<h1 id="參考資料">參考資料</h1>

<p>感謝大大～～
<a href="https://itisjoe.gitbooks.io/swiftgo/content/">https://itisjoe.gitbooks.io/swiftgo/content/</a>
因應swift3，筆記內容與gitbook上略有不同</p>

<h1 id="struct和enum是value-type-class是reference-type">struct和enum是value type, class是reference type</h1>

<ul>
<li>struct宣告為常數，就無法更改內部的值，但class可以。</li>
<li>struct和enum這種value type，內部member function不能修改member data的值</li>
<li>如果真的要修改要加上mutating修飾字</li>
</ul>

<pre><code class="language-swift">struct Apple{
    var x = 0.0
    mutating func add(num:Double){
        x += num
    }
}

var x = Apple(x:1.2)
x.add(1.5)
print(x.x)
</code></pre>

<ul>
<li>mutating 還可以替換掉本身的實體結構</li>
</ul>

<pre><code class="language-swift">struct Apple{
    var x = 0.0
    mutating func new(num:Double){
        x = Apple()
    }
}
</code></pre>

<h1 id="function注意事項">function注意事項</h1>

<p>call function時，參數後要指定參數名稱，不可以省略</p>

<pre><code class="language-swift">func plus(a :Int, b:Int){
  print(a+b)
}
plus(a:1, b:3)
</code></pre>

<p>如果要省略要加上底線</p>

<pre><code class="language-swift">func plus(_ a :Int,_ b:Int){
  print(a+b)
}
plus(1, 3)
</code></pre>

<h2 id="外部參數名稱-external-parameter-name">外部參數名稱(External parameter Name)</h2>

<p>事實上a前面的底線是External parameter Name的意思。External parameter Name用於外部呼叫Function時的參數識別名，若不寫則與內部名稱相同。
而底線代表不在意參數識別名稱，即為可忽略的意思。</p>

<pre><code class="language-swift">func plus(AAA a :Int,BBB b:Int){
  print(a+b)
}
plus(AAA:1, BBB:3)
</code></pre>

<h1 id="型別方法">型別方法</h1>

<p>在class中要宣告class方法(非object方法)，可以用關鍵字<strong>class</strong>或<strong>static</strong></p>

<pre><code class="language-swift">class SomeClass {
    // 定義一個型別方法
    class func someTypeMethod() {
        print(&quot;型別方法&quot;)
    }
}
</code></pre>

<h1 id="closure">Closure</h1>

<h2 id="函式也是一種型別">函式也是一種型別</h2>

<p>型別名稱為
(參數型別)-&gt;回傳型別</p>

<h2 id="化function為clousure">化function為Clousure</h2>

<ol>
<li>刪掉func與函式名</li>
<li>將大括號移到最外側</li>
<li>在參數後面加上in</li>
</ol>

<p>before</p>

<pre><code class="language-swift">func add(x:Int, y:Int)-&gt;Int{
    return x + y
}
</code></pre>

<p>after</p>

<pre><code class="language-swift">{
    (x:Int, y:Int)-&gt;Int in
  return x + y
}
</code></pre>

<h2 id="closure簡寫">Closure簡寫</h2>

<ol>
<li><p>如果已經知道參數跟回傳值的型別的話，可以省略Clousure裡的參數與回傳值型別</p>

<pre><code class="language-swift">let numberArray=[1,3,6,8,10,45]
  numberArray.map( {(number) in return number+10} ) // 省略型別
</code></pre></li>

<li><p>如果Closure有回傳值，而且程式碼是一行的話，可以省略return，</p>

<pre><code class="language-swift">let numberArray=[1,3,6,8,10,45]
  numberArray.map( {(number) in number+10} ) // 回傳number+10
</code></pre></li>

<li><p>可以用$0, $1 &hellip; 代表參數。</p>

<pre><code class="language-swift">let numberArray=[1,3,6,8,10,45]
  numberArray.map( {$0 + 10} ) // 省略參數，利用$0代表參數
</code></pre></li>

<li><p>如果Closure是最後一個參數的話，可以把clousure寫在小括號的外面。</p>

<pre><code class="language-swift">  let numberArray=[1,3,6,8,10,45]
  numberArray.map(){$0 + 10} // 寫在小括號的外面
</code></pre></li>

<li><p>如果Closure是唯一的參數的話，可以省略小括號</p>

<pre><code class="language-swift">let numberArray=[1,3,6,8,10,45]
  numberArray.map{$0 + 10} // 直接省掉小括號
</code></pre></li>
</ol>

<h1 id="guard的用途">guard的用途</h1>

<p>guard比if能更好的實行Defensive Programming，因為在guard中的可選綁定可以在接下來code中使用。</p>

<pre><code class="language-swift">var text:String? = &quot;abc&quot;
if let apple = text{
    print(apple)
}
// 在這邊用會失敗
// print(apple)
</code></pre>

<pre><code class="language-swift">var text:String? = &quot;abc&quot;
guard let apple = text else{
    print(apple)
}
// 照用
print(apple)
</code></pre>

<h1 id="error">Error</h1>

<p>Swift丟出的異常是一種enum，實作時繼承Error。
有幾種方法
1. 最基本的do try catch
2. 向上拋擲function填throw
3. try? : 如果出現錯誤則回傳nil(不用再寫do catch)，可搭配optinal binding
4. try! : 一定成功。(若沒成功會crash)</p>

<h1 id="init">init</h1>

<h2 id="init-1">init?</h2>

<p>init?代表可以回傳nil，也就是可能init失敗。
參看下面的code</p>

<pre><code class="language-swift">class Baby{
    var age:Int
    init?(age:Int){
    if age &lt; 0{
        return nil
    }
    self.age = age
  }
}
</code></pre>

<p>一個寶寶生出來小於一歲是不合理的，所以init失敗回傳nil</p>

<h2 id="init的順序">init的順序</h2>

<ul>
<li>原則1：屬性的初始,必須在當初宣告屬性的類別裡進⾏。</li>
<li>原則2：⼦類別得先完成⾃⼰屬性的初始後，才能進⾏⽗類別屬性的初始。

<ul>
<li>此原則是為了防止繼承的class複寫基礎class的方法，而基礎的class使用此方法來初始化。</li>
<li>若此function剛好動用到繼承class之porperty，那就會出現問題。</li>
</ul></li>
</ul>

<p>假設有一個基礎型別寶寶</p>

<pre><code class="language-swift">class Baby{
    var age:Int
    init(age:Int){
        self.age = age
    }
}
</code></pre>

<p>正確的範例</p>

<pre><code class="language-swift">class SuperBaby: Baby{
    var magic:Int
    init(age:Int, magic:Int){
        self.magic = magic
        super.init(age: age)
    }
}
</code></pre>

<p>錯誤的範例: 違反原則1，age屬性的初始化不在宣告的類別裡。</p>

<pre><code class="language-swift">class SuperBaby: Baby{
    var magic:Int
    init(age:Int, magic:Int){
        self.magic = magic
        self.age = age
        super.init(age: age)
    }
}
</code></pre>

<p>錯誤的範例: 違反原則2，必須先將自己的屬性先初始化完畢，才能call super init</p>

<pre><code class="language-swift">class SuperBaby: Baby{
    var magic:Int
    init(age:Int, magic:Int){
            super.init(age: age)
        self.magic = magic
    }
}
</code></pre>

<p>正確的範例: 在age初始化後才改變age的值</p>

<pre><code class="language-swift">class SuperBaby: Baby{
    var magic:Int
    init(age:Int, magic:Int){
        self.magic = magic
        super.init(age: age)
        self.age = age
    }
}
</code></pre>

<h2 id="convenience-init">convenience init</h2>

<p>有兩種類型的init
- designated initializer : 一般的init
- convenience initializer : 加了關鍵字convenience的init</p>

<p>擁有convenience關鍵字的init才可以call其他init function，來減少重複工作，非常<strong>方便</strong>。
舉例來說：</p>

<pre><code class="language-swift">class Baby{
    var age:Int
    var name:String
    init(age:Int, name:String){
        self.age = age
        self.name = name
    }
    
    convenience init(name:String){
            self.init(age:1, name:name)
    }
}
</code></pre>

<h2 id="init的繼承">init的繼承</h2>

<ul>
<li>designated initializer的繼承

<ul>
<li>子類別沒有定義任何designated initializer，預設全部自動繼承。</li>
<li>子類別定義了任意init，不會自動繼承父類別的init。</li>
</ul></li>
<li>convenience initializer的繼承

<ul>
<li>子類別沒有定義任何designated initializer，預設全部自動繼承。</li>
<li>子類別覆寫了父類別所有的designated initializer，則自動繼承所有convenience initializer。</li>
<li>子類別複寫不完全，則不會繼承convenience initializer。</li>
</ul></li>
</ul>

<pre><code class="language-swift">
</code></pre>

<pre><code class="language-swift">
</code></pre>

<h2 id="使用required防止init失傳">使用required防止init失傳</h2>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-10-03/">
        Swift 不同Controller互動 與 Navigation Bar
      </a>
    </h1>

    <span class="post-date">Mon, Oct 3, 2016</span>

    

<h1 id="controller之間的呼叫">Controller之間的呼叫</h1>

<h2 id="present-與-dismiss">present 與 dismiss</h2>

<p>想要跳轉頁面，我們可以靠storyBoard拉出present的線，也可以靠程式碼。
在StoryBoard中只要按住ctrl，將button拉到另一個controller後再選present即可。
在程式碼的話</p>

<pre><code class="language-swift">// 因為此ViewController什麼都沒設定，所以會是一片黑
present(ViewController(), animated: true, completion: nil)
</code></pre>

<p>有跳過去，就有返回，想返回時使用dismiss function。</p>

<pre><code class="language-swift">dismiss(animated: true, completion: nil)
</code></pre>

<p>dismiss的原理是，直接呼叫時，請求presentingViewController把你關掉。
間接呼叫時，把後面的presentedViewController們關掉。
至於這兩個是什麼意思請參看下節。</p>

<h2 id="presentingviewcontroller-與-presentedviewcontroller">presentingViewController 與 presentedViewController</h2>

<p>每個controller皆有兩個重要的屬性，可以分辨這個controller是被誰present，或是present了誰。
- presentingViewController：present Controller的Controller
- presentedViewController：被present的Controller</p>

<p>假設ABC皆為Controller，A present B，B present C，那對於B來說。
- A為B之presentingViewController
- C為B之presentedViewController</p>

<h1 id="navigation-bar">Navigation bar</h1>

<h2 id="push-與-pop">push 與 pop</h2>

<p>與present / dismiss相似，進到navigation controller後要使用 navigation屬性的push/pop方法，不然會跳出navigation controller的頁，失去Navigation Bar的效果。</p>

<p>程式碼的形式如下</p>

<pre><code class="language-swift">// 推上下一個頁面
self.navigationController?.pushViewController(ViewController(), animated: true)
// 回到上一頁
self.navigationController?.popViewController(animated: true)
// 直接回到navigation最開頭
self.navigationController?.popToRootViewController(animated: true)
</code></pre>

<h2 id="前後的controller">前後的controller</h2>

<p>如同present / dismiss可以拿到前後關係一樣，navigation controller也是可以拿到前後關係的。
所有經過的controller都放在self.navigationController?.viewControllers這個array裡可以拿取。</p>

<pre><code class="language-swift">self.navigationController?.viewControllers[0]
self.navigationController?.viewControllers[1]
...
</code></pre>

<h2 id="navigation-controller的建立">Navigation Controller的建立</h2>

<p>Navigation Contrller本身並不帶有頁面資訊，而是在Navigation Controller的下一個Controller才會開始顯示。
那兩者之間要建立連線，必須要指定Navigation Controller當中的Root View Controller才行。</p>

<ul>
<li>方法1: Navigation綁定Root Controller，有兩種做法

<ul>
<li>按住Ctrl並將Navigation Controller拉到想要顯示的第一個Controller，鬆開後選擇Root view Controller</li>
<li>在Navigation Controller的Triggered Segue中，指定Root view Controller</li>
</ul></li>
<li>方法2: 在StoryBoard中，點擊已經存在的Controller。並從上方選單Editor =&gt; Embed in =&gt; NavigatioController即可</li>
</ul>

<h2 id="上面的title和向右鈕">上面的title和向右鈕</h2>

<p>預設只有Navigation Controller後第一個Bar可以編輯Title，若要加入新title則要從StoryBoard中拉入<strong>Navigation item</strong>
預設上方並無向右鍵，只有返回鍵，若要加入則拉入<strong>Bar Button Item</strong></p>

<h1 id="tab-bar-controller">Tab Bar Controller</h1>

<p>與Navigation View許多做法類似
想加上新的tab可以
- 方法1: TabViewController綁定View Controllers，有兩種做法
 - 按住Ctrl並將TabViewController拉到想要加上的Controller，鬆開後選擇View Controllers
 - 在TabViewController的Triggered Segue中，指定新的View Controllers
- 方法2: 在StoryBoard中，點擊已經存在的Controller。並從上方選單Editor =&gt; Embed in =&gt; TabViewController即可</p>

<h2 id="tab-bar-controller下的controller們">tab bar controller下的controller們</h2>

<pre><code class="language-swift">self.tabBarController?.viewControllers[0]
self.tabBarController?.viewControllers[1]
...
</code></pre>

<p>要注意的是，如果是tab bar controller下包著navigation controller，在存取時要先轉型成navigation controller，再取用navigation controller裡面的controller，才不會錯誤。</p>

<h2 id="切換tab">切換tab</h2>

<pre><code class="language-swift">self.tabBarController?.selectedIndex = 0
</code></pre>

<h2 id="隱藏tab">隱藏tab</h2>

<pre><code class="language-swift">self.tabBarController?.tabBar.isHidden = true
</code></pre>

<h1 id="在不同的controller之間跳轉">在不同的Controller之間跳轉</h1>

<h2 id="方法1-直接拖拉">方法1 直接拖拉</h2>

<p>在storyboard上
按住ctrl點下來源Controller之button拉到要呈現的Controller後鬆開，選擇show或present即可。
show會在啟用navigation bar的時候自動使用navigation.push，若無navigation bar則是使用present。</p>

<h2 id="方法2-利用segue">方法2 利用segue</h2>

<p>在storyboard上
按住ctrl點下來源Controller，拉到要呈現的Controller，會多一條segue連線，幫此條連線取名字(identifer)
接下來在想切換的情況下使用performSegue即可(參數為剛剛取的identifer)</p>

<pre><code class="language-swift">performSegue(withIdentifier: &quot;goToView2&quot;, sender: nil)
</code></pre>

<h2 id="方法3-指定storyboard以及controller-通常用在更換story-board的時候">方法3 指定StoryBoard以及Controller (通常用在更換Story Board的時候)</h2>

<p>將要呈現的Controller取名字(StoryBoardID)
並在程式碼中指定
1. 位於哪個StoryBoard
2. Controller的StoryBoardID
最後present或push即可</p>

<pre><code class="language-swift">let myStoryBoard = UIStoryboard(name: &quot;Main&quot;, bundle: nil)
let whiteViewController = myStoryBoard.instantiateViewController(withIdentifier: &quot;whiteView&quot;)
present(whiteViewController, animated:true, completion:nil)
</code></pre>

<p>如果是位於同一個storyboard，也可以拿到自己的storyboard</p>

<pre><code class="language-swift">let myStoryBoard = self.storyboard!
let whiteViewController = myStoryBoard.instantiateInitialViewController(withIdentifier: &quot;whiteView&quot;)
present(whiteViewController, animated:true, completion:nil)
</code></pre>

<h2 id="方法4-storyboard-reference-通常用在更換story-board的時候">方法4 StoryBoard Reference (通常用在更換Story Board的時候)</h2>

<p>在StoryBoard中，將StoryBoard Reference
拖到畫面上，指定StoryBoard Reference上的StoryBoard和ControllerID
接下來利用方法1或2拖拉即可成功</p>

<h2 id="方法5-逃生門-通常用在要返回前一個controller的時候">方法5 逃生門 (通常用在要返回前一個Controller的時候)</h2>

<h3 id="情況">情況</h3>

<p>假設最初的controller取名叫parent controller
parent controller可以連到許多child controller
當child controller想返回parent controller的時候</p>

<h3 id="作法">作法</h3>

<p>先寫在parent controller</p>

<pre><code class="language-swift">@IBAction func backToMain(_ segue:UIStoryboardSegue){
    print(&quot;back to main&quot;)
}
</code></pre>

<p>再用StoryBoard選擇child controller
按鈕按住ctrl往該controller的逃生門拉 (上方最右邊的圖示)
即會出現backToMain的方法
如果parent controller在child controller返回後想執行什麼動作也可在此function中填入</p>

<h1 id="controller之間傳遞訊息">Controller之間傳遞訊息</h1>

<h2 id="方法1-利用destination-controller的property-呼叫下一個controller時">方法1. 利用destination controller的property (呼叫下一個Controller時)</h2>

<ol>
<li>複寫Source Controller的prepare Function</li>
<li>參數segue之屬性destionation即為destination controller</li>
<li>強制轉型為destination controller</li>
<li>將其塞入數值</li>
</ol>

<p>這裡要注意的是，不能把值塞進destination controller的UI元件內(Ex: Label)，因為這個時候畫面元件還沒生成。</p>

<pre><code class="language-swift">// Source Controller
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    if segue.destination is SecondViewController{
    let des = segue.destination as! SecondViewController
    des.textFromFirstView = &quot;Hello World&quot;
    }
}
</code></pre>

<h2 id="方法2-利用前後階層關係-僅適用於返回controller時">方法2. 利用前後階層關係(僅適用於返回controller時)</h2>

<p>前面有說過present可以靠
- presentingViewController
- presentedViewController</p>

<p>navigation bar可以靠
- self.navigationController?.viewControllers[0]
- self.navigationController?.viewControllers[1]
- &hellip;</p>

<p>來獲得前面的controller元件
取得controller後再參考方法1塞入值</p>

<h2 id="方法3-protocol-返回前一個controller時">方法3. protocol (返回前一個controller時)</h2>

<p>將前一個controller名為FirstViewController
現在這個controller名為SecondViewController
令一個protocol叫做SecondViewControllerDelegate</p>

<ol>
<li>將SecondViewControllerDelegate當作SecondViewController的屬性</li>
<li>在FirstViewController跳轉到SecondViewController前，通過方法1塞進自己實作的SecondViewControllerDelegate</li>
<li>SecondViewController消失前，執行該protocol的method (透過複寫viewWillDisapear來達成)</li>
</ol>

<p>```swift SecondController
var delegate:SecondViewControllerDelegate?
@IBAction func goBack(_ sender: UIButton) {
    let _ = navigationController?.popViewController(animated: true)
}</p>

<p>override func viewWillDisappear(_ animated: Bool) {
  super.viewWillDisappear(animated)
  if self.isMovingFromParentViewController{
        delegate?.setColor(colorType: &ldquo;red&rdquo;)
    }
}</p>

<pre><code>`hint: 可以靠 self.isMovingFromParentViewController來測試是否為返回到前一個Controller`

```swift SecondViewControllerDelegate
protocol SecondViewControllerDelegate{
    func setColor(colorType:String)
}
</code></pre>

<p>```swift FirstViewController (實作SecondViewControllerDelegate)
override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
  if let des = segue.destination as? SecondViewController{
    des.delegate = self
  }
}</p>

<pre><code>
## 方法4. notification (返回前一個controller時)
1. parent controller先監聽事件
    - 撰寫接收到監聽後要執行的function
  - 註冊監聽事件
2. child controller發送notification

```swift ParentController
// 接收到事件後要執行的任務
func getUpdateNoti(noti:Notification) {
    let data = noti.userInfo![&quot;data&quot;] as! String
    print(data)
}

override func viewDidLoad() {
  super.viewDidLoad()
    
  // 註冊事件
  let notificationName = Notification.Name(&quot;GetUpdateNoti&quot;)
  NotificationCenter.default.addObserver(self, selector: #selector(ViewController.getUpdateNoti(noti:)), name: notificationName, object: nil)
}
</code></pre>

<p>```swift ChildController
// 發送事件
let notificationName = Notification.Name(&ldquo;GetUpdateNoti&rdquo;)
NotificationCenter.default().post(name: notificationName,object: nil, userInfo: [&ldquo;data&rdquo;:&ldquo;Hello World&rdquo;])</p>

<pre><code>
## 方法5. 全域變數
在AppDelegate增加property
並在想要使用的class裡面，將UIApplication.shared.delegate轉型為AppDelegate
即可使用裡面的property
```swift
if let appDelegate = UIApplication.shared.delegate as? AppDelegate{
    if let colorName = appDelegate.color{
    setColor(colorType: colorName)
  }
}
</code></pre>

<p>全域變數還有很多做法，像是singleton或是寫在class之外，有機會再開一篇講。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-09-13/">
        Swift 快速筆記
      </a>
    </h1>

    <span class="post-date">Tue, Sep 13, 2016</span>

    

<h1 id="autolayout">AutoLayout</h1>

<p>只要確定好下面的參數，autoLayout就不會跑警告
1. x
2. y
3. width
4. height</p>

<h1 id="alertcontroller">AlertController</h1>

<ol>
<li>新增AlertController

<ul>
<li>.ActionSheet可藉由點警告視窗外面而取消</li>
<li>.alert不可藉由點警告視窗外面而取消</li>
</ul></li>
<li>如果需要&rdquo;OK&rdquo;等選項的話，新增UIAction (.alert必做，不然會回不去)</li>
<li>將UIAction放置到AlertController上</li>
<li>present</li>
</ol>

<pre><code class="language-swift">let myAlert = UIAlertController(title: &quot;Please enter something&quot;, message: nil, preferredStyle: .alert)
let myAction = UIAlertAction(title: &quot;OK&quot;, style: .default, handler:nil)
myAlert.addAction(myAction)
present(myAlert, animated: true, completion: nil)
</code></pre>

<p>嘗試加入文字框</p>

<pre><code class="language-swift">let myAlert = UIAlertController(title: &quot;Add New Task&quot;, message: nil, preferredStyle: .alert)
myAlert.addTextField {
  (textfield:UITextField) in
  textfield.placeholder = &quot;Add New Task'&quot;
}
</code></pre>

<p>嘗試對加入的UIAction執行一些動作</p>

<pre><code class="language-swift">let ok = UIAlertAction(title: &quot;OK&quot;, style: .default){
    (action) in
  // action是UIAlertAction
  // 在下面填入想要執行的動作
  ...
  ...
}
</code></pre>

<h1 id="讓鍵盤自動彈出">讓鍵盤自動彈出</h1>

<p>在可輸入的View中(Ex: textfield)，會有<code>becomeFirstResponder()</code>方法</p>

<h1 id="pickerview">PickerView</h1>

<h2 id="選中某一列後立刻執行某動作">選中某一列後立刻執行某動作</h2>

<p>複寫</p>

<pre><code class="language-swift">func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) {
    chooseColor = colorArray[row]
}
</code></pre>

<h2 id="得知目前是選中哪一列">得知目前是選中哪一列</h2>

<p>call function，並指定是哪個Component</p>

<pre><code class="language-swift">myPickerView.selectedRow(inComponent: 0)
</code></pre>

<h2 id="更為簡單的datepickerview">更為簡單的DatePickerView</h2>

<p>若想得知DatePickerView所擷取到的日期或時間只要使用</p>

<pre><code class="language-swift">let date = myDatePicker.date
</code></pre>

<p>一行即可，其他的都是date格式的問題。
DatePickerView的樣式可以從storyBoard中選擇。</p>

<h1 id="播放影片">播放影片</h1>

<h2 id="流程">流程</h2>

<ol>
<li>找到播放影片URL</li>
<li>初始化AVPlayer(將URL放進去)</li>
<li>初始化AVPlayerViewController</li>
<li>將AVPlayerController的player設成剛剛的AVPlayer</li>
<li>present並播放</li>
</ol>

<pre><code class="language-swift">guard let path = Bundle.main.url(forResource: &quot;HipHop&quot;, withExtension: &quot;mp4&quot;) else {
    return
}

let videoPlayer = AVPlayer(url: path)
let videoPlayerController = AVPlayerViewController()
videoPlayerController.player = videoPlayer
present(videoPlayerController, animated: true, completion: nil)
videoPlayer.play()
</code></pre>

<h2 id="重複播放">重複播放</h2>

<p>不同於播放音樂可以簡單設置loop，重複播放影片是要傾聽影片播完後所發送的notification。</p>

<p>監聽播放完成notification</p>

<pre><code class="language-swift">NotificationCenter.default.addObserver(self, selector: #selector(ViewController.playerDidReachEnd(notification:)), name: Notification.Name.AVPlayerItemDidPlayToEndTime, object: nil)

// 監聽function
func playerDidReachEnd(notification:Notification){
    videoPlayer?.currentItem?.seek(to: kCMTimeZero)
    videoPlayer?.play()
}
</code></pre>

<h1 id="錄影">錄影</h1>

<h1 id="照相">照相</h1>

<ol>
<li>在info.plist設定照相權限</li>
<li>產生image picker Controller</li>
<li>設定 sourceType</li>
<li>設定delegate屬性，決定照相完畢後要做什麼</li>
<li>推出image Picker
這邊要特別注意，模擬器是沒有camera的，所以若要用模擬器最好先檢查。</li>
</ol>

<p>照相權限
<img src="http://i.imgur.com/Yf8lCmd.png" alt="照相權限" /></p>

<pre><code class="language-swift">let imagePicker = UIImagePickerController()
imagePicker.sourceType = .camera
imagePicker.delegate = self
present(imagePicker, animated:true, completion:nil)
</code></pre>

<p>delegate寫法</p>

<pre><code class="language-swift">func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) {
  guard let image = info[UIImagePickerControllerMediaURL] as? UIImage{
    print(&quot;Cannot get picture url&quot;)
    return
  }
  myImageView.image = image
  dismiss(animated: true, completion: nil)
}
</code></pre>

<h2 id="其他實用方法">其他實用方法</h2>

<p>若想存檔可使用下方程式碼</p>

<pre><code>UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil)
</code></pre>

<p>若想直接從已拍照圖庫裡面選擇圖片，可以透過更改sourcetype來完成</p>

<pre><code>imagePicker.sourceType = .photoLibrary
</code></pre>

<h1 id="使用資源">使用資源</h1>

<ul>
<li><p>先找路徑再找URL</p>

<pre><code class="language-swift">let path = Bundle.main.path(forResource: &quot;Right&quot;, ofType:&quot;mp3&quot;)
let audioURL = URL(fileURLWithPath: path)
</code></pre></li>

<li><p>直接找URL</p>

<pre><code class="language-swift">let path = Bundle.main.url(forResource: &quot;HipHop&quot;, withExtension: &quot;mp4&quot;)
</code></pre></li>
</ul>

<h1 id="存資料-物件">存資料(物件)</h1>

<p>使用UserDefaults.standard.set和UserDefaults.standard.synchronize
1. 用set並給一個key
2. synchronize</p>

<pre><code class="language-swift">var toDo = [&quot;Buy milk&quot;, &quot;iOS exam&quot;, &quot;Sleep&quot;, &quot;Make money&quot;]
UserDefaults.standard.set(toDo, forKey:&quot;todo&quot;)
UserDefaults.standard.synchronize()
</code></pre>

<p>取值，要記得取出來是anyObject，必須轉型，而且可能為nil(key不存在)。</p>

<pre><code class="language-swift">guard let loaded = UserDefaults.standard.object(forKey: &quot;toDo&quot;) as? [String] else{
  print(&quot;No such key&quot;)
  return
}
print(loaded)
</code></pre>

<p>如果存的是預設型別(像是Int)，取值方法可以不用轉型</p>

<pre><code class="language-swift">guard let loaded = UserDefaults.standard.integer(forKey: &quot;toDo&quot;) else{
  print(&quot;No such key&quot;)
  return
}
print(loaded)
</code></pre>

<h1 id="property-list-plist">Property List (Plist)</h1>

<p>Info.plist就是一種Property List的檔案。
plist可以很方便地幫你用Array或dictionary的形式存取資訊(String, Int &hellip;)，個人覺得跟json沒兩樣。
使用的步驟如下
1. 新增一個Property List檔案
2. 在上面加上一些資訊(假設是一串Array)
3. 使用Bundle.main.path拿到資源(檔案型態是plist)
4. 利用NSArray將檔案轉成Array，或是NSDictionary檔案轉成dict</p>

<pre><code class="language-swift">guard let scorePlist = Bundle.main.path(forResource: &quot;Score&quot;, ofType: &quot;plist&quot;),
  let scoreArray = NSArray(contentsOfFile: scorePlist) else{
    print(&quot;Get Plist Error&quot;)
    return
}
print(scoreArray)
</code></pre>

<h1 id="activity-indicator">Activity Indicator</h1>

<ul>
<li>用StoryBoard直接拉</li>
<li>記得把Hides when stop打勾，不然圖案一直都在</li>
<li>startAnimating()開始轉</li>
<li>stopAnimationg()停止轉</li>
</ul>

<h1 id="cocoapods">COCOAPODS</h1>

<p>先安裝
<a href="https://cocoapods.org/">https://cocoapods.org/</a></p>

<p>在Xcode專案底下</p>

<pre><code class="language-bash">pod init
</code></pre>

<p>編輯生出來podfile
加入需要的pod 專案</p>

<pre><code class="language-Podfile"># Uncomment the next line to define a global platform for your project
# platform :ios, '9.0'

target 'HelloCoCoaPods' do
  # Comment the next line if you're not using Swift and don't want to use dynamic frameworks
  use_frameworks!

  # Pods for HelloCoCoaPods
  pod 'Firebase/Database'

end
</code></pre>

<p>安裝專案</p>

<pre><code class="language-bash">pod install
</code></pre>

<h1 id="reachability-測試有無連網">Reachability 測試有無連網</h1>

<ol>
<li>下載<a href="https://developer.apple.com/library/content/samplecode/Reachability/Introduction/Intro.html">reachability</a></li>
<li>將Reachablility.h 及.m一起拖到專案，選擇新增Bridge</li>
<li>Bridege中寫入<code>#import &quot;Reachability.h&quot;</code></li>
<li>初始化<code>Reachability(hostName: &quot;www.apple.com&quot;)</code>

<ul>
<li>必須指定一個可連線的網址</li>
</ul></li>
<li>使用方法startNotifier</li>
<li>addObserver</li>
<li>接收notification</li>
</ol>

<h1 id="xml">XML</h1>

<p>解析XML XML delegate</p>

<h1 id="值得用的app">值得用的APP</h1>

<p>figure</p>

<h1 id="登入與非登入狀態用不同的controller">登入與非登入狀態用不同的Controller</h1>

<p>在Appdelegate裡面</p>

<pre><code class="language-swift">func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {
  if check != 1 {
    let controller = UIStoryboard(name: &quot;LogIn&quot;, bundle: nil).instantiateViewController(withIdentifier: &quot;logIn&quot;)
    self.window?.rootViewController = controller
  } else {
    let controller = UIStoryboard(name: &quot;Main&quot;, bundle: nil).instantiateViewController(withIdentifier: &quot;tab&quot;)
    self.window?.rootViewController = controller
  }
    return true
}
</code></pre>

<h1 id="keyboard">keyboard</h1>

<h2 id="彈出來時畫面自動向上">彈出來時畫面自動向上</h2>

<p><a href="http://stackoverflow.com/questions/25693130/move-textfield-when-keyboard-appears-swift">http://stackoverflow.com/questions/25693130/move-textfield-when-keyboard-appears-swift</a></p>

<h2 id="點旁邊畫面自動縮回去">點旁邊畫面自動縮回去</h2>

<p><a href="http://stackoverflow.com/questions/24126678/close-ios-keyboard-by-touching-anywhere-using-swift">http://stackoverflow.com/questions/24126678/close-ios-keyboard-by-touching-anywhere-using-swift</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/misc/2016-09-06/">
        產品開發的進展過程
      </a>
    </h1>

    <span class="post-date">Tue, Sep 6, 2016</span>

    

<h1 id="brain-storming要想出的東西">Brain Storming要想出的東西</h1>

<ul>
<li>服務對象(Target User)</li>
<li>想解決的問題</li>
<li>使用情境(User Scenario)</li>
<li>使用行為(User Story)

<ul>
<li>主詞動詞受詞，描述一個功能
<br /></li>
</ul></li>
</ul>

<h1 id="工程師眼中的mvp">工程師眼中的MVP</h1>

<ul>
<li>花最少時間(最多三個月，最好定在一個月)能&rdquo;上架&rdquo;的產品</li>
<li>精準服務ＴＡ</li>
<li>大部份是從工具類產品開始(反例：平台)

<ul>
<li>使用者相對單一，不必顧慮到太多外人</li>
</ul></li>
<li>可用功能約略只有三到五個

<ul>
<li>讓行為單一</li>
</ul></li>
<li>請用wireframe storyboard進行描述

<ul>
<li>手畫也可以</li>
<li>讓所有人在同一概念下做事</li>
<li><a href="https://prottapp.com">prott</a>好用，UI跳轉還可以幫你畫流程圖</li>
</ul></li>
</ul>

<h1 id="工程師最重要的工作">工程師最重要的工作</h1>

<ul>
<li>提出所有User Story中最花時間，最不可能達成的功能。</li>
</ul>

<h1 id="卡片評分">卡片評分</h1>

<ul>
<li>就每個User Story對難易度與實用性進行評分</li>
<li>所有人評分，不只有工程師</li>
</ul>

<h1 id="wireframe要表達的重點">Wireframe要表達的重點</h1>

<ul>
<li>流程問題</li>
<li>幫助他人了解你的東西</li>
</ul>

<h1 id="工程師和設計師的合作">工程師和設計師的合作</h1>

<ul>
<li>大部份的專案，不該由工程師跟設計師直接溝通，要有中間人比較好

<ul>
<li>會吵架！！！</li>
</ul></li>
<li>工程師要評估介面和過場動畫有沒有非常困難或不合理的點</li>
<li>切圖的命名規則應該優先訂定

<ul>
<li>檔名須以小寫英文字母開頭</li>
<li>不能有空白鍵</li>
<li>etc
<br /></li>
</ul></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/misc/2016-09-05/">
        從0到1 與1到1億
      </a>
    </h1>

    <span class="post-date">Mon, Sep 5, 2016</span>

    

<h1 id="標題與內文不符">標題與內文不符～～</h1>

<h1 id="小步快跑">小步快跑</h1>

<ul>
<li>最小的成本去除錯，最快的速度達成目標。</li>
</ul>

<h1 id="單週迭代">單週迭代</h1>

<h2 id="種類">種類</h2>

<ul>
<li>Idea</li>
<li>Code</li>
<li>Data</li>
</ul>

<h2 id="build-idea-build">Build：IDEA =&gt; Build</h2>

<ul>
<li>需求撰寫</li>
<li>交互 視覺設計</li>
<li>研發</li>
<li>測試</li>
</ul>

<h2 id="production-code-data">Production：Code =&gt; Data</h2>

<ul>
<li>Data</li>
<li>GP(概率發布)</li>
<li>數據蒐集</li>
</ul>

<h1 id="訪談">訪談</h1>

<ul>
<li>訪談不是為了驗證數據上的結果</li>
<li>也不是用來證明個人的假設，去說服別人同意自己的觀點</li>
<li>不該預設目標，倒果為因</li>
<li>不要陷入&rdquo;確認偏誤&rdquo;的立場</li>
</ul>

<h2 id="目的">目的</h2>

<ul>
<li>為了瞭解用戶這麼做，或不這麼做的原因是什麼？</li>
<li>了解用戶過去的經驗，當場景發生當時的想法，以及當下認為最重要的事情是什麼？</li>
<li>不要問假設性問題，還原用戶發生問題時的心情。</li>
</ul>

<h2 id="要點">要點</h2>

<ul>
<li>SAY：說了什麼</li>
<li>DO：做了什麼</li>
<li>FEEL：當下感受</li>
<li>THINK：預期反應</li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-08-05/">
        Android JNI 環境建置
      </a>
    </h1>

    <span class="post-date">Fri, Aug 5, 2016</span>

    

<h1 id="介紹">介紹</h1>

<p>主要參考這篇：
<a href="http://blog.xuite.net/lwchafter30/blog/373974237-Android+studio+1.5.1+NDK+JNI%E7%92%B0%E5%A2%83%E5%AE%89%E8A3%9D%E8%88%87%E5%9F%B7%E8%A1%8C%E5%8E%9F%E7%90%86" title="Android studio 1.5.1 NDK JNI環境安裝與執行原理">Android studio 1.5.1 NDK JNI環境安裝與執行原理</a>
不過Android 2.1.2上步驟稍有簡化，還是可以達到同樣效果。
1. 載NDK
2. 設定external tool (僅javah)
3. 在java中增加native code，並利用javah產生JNI header
4. 實作JNI
5. 設定gradle (僅ndk區塊)</p>

<h1 id="載ndk">載NDK</h1>

<p>開啟SDK Manager，選擇SDK Tools，將NDK之選項給打勾。
<img src="http://i.imgur.com/nsDiPAi.png" alt="SDK Manager" /></p>

<h1 id="設定external-tool">設定external tool</h1>

<p>與連結相同，不過只要設定javah即可，其他不需要。</p>

<p><img src="http://i.imgur.com/m4s02Gt.png" alt="javah設定" /></p>

<p>快速複製區 <a href="http://blog.xuite.net/lwchafter30/blog/373974237-Android+studio+1.5.1+NDK+JNI%E7%92%B0%E5%A2%83%E5%AE%89%E8A3%9D%E8%88%87%E5%9F%B7%E8%A1%8C%E5%8E%9F%E7%90%86" title="Android studio 1.5.1 NDK JNI環境安裝與執行原理">來源</a></p>

<pre><code>$JDKPath$/bin/javah

-v -jni -d $ModuleFileDir$/src/main/jni $FileClass$

$SourcepathEntry$
</code></pre>

<p>Windows和Linux在第1行稍有分別，只有在Windows系統中，執行檔的副檔名才是.exe。Mac和Linux皆否。
個人是用linux系統，所以第1行javah後面並不接.exe，若是Windows系統則第1行變為。</p>

<pre><code>$JDKPath$/bin/javah.exe
</code></pre>

<h1 id="jni-header">JNI header</h1>

<p>在想要使用JNI的class加入如下的程式碼。</p>

<pre><code>    static {
            System.loadLibrary(&quot;myJNI&quot;);
    }
    public native String getMycstring();
    public native void testLog();
</code></pre>

<p>static區塊中的myJNI會變成將來再build gradle當中的moduleName
method加上native關鍵詞後，程式就會知道這是需要依靠JNI實作之程式碼。</p>

<p>再來在該java檔上按右鍵，使用剛剛建置好的external library javah，自動的產生JNI header。
<img src="http://i.imgur.com/ag5rJ6c.png" alt="使用javah" /></p>

<p>此時在java目錄下，應該會多出一個jni的資料夾，裡頭放置著 OOXX.h
打開.h檔，建置出來的code應該會如下形式</p>

<pre><code class="language-c++">/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class com_example_isa_myapplication_MainActivity */

#ifndef _Included_com_example_isa_myapplication_MainActivity
#define _Included_com_example_isa_myapplication_MainActivity
#ifdef __cplusplus
extern &quot;C&quot; {
#endif
/*
 * Class:     com_example_isa_myapplication_MainActivity
 * Method:    getMycstring
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_isa_myapplication_MainActivity_getMycstring
  (JNIEnv *, jobject);

/*
 * Class:     com_example_isa_myapplication_MainActivity
 * Method:    testLog
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_example_isa_myapplication_MainActivity_testLog
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif

</code></pre>

<h1 id="實作jni">實作JNI</h1>

<p>步驟如下
1. 在jni資料夾中，新增一個myJNI.cpp
2. include剛剛自動產生的header
3. 實作剛剛只宣告未實作的程式碼
4. (細節注意)</p>

<h2 id="新增myjni-cpp">新增myJNI.cpp</h2>

<p>在jni資料夾中，新增一個myJNI.cpp</p>

<h2 id="include剛剛自動產生的header">include剛剛自動產生的header</h2>

<pre><code class="language-c++">#include &quot;com_example_isa_myapplication_MainActivity.h&quot;
</code></pre>

<h2 id="實作剛剛只宣告未實作的程式碼">實作剛剛只宣告未實作的程式碼</h2>

<p>由於Log功能要使用到android/log.h library，所以也要include進來。</p>

<pre><code class="language-c++">#include &quot;com_example_isa_myapplication_MainActivity.h&quot;
#include &lt;android/log.h&gt;

JNIEXPORT jstring JNICALL Java_com_example_isa_myapplication_MainActivity_getMycstring
  (JNIEnv *env, jobject jobj){
        return (*env).NewStringUTF(&quot;MY !!  NDKString!!&quot;);
  }
  
JNIEXPORT void JNICALL Java_com_example_isa_myapplication_MainActivity_testLog
  (JNIEnv * env, jobject jobj){
    __android_log_print(ANDROID_LOG_INFO, &quot;JNI&quot;, &quot;JNI Test&quot;);
  }
</code></pre>

<h2 id="細節注意">細節注意</h2>

<p>當然僅僅如此還不夠，觀看.h檔可以發現有extern &ldquo;C&rdquo;包圍著宣告的函式，所以也要一併複製。</p>

<pre><code class="language-c++">#include &quot;com_example_isa_myapplication_MainActivity.h&quot;
#include &lt;android/log.h&gt;


#ifdef __cplusplus
extern &quot;C&quot; {
#endif

JNIEXPORT jstring JNICALL Java_com_example_isa_myapplication_MainActivity_getMycstring
  (JNIEnv *env, jobject jobj){
        return (*env).NewStringUTF(&quot;MY !!  NDKString!!&quot;);
  }
  
  JNIEXPORT void JNICALL Java_com_example_isa_myapplication_MainActivity_testLog
  (JNIEnv * env, jobject jobj){
    __android_log_print(ANDROID_LOG_INFO, &quot;JNI&quot;, &quot;JNI Test&quot;);
  }
  
#ifdef __cplusplus
}
#endif
</code></pre>

<p>切記不要連 #ifndef _Included_com_example_isa_myapplication_MainActivity 的相關句子也複製進來。
在.h檔已經定義過，若在.cpp重複定義，則中間的所有內容都會被忽略掉。</p>

<h1 id="設定gradle">設定gradle</h1>

<p>在defaultConfig這個區塊內加入</p>

<pre><code>ndk{
  moduleName &quot;myJNI&quot;
  ldLibs &quot;log&quot;
}
</code></pre>

<p>moduleName為你剛剛在System.loadLibrary裡面設定的名字。
ldLibs &ldquo;log&rdquo;可以讓cpp檔include log功能的時候不會出錯。</p>

<p>整體看起來是這樣</p>

<pre><code>android {
    compileSdkVersion 23
    buildToolsVersion &quot;23.0.2&quot;

    defaultConfig {
        applicationId &quot;com.example.isa.myapplication&quot;
        minSdkVersion 15
        targetSdkVersion 23
        versionCode 1
        versionName &quot;1.0&quot;
        ndk{
            moduleName &quot;myJNI&quot;
            ldLibs &quot;log&quot;
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}
</code></pre>

<p>最後編譯就完成了。</p>

<h1 id="參考資料">參考資料</h1>

<p><a href="http://blog.xuite.net/lwchafter30/blog/373974237-Android+studio+1.5.1+NDK+JNI%E7%92%B0%E5%A2%83%E5%AE%89%E8A3%9D%E8%88%87%E5%9F%B7%E8%A1%8C%E5%8E%9F%E7%90%86" title="Android studio 1.5.1 NDK JNI環境安裝與執行原理">Android studio 1.5.1 NDK JNI環境安裝與執行原理</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-07-24/">
        renpy (5) 自己撰寫button的Action
      </a>
    </h1>

    <span class="post-date">Sun, Jul 24, 2016</span>

    

<p>在<a href="https://www.renpy.org/doc/html/screen_actions.html">官網</a>可以看到有很多可使的Action。
萬一想要的功能並不在裡面呢? 其實也有<a href="https://www.renpy.org/doc/html/screen_actions.html#Function">Function</a>此一Action的存在，可自己撰寫Function傳進去使用。</p>

<p>這裡只是提點一些Function使用上的誤區。</p>

<h1 id="絕對要使用function此action">絕對要使用Function此Action</h1>

<ul>
<li>絕對要使用Function此Action</li>
<li>絕對不要直接把自己寫的function當Action</li>
</ul>

<h2 id="錯誤範例">錯誤範例</h2>

<pre><code class="language-python">python:
    def test():
        pass
textbutton &quot;Click Me!!&quot;:
    action test()
</code></pre>

<p>在renpy眼中，這是一個正常行為，他不會報錯。
但是這會導致此button並非在點擊才觸發Action，而是在載入、textbutton出來的那瞬間，就執行了action。</p>

<h2 id="正確寫法">正確寫法</h2>

<pre><code class="language-python">python:
    def test():
        pass
textbutton &quot;Click Me!!&quot;:
    action Function(test)
</code></pre>

<h1 id="傳入參數">傳入參數</h1>

<p>如果這個function需要支援參數傳遞呢? 一樣可以用Function達到</p>

<pre><code class="language-python">python:
    def test(text):
        pass
textbutton &quot;Click Me!!&quot;:
    action Function(test, text = &quot;apple&quot;)
</code></pre>

<p>Function在官方的文件上說支援args和kwargs的參數傳遞。
但實際測試後發現，<strong>args的參數傳遞是壞的</strong>，並不能使用。所以請都用kwargs的參數傳遞法。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-07-23/">
        renpy (4) button / imagebutton / textbutton 按鈕變色效果 (hover / unhover)
      </a>
    </h1>

    <span class="post-date">Sat, Jul 23, 2016</span>

    

<p>當滑鼠移上按鈕，咻，按鈕變色了。當滑鼠離開按鈕，咻，按鈕又變回來了。
藉由這樣的效果，可以讓玩家清楚感受到這是一個可點選的按鈕。
要如何製作這樣的效果呢?</p>

<h1 id="imagebutton">imagebutton</h1>

<p>難度：簡單</p>

<pre><code class="language-python">Imagebutton:
    idle &quot;滑鼠離開時照片&quot;
    hover &quot;滑鼠移上時照片&quot;
    action NullAction()
</code></pre>

<p>參閱<a href="https://www.renpy.org/doc/html/screens.html#imagebutton">官網</a>
只要設定屬性idle及hover即可，要注意的一點是，必須要有任意Action，變色效果才會顯現出來。
如果不打算有任何Action，則使用NullAction吧，此方法就是為了變色而設立的。</p>

<h1 id="textbutton">textbutton</h1>

<p>難度：中等
參閱<a href="https://www.renpy.org/doc/html/thequestion.html#options-rpy">官網</a>在<strong>options.rpy</strong>當中，有欄位為</p>

<pre><code class="language-python">widget_text = &quot;滑鼠離開時顏色&quot;,
widget_selected = &quot;滑鼠移上時顏色&quot;,
</code></pre>

<p>設定好後，textbutton的變色就會依照此設定來做調整囉。
缺點是不能在任意的textbutton指定變數顏色，如果今天有兩個textbutton，想指定為
1. textbutton1 滑鼠移上紅色 滑鼠離開白色
2. textbutton2 滑鼠移上藍色 滑鼠離開白色</p>

<p>在此方法中是無能為力的。</p>

<h1 id="button">button</h1>

<p>難度：困難，但textbutton或imagebutton也可用此方法來變色，最萬用。</p>

<pre><code class="language-python">Screen button_test:
    default myhover = False
    button:
        action SetScreenVariable(&quot;myhover&quot;, False)
        hovered SetScreenVariable(&quot;myhover&quot;, True)
        unhovered SetScreenVariable(&quot;myhover&quot;, False)
        if myhover:
          image &quot;滑鼠移上時照片&quot;
          text (&quot;YA&quot;) color &quot;滑鼠移上時顏色&quot;
        else:
          image &quot;滑鼠離開時圖片&quot;
          text (&quot;YA&quot;) color &quot;滑鼠離開時顏色&quot;
</code></pre>

<p>在Screen Language當中，可以使用defalut這個字眼來定義專屬於某個Screen的變數，並且可使用<a href="https://www.renpy.org/doc/html/screen_actions.html#SetScreenVariable">SetScreenVariable</a>此Action來指定變數值。
所以只要指定，在滑鼠移上時，變數值為True，滑鼠離開時，變數值為False。
最後再根據True/False之值，來決定畫面上要顯示什麼即可。</p>

<p>另外，除了if else寫法以外，單純圖片變色也可以使用ConditionSwitch這個函式</p>

<pre><code class="language-python">image ConditionSwitch( myhover, &quot;滑鼠移上時圖片&quot;,
                        True, &quot;滑鼠離開時圖片&quot;)
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-07-11/">
        renpy (3) 改良tooltip的方法
      </a>
    </h1>

    <span class="post-date">Mon, Jul 11, 2016</span>

    

<h1 id="tooltip">tooltip</h1>

<p>所謂的tooltip，就是當你滑鼠移到一個button上後，可以顯示一些說明，讓使用者更了解這個button的功能。
可以用以下的程式碼簡單的實作tootip</p>

<pre><code class="language-python">screen tooltip(tip, positon):
    frame:
        text tip pos position
</code></pre>

<p>然後在button上的hovered和unhovered加上action即可
- hovered : Show(tooltip, tip=&ldquo;說明文字&rdquo;, position = (10,20) )
- unhovered : Hide(tooltip)</p>

<h1 id="出現在滑鼠的位置">出現在滑鼠的位置</h1>

<p>目前這個簡陋的tooltip，它的位置是被固定死的。也就是說，每次有新的tooltip，都得自己先行想好tooltip的位置。
能不能要tooltip直接顯示在滑鼠旁邊呢? 可行的，renpy有提供滑鼠位置的函式。</p>

<pre><code class="language-python">screen tooltip(tip=None):
    frame:
        $ position = renpy.get_mouse_pos()
        text tip pos position
</code></pre>

<p>ok，如此一來，不用輸入position也可以直接顯示在滑鼠上了，使用者想要自己加減pixel，讓tooltip出現在滑鼠的上下左右方也是非常輕而易舉。</p>

<h1 id="隨著滑鼠而移動">隨著滑鼠而移動</h1>

<p>如果想要tooltip不僅僅只是閃現的那刻出現在滑鼠旁，而是無時無刻的跟著滑鼠移動呢?
查閱<a href="https://www.renpy.org/doc/html/screens.html">官網</a>，影響位置的參數有兩個。大部分的Screen物件都有兩種可調的位置屬性，第一個是Common Properties中的at，第二個是Position Style Properties。
據我所知，Position Style Properties是無法動態調整的，所以我們只能依靠關鍵字at後面所接續的<a href="https://www.renpy.org/doc/html/atl.h">trnasform statement</a>來解決這個問題了。</p>

<h2 id="具體步驟">具體步驟</h2>

<ol>
<li>新增一個transform執行function</li>
<li>此function內容為定時更新位置(範例為0.05秒)</li>
<li>在tooltip當中對frame加上at 步驟1的transform</li>
</ol>

<h2 id="範例">範例</h2>

<pre><code class="language-python">transform follow_mouse:
    function follow_mouse_func
    
init python:
    def follow_mouse_func(trans, st, at):
        trans.pos = renpy.get_mouse_pos()
        return 0.05

screen tooltip(tip=None):
    frame:
        at follow_mouse
        if tip is not None:
            text tip size 14 color &quot;#000000&quot;
</code></pre>

<p>function的撰寫可以參考<a href="https://www.renpy.org/doc/html/atl.html#function-statement">官網</a>
簡略的說一下內容：
1. 必須有3個參數
2. 第一個參數為transfrom物件，物件的資訊一樣看<a href="https://www.renpy.org/doc/html/atl.html#list-of-transform-properties">官網</a>
3. 第二、三個參數跟執行時間相關，較不重要。
4. 回傳值為<strong>希望多久後再呼叫一次此function</strong>，0秒代表立刻，None代表不再call function，可以繼續向下執行其他transition內容。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-07-10/">
        renpy (2) show 立繪 image 變數的妙用
      </a>
    </h1>

    <span class="post-date">Sun, Jul 10, 2016</span>

    

<h1 id="問題">問題</h1>

<p>在寫AVG遊戲的時候，常常遇到立繪需要變更的狀況。考量以下場景
1. 人物A平常表情
2. 人物A笑
3. 人物A平常表情
4. 人物A立繪從場上消失</p>

<p>程式碼可能會長這樣</p>

<pre><code class="language-python">image a_normal = &quot;a_normal.png&quot;
image a_laugh = &quot;a_laugh.png&quot;

label start:
    show a_normal
    
    pause 2
    
    hide a_normal
    show a_laugh
    
    puase 2
    
    hide a_laugh
    show a_normal
    
    pause 2
    
    hide a_normal
</code></pre>

<p>如果要人物A換動作，就得先記得他上次是哪個圖片，隱藏之後再show新的，想想就累。</p>

<h1 id="解法">解法</h1>

<p>renpy提供了一個方便的解法。在取變數名稱的時候可以用兩個識別字來描述。
例如可以把立繪取叫
image a normal = &ldquo;a_normal.png&rdquo;
image a laugh = &ldquo;a_laugh.png&rdquo;</p>

<p>如此一來，renpy就會知道a normal和 a laugh為同一人的不同種表情，因為前識別字a都一樣。
這樣show a normal時如果a laugh在場上就會自動隱藏了。
最後若要將a隱藏起來的時候只需要hide前識別字即可。</p>

<pre><code class="language-python">image a normal = &quot;a_normal.png&quot;
image a laugh = &quot;a_laugh.png&quot;

label start:
    show a normal
    
    pause 2
    
    show a laugh
    
    puase 2

    show a normal
    
    pause 2
    
    hide a
</code></pre>

<p>省了不少程式碼，也不需要記上次是哪種立繪。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-07-06/">
        renpy (1) 基礎語句
      </a>
    </h1>

    <span class="post-date">Wed, Jul 6, 2016</span>

    

<h1 id="緣起">緣起</h1>

<p>其實很多內容在 <strong>雪凡與好朋友們的 Ren&rsquo;Py 遊戲引擎初學心得提示</strong> 就有了，大概寫一些製作時的心得而已。
- <a href="http://www.openfoundry.org/foss-programs/8811">第一回</a>
- <a href="http://www.openfoundry.org/foss-programs/8836">第二回</a>
- <a href="http://www.openfoundry.org/foss-programs/8848">第三回</a>
- <a href="http://www.openfoundry.org/foss-programs/8859">第四回</a>
- <a href="http://www.openfoundry.org/foss-programs/8874">第五回</a>
-   <a href="http://www.openfoundry.org/foss-programs/8901">第六回</a>
- <a href="http://www.openfoundry.org/foss-programs/8919">第七回</a>
- <a href="http://www.openfoundry.org/foss-programs/8972">第八回</a>
- <a href="http://www.openfoundry.org/foss-programs/9045">第九回</a></p>

<p>搭配<a href="https://www.renpy.org/doc/html/index.html">renpy官網</a>服用，妙不可言。</p>

<h1 id="檔案目錄">檔案目錄</h1>

<p>初學要知道的在renpy中有三個區段。我稱之為init區段，label區段以及python區段。這三個區段的語法都略有不同。
而撰寫語法的檔案，只要在game目錄下新增.rpy檔即可，不管命名為何，renpy會預設載入game目錄下所有的.rpy檔作為renpy的語法輸入。</p>

<p>接下來就分別說明三個區段的差異之處。</p>

<h2 id="init區段">init區段</h2>

<p>新增一個.rpy檔，若無明確指定為label或python區段，那就可以視為 init 0區段了。
init區段通常做為定義變數、圖片、screen之用，會在遊戲啟動的瞬間先行載入。
init區段可以透過下列語法來新增</p>

<pre><code class="language-python">init -1:
    define abc = character(&quot;abc&quot;)
    image def = &quot;def&quot;
</code></pre>

<p>init旁邊接的數字的意義為載入順序(若沒寫則為0)，比如說，若有三個init區段</p>

<pre><code class="language-python">init 1:
    image a = &quot;a&quot;
init 2:
    image b = &quot;b&quot;
init 3:
    image c = &quot;c&quot;
</code></pre>

<p>雖然撰寫順序為由上往下，但由於數字大的先載入，所以renpy會先讀取image c，接下來是b，最後才為a。
如果有載入順序的要求的話(雖然我還沒遇過)，可以嘗試看看這招。</p>

<h2 id="label區段">label區段</h2>

<p>此處為遊戲運行之腳本，對於玩過avg遊戲的人應該很熟悉，就是讓你可以點一點繼續向下看對話的地方。
可以運用show , call, with dissolve之類的語句來展現對話效果。
這裡列出兩個極為重要的保留(reserved) label</p>

<pre><code class="language-python">label start:
    a &quot;Are u ok&quot;
    b &quot;I'm fine.&quot;

label splashscreen:
    &quot;hello moto&quot;
</code></pre>

<p>現在市面上遊戲開始的流程大致如下
(開啟遊戲) 遊戲廠商logo(或片頭動畫) =&gt; 遊戲主選單 =&gt; 進入遊戲主題</p>

<p>label start為預設的遊戲主題進入點，當你使用Start()這個函式時即會自動跳轉到start label所在的位置。
label splashscreen則可以作為遊戲廠商logo或片頭動畫之用，是進入遊戲主選單前要執行之語句。</p>

<p>其他重要的label可參照<a href="https://www.renpy.org/doc/html/label.html#special-labels">官網</a></p>

<p>另外，若無指定<strong>main_menu</strong>此label，則<strong>screen main_menu</strong>是預設的遊戲主選單畫面。</p>

<h2 id="python區段">python區段</h2>

<p>在撰寫renpy的時候應該多數人都會覺得自己是在寫renpy而非寫python，雖然語法相似，很多地方還是有不同XD
另外，renpy語法雖然已經夠強大，但有些時候還是得靠python才能做到一些renpy不支援的特效。於是renpy也支援在renpy中插入python語法。</p>

<p>最基本的插入法可看下列程式碼</p>

<pre><code class="language-python">$ x = &quot;abc&quot;
$ y = &quot;def&quot;

python:
    x = &quot;abc&quot;
    y = &quot;def&quot;
</code></pre>

<p>這兩種寫法都是同義的，如果你只想寫一行python，可以考慮使用 $ 符號，如果你想一次撰寫多行(例如function)可以用python:的方式來撰寫。</p>

<p>在label區段中，插入python code應該沒任何問題，不過在init區段的screen language當中，插入python的位置就要小心。</p>

<pre><code class="language-python">screen test:
    python:
        def func():
            pass
    frame:
        textbutton &quot;abc&quot;:
            action Function(func)
</code></pre>

<pre><code class="language-python">screen test:
    frame:
        python:
            def func():
                pass
        textbutton &quot;abc&quot;:
            action Function(func)
</code></pre>

<p>這兩個寫法只是將python code稍微移動一下而已，但是下面那個版本在renpy 6.98的版本會找不到func。可能跟renpy的載入順序有關。
所以我個人是建議使用若要在screen中使用python，最好在使用前的上一層結構就先行定義。
但，如果是使用 $ 符號，好像就沒有這個問題。</p>

<p>python區段也可以為init，在最初的時候就先行載入，而非等到程式執行到了才動態載入。語法如下</p>

<pre><code class="language-python">init 2 python:
    x = &quot;abc&quot;
</code></pre>

<p>同樣的init後面的數字為載入之優先權，若無指定則為0。</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-03-04/">
        在AOSP中增加預設app (3) : 利用Android Studio來進行編輯
      </a>
    </h1>

    <span class="post-date">Fri, Mar 4, 2016</span>

    

<h1 id="平台及環境設置">平台及環境設置</h1>

<p>##平台
實驗平台：Nexus 5
Android版本：android-4.4_r1
前置知識： [Howto Build Android KitKat (4.4) for the Google Nexus 5][6]</p>

<p>##環境設置
在AOSP資料夾中</p>

<pre><code class="language-bash">source build/envsetup.sh
lunch aosp_hammerhead-userdebug
</code></pre>

<h1 id="目標-利用android-studio來新增app-命名為world">目標：利用Android Studio來新增APP (命名為World)</h1>

<p>在上一篇文章中，說明了如何copy一份已有的project來改寫。但是寫Android App有許多煩雜的地方，有時候還是需要IDE來幫助比較快，這裡找了一個比較tricky的方法來使用IDE。</p>

<h2 id="新增android-studio-project">新增Android Studio Project</h2>

<p>我們直接從Android Studio中產生一個空的project，命名為<code>World</code>。
新增project時記得選empty Activity，之後比較好做。
<img src="http://i.imgur.com/LTorwRZ.png" alt="Alt Text" /></p>

<h2 id="建立soft-link">建立soft link</h2>

<p>在剛剛產生出來的Android Project路徑底下，<code>World/app/src/main</code>應該有<strong>java、res</strong>資料夾，以及<strong>AndroidManifest.xml</strong>。
在<code>AOSP/packages/apps</code>建立新目錄<code>World</code>，並在其底下建立起上述3個檔案之<a href="http://linux.vbird.org/linux_basic/0230filesystem.php#ln" title="鳥哥 - ln解說">軟連結(soft link)</a>。</p>

<pre><code class="language-bash">mkdir $ANDROID_BUILD_TOP/packages/apps/World &amp;&amp; cd $_
ln -s AndroidProject目錄/World/app/src/main/java  java
ln -s AndroidProject目錄/World/app/src/main/res  res
ln -s AndroidProject目錄/World/app/src/main/AndroidManifest.xml  AndroidManifest.xml
</code></pre>

<h2 id="撰寫android-mk">撰寫Android.mk</h2>

<p>參考<a href="http://android.mk/" title="Secrets of Android.mk">Secrets of Android.mk</a>此份文件當中的<strong>Building a simple APK</strong>目錄。將其加到<code>AOSP/packages/apps/World</code>資料夾下。</p>

<p>```makefile Android.mk
  LOCAL_PATH := $(call my-dir)
  include $(CLEAR_VARS)</p>

<p># Build all java files in the java subdirectory
  LOCAL_SRC_FILES := $(call all-subdir-java-files)</p>

<p># Name of the APK to build
  LOCAL_PACKAGE_NAME := LocalPackage</p>

<p># Tell it to build an APK
  include $(BUILD_PACKAGE)</p>

<pre><code>
## 修改掉所有appcompat的部份
再來使用`mm`在`AOSP/packages/apps/World`進行編譯，運氣不好的話，編譯會出現找不到某些命名的錯誤。這是因為Google為了讓各種app看起來更有一致性，將Android Studio的新Project皆使用Appcompat此library來協調視覺效果。可是此library並不存在於預設的編譯環境當中。為了為了節省麻煩，將其去掉。

```xml style.xml
&lt;resources&gt;

    &lt;!-- Base application theme. --&gt;
    &lt;style name=&quot;AppTheme&quot; parent=&quot;android:Theme.Holo.Light.DarkActionBar&quot;&gt;
        &lt;!-- Customize your theme here. --&gt;
    &lt;/style&gt;

&lt;/resources&gt;
</code></pre>

<p>並把MainActivity中可能會用<strong>ActionBarActivity</strong>或是<strong>AppCompatActivity</strong>來替代Activity，請一律換成Activity來使用。
```java MainActivity.java
package com.android.world;</p>

<p>import android.app.Activity;
import android.os.Bundle;</p>

<p>public class MainActivity extends Activity{</p>

<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
}
</code></pre>

<p>}</p>

<pre><code>
最後，我在編譯途中還遇到標籤問題。預設的編譯環境似乎不允許著無命名的字串存在。也就是說，如果你有任何的**text**標籤是直接給予字串值的，可能會編譯失敗。
```xml 修改前
&lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Hello World&quot; /&gt;
</code></pre>

<p>可能要改將字串引用自string.xml才能編譯成功。
```xml 修改後
<TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/app_name" /></p>

<pre><code>```xml res/values/string.xml
&lt;resources&gt;
    &lt;string name=&quot;app_name&quot;&gt;World&lt;/string&gt;
&lt;/resources&gt;
</code></pre>

<h2 id="編譯">編譯</h2>

<p>使用<code>mm</code>進行編譯，此次應該可以順利通過了。
之後直接在Android Studio裡對Application進行編輯，由於建立了軟連結，AOSP內部的內容也會同步更改。
這樣就可以用Android Studio來撰寫APP囉。</p>

<h1 id="reference">Reference</h1>

<ul>
<li><a href="http://android.mk/" title="Secrets of Android.mk">Android.mk</a></li>
<li><a href="http://linux.vbird.org/linux_basic/0230filesystem.php#ln" title="鳥哥 - ln解說">鳥哥 - ln解說</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-02-28/">
        在AOSP中增加預設app (2) : 自行編譯
      </a>
    </h1>

    <span class="post-date">Sun, Feb 28, 2016</span>

    

<h1 id="平台及環境設置">平台及環境設置</h1>

<p>##平台
實驗平台：Nexus 5
Android版本：android-4.4_r1
前置知識： [Howto Build Android KitKat (4.4) for the Google Nexus 5][6]</p>

<p>##環境設置
在AOSP資料夾中</p>

<pre><code class="language-bash">source build/envsetup.sh
lunch aosp_hammerhead-userdebug
</code></pre>

<p>#目標：加入一個需編譯的預設App到AOSP裡</p>

<p>在<code>AOSP/development/samples</code>裏面有許多可以借鑒的對象。
這次學習的目錄為<code>AOSP/development/samples/HelloActivity/</code></p>

<h2 id="複製資料夾">複製資料夾</h2>

<p>首先我們先把這個資料夾複製到<code>packages/app/</code>裏面</p>

<pre><code class="language-bash">cp $ANDROID_BUILD_TOP/development/samples/HelloActivity   $ANDROID_BUILD_TOP/packages/apps/
</code></pre>

<h2 id="使用mm進行編譯">使用mm進行編譯</h2>

<p>在<code>packages/apps/HelloActivity</code>內進行<code>mm</code>編譯。</p>

<pre><code class="language-bash">cd $ANDROID_BUILD_TOP/packages/apps/HelloActivity
mm
</code></pre>

<h2 id="解析">解析</h2>

<p>原本想長篇大論，但是好像有人寫的比我好XD
只好直接給<a href="http://kezeodsnx.pixnet.net/blog/post/26377152-%5B%E8%BD%89%E8%B2%BC%5Dandroid%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%EF%BC%9Ahelloactivity" title="Android的應用程序結構分析">連結</a>，有空再來寫自己的版本吧。
懂的HelloAcitivity的結構之後，就可以對其進行修改，以符合自己的需求。
對於Android.mk若有什麼不懂的也可參考上次<a href="http://android.mk/" title="Secrets of Android.mk">這篇</a>。</p>

<h1 id="reference">Reference</h1>

<ul>
<li><a href="http://kezeodsnx.pixnet.net/blog/post/26377152-%5B%E8%BD%89%E8%B2%BC%5Dandroid%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%EF%BC%9Ahelloactivity" title="Android的應用程序結構分析">Android的應用程序結構分析</a></li>
<li><a href="http://android.mk/" title="Secrets of Android.mk">Secrets of Android.mk</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2016-02-24/">
        在AOSP中增加預設app (1) : prebuilt apk
      </a>
    </h1>

    <span class="post-date">Wed, Feb 24, 2016</span>

    

<h1 id="平台及環境設置">平台及環境設置</h1>

<p>##平台
實驗平台：Nexus 5
Android版本：android-4.4_r1
前置知識： <a href="https://nosemaj.org/howto-build-android-kitkat-nexus-5" title="Howto Build Android KitKat (4.4) for the Google Nexus 5">Howto Build Android KitKat (4.4) for the Google Nexus 5</a></p>

<p>##環境設置
在AOSP資料夾中</p>

<pre><code class="language-bash">source build/envsetup.sh
lunch aosp_hammerhead-userdebug
</code></pre>

<h1 id="目標-在aosp當中加入一個已經編譯好的apk檔-hello-apk">目標：在AOSP當中加入一個已經編譯好的apk檔，Hello.apk</h1>

<h2 id="手動編譯設置">手動編譯設置</h2>

<p>預設的app放在 <code>AOSP/packages/apps</code>下，任意觀看此目錄下的資料夾，會發現皆有<strong>Android.mk</strong>此檔案，此為AOSP編譯規則。
參看 <a href="http://android.mk/" title="Secrets of Android.mk">Secrets of Android.mk</a>此份文件中的<a href="http://android.mk/#prebuiltAPK">Adding a prebuilt APK</a>章節。</p>

<p>依樣畫葫蘆，在<code>AOSP/packages/apps</code>目錄中手動創造Hello資料夾，放入Android.mk。
``` makefile Android.mk
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)</p>

<h1 id="module-name-should-match-apk-name-to-be-installed">Module name should match apk name to be installed.</h1>

<p>LOCAL_MODULE := Hello
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_CERTIFICATE := PRESIGNED</p>

<p>include $(BUILD_PREBUILT)</p>

<pre><code>
並使用Android Studio(或eclipse)隨便製造出一個Hello.apk，同樣將其放置在`AOSP/packages/apps`目錄下。
在[設置好環境][3]後，使用指令`mm`在Hello資料夾底下進行編譯，即可將檔案複製到`AOSP/out/target/product/板子名/system/app/`裏面去。
最後執行`make snod`即可將此apk包入system.img之中。

&gt; 註：若放置的apk沒簽名，可能會出現
`build/core/prebuilt.mk:122: *** No LOCAL_CERTIFICATE specified for prebuilt &quot;packages/apps/Hello/Hello .apk&quot;.  Stop.`
此錯誤訊息。
關於如何產生簽名過後的apk，可參看[Android官網][5]。
眼尖的人應該注意到，在上述的Android.mk當中多了一行`LOCAL_CERTIFICATE := PRESIGNED`，若沒有此行，則即使在Android Studio中已經編譯出簽名過後的apk，依然會出現錯誤訊息。要小心。

## 自動編譯設置
上述的手動編譯可總結為三步驟
1. 在AOSP/packages/apps裡新增Hello資料夾，並放入Android.mk與Hello.apk
2. 在Hello資料夾使用指令`mm`，檔案會複製到`AOSP/out/target/product/板子名/system/app/`
3. 使用指令`make snod`將檔案打包進system.img之中

想像每次修改檔案，皆需重複執行2,3步驟，不太方便。若有不只一個的pre-built apk，則進入每個資料夾使用mm更是麻煩。所以我們要修改make規則，讓AOSP在執行make時，也能偵測到這些新增資料夾。
修改的地方位在`AOSP/build/target/product/generic_no_telephony.mk`，可以發現這個檔案中有不少的原生app名稱。
將`Hello`加入`PRODUCT_PACKAGES`之下。如
```makefile generic_no_telephony.mk
(...省略...)
 PRODUCT_PACKAGES := \
      Hello
(...省略...)
</code></pre>

<p>如此一來就可以在一般make時偵測到<code>AOSP/packages/apps</code>所新增的Hello資料夾。</p>

<h1 id="reference">Reference</h1>

<ul>
<li><a href="https://nosemaj.org/howto-build-android-kitkat-nexus-5" title="Howto Build Android KitKat (4.4) for the Google Nexus 5">Howto Build Android KitKat (4.4) for the Google Nexus 5</a></li>
<li><a href="http://android.mk/" title="Secrets of Android.mk">Secrets of Android.mk</a></li>
<li><a href="http://stackoverflow.com/questions/10579827/add-apk-files-in-aosp" title="Add .apk files in aosp">Add .apk files in aosp</a></li>
<li><a href="https://source.android.com/source/building.html#initialize" title="Set up environment">Building the System</a></li>
<li><a href="http://mrslowblog.blogspot.tw/2013/01/sign-apk-android-app.html" title=" [教學]簽署應用程式 sign APK 發佈 Android App "> [教學]簽署應用程式 sign APK 發佈 Android App </a></li>
<li><a href="http://developer.android.com/intl/zh-tw/tools/publishing/app-signing.html" title="Signing Your Applications">Signing Your Applications</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2015-08-12/">
        在mutt設定gmail
      </a>
    </h1>

    <span class="post-date">Wed, Aug 12, 2015</span>

    

<h1 id="總設定">總設定</h1>

<pre><code>set editor = &quot;vim&quot;
set send_charset=&quot;us-ascii:utf-8&quot;
set from = &quot;你的帳號@gmail.com&quot;  
set realname = &quot;你的名字 可隨便打&quot;
set imap_user = &quot;你的帳號@gmail.com&quot;  
set imap_pass = &quot;你的密碼&quot;  
set folder = &quot;imaps://imap.gmail.com:993&quot;  
set spoolfile = &quot;+INBOX&quot;  
set postponed =&quot;+[Gmail]/Drafts&quot;  
set header_cache =~/.mutt/cache/headers  
set message_cachedir =~/.mutt/cache/bodies  
set certificate_file =~/.mutt/certificates  
set smtp_url = &quot;smtp://你的帳號@smtp.gmail.com:587/&quot;  
set smtp_pass = &quot;你的密碼&quot;  
set move = no
set imap_keepalive = 900  

bind pager &lt;up&gt; previous-line #scroll inside the message rather than the index
bind pager &lt;down&gt; next-line
bind index &lt;left&gt; last-entry
bind pager &lt;left&gt; exit
bind index &lt;right&gt; display-message
bind pager &lt;right&gt; next-page
bind browser &lt;right&gt; select-entry 
</code></pre>

<h1 id="細部設定">細部設定</h1>

<h2 id="編碼與編輯器">編碼與編輯器</h2>

<p>通常在Ubuntu底下的預設編輯器是nano而不是vim，所以需要調整。
utf-8則是<a href="http://lxr.free-electrons.com/source/Documentation/email-clients.txt">Linux Cross Reference</a>中建議的。</p>

<pre><code>set editor = &quot;vim&quot;
set send_charset=&quot;us-ascii:utf-8&quot;
</code></pre>

<h2 id="imap">imap</h2>

<p>imap的服務可以讓你同步本機端與雲端上的信件，當你在mutt刪除/標記信件，gmail的內容也會隨之改變。
使用這項服務前請記得到gmail中，設定-&gt;轉寄和POP/IMAP-&gt;IMAP存取-&gt;啟用IMAP
需要設定的項目有imap_user,imap_pass,folder。
- imap_user無須贅言，你的gmail帳號。
- imap_pass此處輸入密碼，但有兩種情況。
  - 無二階段驗證：使用你平常的密碼即可。
  - 有二階段驗證：必須申請應用程式密碼，請參閱<a href="https://support.google.com/accounts/answer/185833?hl=zh-Hant">使用應用程式密碼登入</a>。
- folder統一使用imaps://imap.gmail.com:993即可，可參閱<a href="https://support.google.com/mail/troubleshooter/1668960?hl=zh-Hant#ts=1665018,1665144">開始使用 IMAP 和 POP3</a>。</p>

<pre><code>set imap_user = &quot;你的帳號@gmail.com&quot;  
set imap_pass = &quot;你的密碼&quot;  
set folder = &quot;imaps://imap.gmail.com:993&quot;  
</code></pre>

<h2 id="smtp">smtp</h2>

<p>設定smtp可以讓你的mutt可以透過gmail傳送信件，可參考<a href="https://support.google.com/mail/answer/78775?hl=zh-Hant">使用 POP 或 IMAP 發送郵件時遇到問題</a>
smtp_pass同imap密碼。</p>

<pre><code>set smtp_url = &quot;smtp://你的帳號@smtp.gmail.com:587/&quot;  
set smtp_pass = &quot;你的密碼&quot;  
</code></pre>

<h2 id="其他設定">其他設定</h2>

<p>下面是由 <a href="http://go2linux.garron.me/linux/2010/10/how-send-email-command-line-gmail-mutt-789/">How to send email from the command line - Gmail Mutt -</a> 照抄來的設定</p>

<pre><code>set spoolfile = &quot;+INBOX&quot;  
set postponed =&quot;+[Gmail]/Drafts&quot;  
set header_cache =~/.mutt/cache/headers  
set message_cachedir =~/.mutt/cache/bodies
set certificate_file =~/.mutt/certificates

set move = no
set imap_keepalive = 900  
</code></pre>

<h2 id="快捷鍵">快捷鍵</h2>

<p>原始的鍵盤設定有點彆扭，如果你在讀email時按&rdquo;下&rdquo;，則會跳至下一封信，而非下一行。
透過更改快捷鍵把他改成類似bbs的設定。
上：讀信件時向上一行
下：讀信件時向下一行
左：讀信件時離開信件，在信件目錄時跳到最底部的信件
右：讀信件時向下一頁，在信件目錄時進入信件，在信箱時進入信箱</p>

<pre><code>bind pager &lt;up&gt; previous-line #scroll inside the message rather than the index
bind pager &lt;down&gt; next-line
bind index &lt;left&gt; last-entry
bind pager &lt;left&gt; exit
bind index &lt;right&gt; display-message
bind pager &lt;right&gt; next-page
bind browser &lt;right&gt; select-entry 
</code></pre>

<h1 id="reference">Reference</h1>

<ul>
<li><a href="http://lxr.free-electrons.com/source/Documentation/email-clients.txt">Linux Cross Reference</a></li>
<li><a href="https://support.google.com/accounts/answer/185833?hl=zh-Hant">使用應用程式密碼登入</a></li>
<li><a href="https://support.google.com/mail/troubleshooter/1668960?hl=zh-Hant#ts=1665018,1665144">開始使用 IMAP 和 POP3</a></li>
<li><a href="https://support.google.com/mail/answer/78775?hl=zh-Hant">使用 POP 或 IMAP 發送郵件時遇到問題</a></li>
<li><a href="http://go2linux.garron.me/linux/2010/10/how-send-email-command-line-gmail-mutt-789/">How to send email from the command line - Gmail Mutt -</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2015-06-10/">
        llvm - helloworld
      </a>
    </h1>

    <span class="post-date">Wed, Jun 10, 2015</span>

    

<h1 id="環境設置">環境設置</h1>

<ul>
<li>ubuntu體系：sudo apt-get install llvm</li>
<li>MAC: brew install llvm</li>
</ul>

<h1 id="makefile-mac">makefile (MAC)</h1>

<pre><code>BIN_PATH=/usr/local/Cellar/llvm/3.6.1/bin/
export PATH:=$(PATH):$(BIN_PATH)
LLVM_CONFIG=llvm-config 
FLAGS= --cxxflags --ldflags --system-libs --libs core

toy: toy.cpp
    clang++ -g -O3 toy.cpp `$(LLVM_CONFIG) $(FLAGS)` -o toy
clean:
    rm -f toy
</code></pre>

<h1 id="top-module">top module</h1>

<pre><code>#include &quot;llvm/LLVMContext.h&quot;
#include &quot;llvm/Module.h&quot;
#include &quot;llvm/Support/IRBuilder.h&quot;

int main()
{
  llvm::LLVMContext&amp; context = llvm::getGlobalContext();
  llvm::Module* module = new llvm::Module(&quot;top&quot;, context);
  llvm::IRBuilder&lt;&gt; builder(context); 

  module-&gt;dump( );
}
</code></pre>

<h1 id="function">function</h1>

<h2 id="宣告function">宣告function</h2>

<ul>
<li>無參數</li>
</ul>

<pre><code>  llvm::FunctionType *funcType = 
      llvm::FunctionType::get(builder.getInt32Ty(), false);
  llvm::Function *mainFunc = llvm::Function::Create(funcType, llvm::Function::ExternalLinkage, &quot;main&quot;, module);
</code></pre>

<ul>
<li>有參數</li>
</ul>

<pre><code>  std::vector&lt; llvm::Type* &gt; putsArgs;
  putsArgs.push_back(builder.getInt8Ty()-&gt;getPointerTo());
  llvm::ArrayRef&lt; llvm::Type* &gt;  argsRef(putsArgs);

  llvm::FunctionType *putsType = 
    llvm::FunctionType::get(builder.getInt32Ty(), argsRef, false);
</code></pre>

<h2 id="定義function">定義function</h2>

<ul>
<li>引用已有的function</li>
</ul>

<pre><code>  llvm::Constant *putsFunc = module-&gt;getOrInsertFunction(&quot;puts&quot;, putsType);
</code></pre>

<ul>
<li>創造新的function</li>
</ul>

<pre><code>  llvm::BasicBlock *entry = llvm::BasicBlock::Create(context, &quot;entrypoint&quot;, mainFunc);
  builder.SetInsertPoint(entry);
</code></pre>

<p>增添function內容</p>

<h1 id="新增變數">新增變數</h1>

<ul>
<li>global variable</li>
</ul>

<pre><code>  llvm::Value *helloWorld = builder.CreateGlobalStringPtr(&quot;hello world!\n&quot;);
</code></pre>

<ul>
<li>local variable</li>
</ul>

<h1 id="reference">Reference</h1>

<p><a href="http://www.ibm.com/developerworks/library/os-createcompilerllvm1/">Create a working compiler with the LLVM framework</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2015-06-07/">
        在linux上跑git server
      </a>
    </h1>

    <span class="post-date">Sun, Jun 7, 2015</span>

    

<h1 id="環境設定">環境設定</h1>

<p>系統: linux mint
套件: <code>sudo apt-get install openssh-server git</code></p>

<h1 id="基本操作">基本操作</h1>

<p>安裝完openssh-server和git後，即可開始嘗試創建remote repository。
為了之後的安全性議題，創建一個新的帳號來管理git server</p>

<pre><code>sudo adduser git
</code></pre>

<p>下方指令新增project.git目錄做為remote repository
(我新增在此帳號的家目錄下，而git官方文件則是放在 /opt/git/ 裡)</p>

<pre><code>su git
mkdir /home/git/project.git
cd /home/git/project.git
git --bare init
</code></pre>

<p>remote repository已經建立，可以開始使用。
<strong>git@gitserver</strong> 代表 <strong>登入帳號@serverIP位置</strong>
試著用ssh連線抓下git repository吧。</p>

<pre><code>git clone git@gitserver:/home/git/project.git
git remote -v
origin git@gitserver:/home/git/project.git (fetch)
origin git@gitserver:/home/git/project.git (push)
</code></pre>

<p>當然push pull指令也沒問題囉~ 只要有該帳戶密碼即可。</p>

<pre><code>git push origin master
git pull origin master
</code></pre>

<h1 id="安全性議題-ssh-public-key-authentication">安全性議題 - SSH Public Key Authentication</h1>

<p>上述推送git repository的流程中，只需要有帳號密碼即可登入。
我們可以改以更安全的SSH Public Key Authentication來登入</p>

<h2 id="client">client</h2>

<p>在terminal上輸入<code>ssh-keygen</code>
全部使用預設值後，成對的公私鑰會出現在~/.ssh裡
- 公鑰:id_rsa.pub
- 私鑰:id_rsa</p>

<p>公鑰長起來像這樣</p>

<pre><code>ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4LojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4kYjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9EzSdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myivO7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPqdAv8JggJICUvax2T9va5 gsg-keypair
</code></pre>

<h2 id="server">server</h2>

<p>登入管理git server的帳戶</p>

<pre><code>su git
</code></pre>

<p>把允許連到這個server的用戶公鑰，複製貼上到~/.ssh/authorized_keys文件中。</p>

<pre><code>mkdir ~/.ssh
vi ~/.ssh/authorized_keys
</code></pre>

<p>authorized_keys中，有幾個公鑰就放幾行。</p>

<pre><code>公鑰1
公鑰2
公鑰3
...
</code></pre>

<h1 id="安全性議題-限制shell功能">安全性議題 - 限制shell功能</h1>

<p>如果有人遠端登入伺服器後，使用vi、rm、touch等指令隨便更改repository內容，豈不是很危險。
因此要限制此帳戶只能拿來做為唯一用途──推送版本庫。
將原本的bash-shell改為git-shell，使此帳戶只剩下git相關功能吧。
編輯權限檔</p>

<pre><code>sudo vim /etc/passwd
</code></pre>

<p>passwd檔案底會出現剛剛的帳戶，這行可能長這樣。</p>

<pre><code>git:x :1001:1001:/home/git:/bin/sh
</code></pre>

<p>由左到右分別代表
<strong>帳戶:密碼(以x代替):UID(使用者識別碼):GID(群組識別碼):家目錄位置:使用的shell</strong>
將shell替代成git-shell，使此帳戶只剩下git相關功能。</p>

<pre><code>git:x :1001:1001::/home/git:/usr/bin/git-shell
</code></pre>

<p>git-shell的位置可以用下列指令找到</p>

<pre><code>which git-shell
</code></pre>

<p>調整完權限後，再想以ssh登入此帳戶就會出現</p>

<pre><code>$ ssh git@gitserver
Welcome to Linux Mint 17.1 Rebecca (GNU/Linux 3.13.0-37-generic x86_64)
Welcome to Linux Mint
 * Documentation:  http://www.linuxmint.com
Last login: Sat Jun  6 19:55:30 2015 from localhost
fatal: Interactive git shell is not enabled.
hint: ~/git-shell-commands should exist and have read and execute access.
Connection to gitserver closed.
</code></pre>

<p>此帳號無法再使用shell囉~</p>

<h1 id="reference">reference</h1>

<ul>
<li><a href="https://git-scm.com/book/zh-tw/v1/%E4%BC%BA%E6%9C%8D%E5%99%A8%E4%B8%8A%E7%9A%84-Git">git server官方文件</a></li>
<li><a href="http://linux.vbird.org/linux_basic/0410accountmanager.php#passwd_file">/etc/passwd文件含意</a></li>
<li><a href="http://blogger.gtwang.org/2014/05/linux-ssh-public-key-authentication.html">ssh產生金鑰</a></li>
<li><a href="http://blog.udn.com/nigerchen/2262865">ssh安全性設定</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2015-06-06/">
        llvm study
      </a>
    </h1>

    <span class="post-date">Sat, Jun 6, 2015</span>

    

<h1 id="overview">Overview</h1>

<p>llvm 示意圖
<img src="http://www.aosabook.org/images/llvm/SimpleCompiler.png" alt="" />
<img src="http://i.imgur.com/YWNh2wy.png" alt="" />
通過front end後程式碼會被轉為中間碼( LLVM Intermediate Representation (IR) )
紅色部分為llvm提供的功能。
出作業應該不會用到1 (要自己寫)，但可能會用到
2. IR interpreter (指令lli)
3. IR compiler (指令 llc)</p>

<h1 id="llvm-指令">llvm 指令</h1>

<pre><code>v    =  operation   type      op1,       op2 ,     opn
%sum =     add             i32      %op1,      %op2  
運算結果   運算元      型態      運算子們
</code></pre>

<h1 id="llvm-function">llvm function</h1>

<p>宣告</p>

<pre><code>define i32            @add1       (   i32 %a,   i32 %b )
define 回傳型態 @函數名稱(  參數列          ) 
</code></pre>

<p>回傳</p>

<pre><code>ret i32 5                       ; 回傳integer ，值為5
ret void                        ; 回傳void
ret { i32, i8 } { i32 4, i8 2 } ; 回傳結構 {int 32, int 8} ,  值為 4 , 2
</code></pre>

<p>範例</p>

<pre><code>define i32 @add1(i32 %a, i32 %b) {
entry:
  %tmp1 = add i32 %a, %b
  ret i32 %tmp1
}
</code></pre>

<h1 id="identifiers">Identifiers</h1>

<ul>
<li>regular expression: &lsquo;[%@][a-zA-Z$._][a-zA-Z$._0-9]*&lsquo;.<br /></li>
<li>@全域變數</li>
<li>%區域變數</li>
<li>雙引號為字串，可用跳脫字元 \， 後面接ASCII code (ex: 換行為\0A, 而非\n)</li>
<li>@1 $2這些應該是暫存變數(不確定)</li>
<li>全部皆為SSA(single static assigment)

<ul>
<li>將變數編上編號</li>
<li>每個變數只會賦值一次
<br /></li>
</ul></li>
</ul>

<h1 id="利用clang-front-end-做測試">利用clang front end 做測試</h1>

<p>安裝</p>

<pre><code>sudo apt-get install clang llvm
</code></pre>

<p>把C code 變成 llvm IR (以test.c為例)</p>

<pre><code>clang test.c -emit-llvm -S
</code></pre>

<p>C code</p>

<pre><code>#include&lt;stdio.h&gt;
int main()
{
    int a, b;
    a = 1;
    b = a + 1;
    printf(&quot;%d\n&quot;, b);
}
</code></pre>

<p>llvm IR (test.ll)</p>

<pre><code>; Function Attrs: nounwind uwtable
define i32 @main() #0 {
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  store i32 1, i32* %a, align 4
  %1 = load i32* %a, align 4
  %2 = add nsw i32 %1, 1
  store i32 %2, i32* %b, align 4
  %3 = load i32* %b, align 4
  %4 = call i32 (i8*, ...)* @printf(i8* getelementptr inbounds ([4 x i8]* @.str, i32 0, i32 0), i32 %3)
  ret i32 0
}

declare i32 @printf(i8*, ...) #1
</code></pre>

<h2 id="1-用interpreter執行llvm-ir">1. 用interpreter執行llvm IR</h2>

<pre><code>lli test.ll
</code></pre>

<h2 id="2-把llvm-ir-編譯成assembly-code">2. 把llvm IR 編譯成assembly code</h2>

<pre><code>llc test.ll
</code></pre>

<p>產生出 test.s
利用clang把assembly轉成machine code</p>

<pre><code>clang test.ll
</code></pre>

<p>執行</p>

<pre><code>./test.ll
</code></pre>

<h1 id="結論">結論</h1>

<p>用llvm學習compiler，不需考慮暫存器分配(assembly code geneate)，但需要考慮SSA。</p>

<h1 id="參考資料">參考資料</h1>

<p><a href="http://www.slideshare.net/kitocheng/ss-42438227">神人投影片</a>
<a href="http://llvm.org/docs/LangRef.html">llvm reference</a></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/post/2015-06-05/">
        git 基本指令
      </a>
    </h1>

    <span class="post-date">Fri, Jun 5, 2015</span>

    <p>初始化</p>

<pre><code>git init
git config --global user.name &quot;你的ID&quot;
git config --global user.email &quot;你的信箱&quot;
</code></pre>

<p>狀態
    git status</p>

<p>新增</p>

<pre><code>git add 檔名
git add -A
git add -u
</code></pre>

<p>提交</p>

<pre><code>git commit -m &quot;改動訊息&quot;
</code></pre>

<p>歷史訊息</p>

<pre><code>git log
</code></pre>

<p>忽略</p>

<pre><code>.gitignore
</code></pre>

<p>比較不同</p>

<pre><code>git diff (工作和暫存)
git diff 分支名稱 (工作和分支)
</code></pre>

<p>分支(版本)名稱
HEAD(目前頭分支) : HEAD HEAD^ HEAD^^ HEAD^^^
master(branch名)
695606fc5e31&hellip;.. (commit hash名)</p>

<p>重置</p>

<pre><code>git reset --hard 分支名稱(分支覆蓋暫存區和工作區，後悔藥，危險不可逆)
git reset 分支名稱 (分支覆蓋暫存區，通常拿來撤銷git add操作)

git checkout 分支名稱 (看以前的版本)

git tag -m &quot;wahaha version 1000&quot; v_1000
</code></pre>

<p>在git中，為了吃後悔藥，完成一個小功能立刻commit
在git中，為了找尋方便，完成大改版記得tag</p>

<pre><code>git describe (方便產生版本號)
</code></pre>

<p>老闆叫你交東西給客戶 但是你程式改到一半</p>

<pre><code>git stash
git stash pop
</code></pre>

<p>交成品囉 []裡面為可加可不加的內容</p>

<pre><code>git archive -o 輸出.zip 分支名稱 [想要複製的資料夾/檔案，可多個]
git archive -o output.zip HEAD src obj
</code></pre>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/about/">
        About
      </a>
    </h1>

    <span class="post-date">Mon, Jan 1, 0001</span>

    <p>Denny Cheng / 月月冬瓜<br />
獸控兼工程師，目前寫Android、IOS和UWP。<br />
家有大貓程式。<br />
我的噗浪：<a href="https://www.plurk.com/cdfq152313">https://www.plurk.com/cdfq152313</a><br />
我的信箱：cdfq152313@gmail.com</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://cdfq152313.github.io/tags/">
        標籤列表
      </a>
    </h1>

    <span class="post-date">Mon, Jan 1, 0001</span>

    <ul>
<li><a href="/tags/general">general</a></li>
<li><a href="/tags/android">android</a></li>
<li><a href="/tags/java">java</a></li>
<li><a href="/tags/jni">jni</a></li>
<li><a href="/tags/aosp">AOSP</a></li>
<li><a href="/tags/ios">iOS</a></li>
<li><a href="/tags/swift">Swift</a></li>
<li><a href="/tags/uwp">UWP</a></li>
<li><a href="/tags/compiler">compiler</a></li>
<li><a href="/tags/llvm">LLVM</a></li>
<li><a href="/tags/git">git</a></li>
<li><a href="/tags/python">python</a></li>
<li><a href="/tags/renpy">renpy</a></li>
<li><a href="/tags/cryptography">Cryptography</a></li>
<li><a href="/tags/mutt">mutt</a></li>
</ul>

  </div>
  
</div>
</div>

  </body>
</html>
