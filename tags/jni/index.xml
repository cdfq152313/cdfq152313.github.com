<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jni on Denny&#39;s Blog</title>
    <link>https://cdfq152313.github.io/tags/jni/index.xml</link>
    <description>Recent content in Jni on Denny&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <atom:link href="https://cdfq152313.github.io/tags/jni/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Android JNI 環境建置</title>
      <link>https://cdfq152313.github.io/post/2016-08-05/</link>
      <pubDate>Fri, 05 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>https://cdfq152313.github.io/post/2016-08-05/</guid>
      <description>

&lt;h1 id=&#34;介紹&#34;&gt;介紹&lt;/h1&gt;

&lt;p&gt;主要參考這篇：
&lt;a href=&#34;http://blog.xuite.net/lwchafter30/blog/373974237-Android+studio+1.5.1+NDK+JNI%E7%92%B0%E5%A2%83%E5%AE%89%E8A3%9D%E8%88%87%E5%9F%B7%E8%A1%8C%E5%8E%9F%E7%90%86&#34; title=&#34;Android studio 1.5.1 NDK JNI環境安裝與執行原理&#34;&gt;Android studio 1.5.1 NDK JNI環境安裝與執行原理&lt;/a&gt;
不過Android 2.1.2上步驟稍有簡化，還是可以達到同樣效果。
1. 載NDK
2. 設定external tool (僅javah)
3. 在java中增加native code，並利用javah產生JNI header
4. 實作JNI
5. 設定gradle (僅ndk區塊)&lt;/p&gt;

&lt;h1 id=&#34;載ndk&#34;&gt;載NDK&lt;/h1&gt;

&lt;p&gt;開啟SDK Manager，選擇SDK Tools，將NDK之選項給打勾。
&lt;img src=&#34;http://i.imgur.com/nsDiPAi.png&#34; alt=&#34;SDK Manager&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;設定external-tool&#34;&gt;設定external tool&lt;/h1&gt;

&lt;p&gt;與連結相同，不過只要設定javah即可，其他不需要。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/m4s02Gt.png&#34; alt=&#34;javah設定&#34; /&gt;&lt;/p&gt;

&lt;p&gt;快速複製區 &lt;a href=&#34;http://blog.xuite.net/lwchafter30/blog/373974237-Android+studio+1.5.1+NDK+JNI%E7%92%B0%E5%A2%83%E5%AE%89%E8A3%9D%E8%88%87%E5%9F%B7%E8%A1%8C%E5%8E%9F%E7%90%86&#34; title=&#34;Android studio 1.5.1 NDK JNI環境安裝與執行原理&#34;&gt;來源&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$JDKPath$/bin/javah

-v -jni -d $ModuleFileDir$/src/main/jni $FileClass$

$SourcepathEntry$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Windows和Linux在第1行稍有分別，只有在Windows系統中，執行檔的副檔名才是.exe。Mac和Linux皆否。
個人是用linux系統，所以第1行javah後面並不接.exe，若是Windows系統則第1行變為。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$JDKPath$/bin/javah.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;jni-header&#34;&gt;JNI header&lt;/h1&gt;

&lt;p&gt;在想要使用JNI的class加入如下的程式碼。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    static {
            System.loadLibrary(&amp;quot;myJNI&amp;quot;);
    }
    public native String getMycstring();
    public native void testLog();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;static區塊中的myJNI會變成將來再build gradle當中的moduleName
method加上native關鍵詞後，程式就會知道這是需要依靠JNI實作之程式碼。&lt;/p&gt;

&lt;p&gt;再來在該java檔上按右鍵，使用剛剛建置好的external library javah，自動的產生JNI header。
&lt;img src=&#34;http://i.imgur.com/ag5rJ6c.png&#34; alt=&#34;使用javah&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此時在java目錄下，應該會多出一個jni的資料夾，裡頭放置著 OOXX.h
打開.h檔，建置出來的code應該會如下形式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/* DO NOT EDIT THIS FILE - it is machine generated */
#include &amp;lt;jni.h&amp;gt;
/* Header for class com_example_isa_myapplication_MainActivity */

#ifndef _Included_com_example_isa_myapplication_MainActivity
#define _Included_com_example_isa_myapplication_MainActivity
#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif
/*
 * Class:     com_example_isa_myapplication_MainActivity
 * Method:    getMycstring
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_example_isa_myapplication_MainActivity_getMycstring
  (JNIEnv *, jobject);

/*
 * Class:     com_example_isa_myapplication_MainActivity
 * Method:    testLog
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_example_isa_myapplication_MainActivity_testLog
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;實作jni&#34;&gt;實作JNI&lt;/h1&gt;

&lt;p&gt;步驟如下
1. 在jni資料夾中，新增一個myJNI.cpp
2. include剛剛自動產生的header
3. 實作剛剛只宣告未實作的程式碼
4. (細節注意)&lt;/p&gt;

&lt;h2 id=&#34;新增myjni-cpp&#34;&gt;新增myJNI.cpp&lt;/h2&gt;

&lt;p&gt;在jni資料夾中，新增一個myJNI.cpp&lt;/p&gt;

&lt;h2 id=&#34;include剛剛自動產生的header&#34;&gt;include剛剛自動產生的header&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;quot;com_example_isa_myapplication_MainActivity.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;實作剛剛只宣告未實作的程式碼&#34;&gt;實作剛剛只宣告未實作的程式碼&lt;/h2&gt;

&lt;p&gt;由於Log功能要使用到android/log.h library，所以也要include進來。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;quot;com_example_isa_myapplication_MainActivity.h&amp;quot;
#include &amp;lt;android/log.h&amp;gt;

JNIEXPORT jstring JNICALL Java_com_example_isa_myapplication_MainActivity_getMycstring
  (JNIEnv *env, jobject jobj){
        return (*env).NewStringUTF(&amp;quot;MY !!  NDKString!!&amp;quot;);
  }
  
JNIEXPORT void JNICALL Java_com_example_isa_myapplication_MainActivity_testLog
  (JNIEnv * env, jobject jobj){
    __android_log_print(ANDROID_LOG_INFO, &amp;quot;JNI&amp;quot;, &amp;quot;JNI Test&amp;quot;);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;細節注意&#34;&gt;細節注意&lt;/h2&gt;

&lt;p&gt;當然僅僅如此還不夠，觀看.h檔可以發現有extern &amp;ldquo;C&amp;rdquo;包圍著宣告的函式，所以也要一併複製。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;quot;com_example_isa_myapplication_MainActivity.h&amp;quot;
#include &amp;lt;android/log.h&amp;gt;


#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

JNIEXPORT jstring JNICALL Java_com_example_isa_myapplication_MainActivity_getMycstring
  (JNIEnv *env, jobject jobj){
        return (*env).NewStringUTF(&amp;quot;MY !!  NDKString!!&amp;quot;);
  }
  
  JNIEXPORT void JNICALL Java_com_example_isa_myapplication_MainActivity_testLog
  (JNIEnv * env, jobject jobj){
    __android_log_print(ANDROID_LOG_INFO, &amp;quot;JNI&amp;quot;, &amp;quot;JNI Test&amp;quot;);
  }
  
#ifdef __cplusplus
}
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切記不要連 #ifndef _Included_com_example_isa_myapplication_MainActivity 的相關句子也複製進來。
在.h檔已經定義過，若在.cpp重複定義，則中間的所有內容都會被忽略掉。&lt;/p&gt;

&lt;h1 id=&#34;設定gradle&#34;&gt;設定gradle&lt;/h1&gt;

&lt;p&gt;在defaultConfig這個區塊內加入&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ndk{
  moduleName &amp;quot;myJNI&amp;quot;
  ldLibs &amp;quot;log&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;moduleName為你剛剛在System.loadLibrary裡面設定的名字。
ldLibs &amp;ldquo;log&amp;rdquo;可以讓cpp檔include log功能的時候不會出錯。&lt;/p&gt;

&lt;p&gt;整體看起來是這樣&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android {
    compileSdkVersion 23
    buildToolsVersion &amp;quot;23.0.2&amp;quot;

    defaultConfig {
        applicationId &amp;quot;com.example.isa.myapplication&amp;quot;
        minSdkVersion 15
        targetSdkVersion 23
        versionCode 1
        versionName &amp;quot;1.0&amp;quot;
        ndk{
            moduleName &amp;quot;myJNI&amp;quot;
            ldLibs &amp;quot;log&amp;quot;
        }
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後編譯就完成了。&lt;/p&gt;

&lt;h1 id=&#34;參考資料&#34;&gt;參考資料&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.xuite.net/lwchafter30/blog/373974237-Android+studio+1.5.1+NDK+JNI%E7%92%B0%E5%A2%83%E5%AE%89%E8A3%9D%E8%88%87%E5%9F%B7%E8%A1%8C%E5%8E%9F%E7%90%86&#34; title=&#34;Android studio 1.5.1 NDK JNI環境安裝與執行原理&#34;&gt;Android studio 1.5.1 NDK JNI環境安裝與執行原理&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>